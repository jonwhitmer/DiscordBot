./
    main.py
    resetdata.py
    summary.py
    test.py
    bot/
        activity_tracker.py
        commands.py
        level_widget.py
        __init__.py
        games/
            blackjack.py
            dealerpoker.py
            duel.py
            game_manager.py
            lottery.py
            slots.py
            __init__.py
            __pycache__/
        misc/
            referral.py
            __init__.py
            __pycache__/
        shop/
            shop.py
            __pycache__/
        status/
            offline.py
            online.py
            setup.py
            __pycache__/
        __pycache__/
    data/
        games/
            lottery/
        playerdata/
        serverside/
    settings/
        .env
        settings.py
        json/
        __pycache__/
    utils/
        graphics.py
        __init__.py
        images/
            blackjackdump/
            deckofcards/
                10/
                2/
                3/
                4/
                5/
                6/
                7/
                8/
                9/
                A/
                J/
                K/
                Q/
            levelimages/
            pokerdump/
        sounds/
            bottalking/
            musicdump/
        __pycache__/


.\main.py
import discord
from discord.ext import commands
import os
import subprocess
import sys
import signal
from settings.settings import load_settings
from dotenv import load_dotenv

load_dotenv(dotenv_path='settings/.env')
TOKEN = os.getenv('TOKEN')

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

def update_status_offline():
    script_path = os.path.join('bot', 'status', 'offline.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to OFFLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

def signal_handler(signal, frame):
    print("Signal received, updating status to OFFLINE...")
    update_status_offline()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    await bot.load_extension('bot.activity_tracker')
    await bot.load_extension('bot.commands')
    await bot.load_extension('bot.games.game_manager')
    await bot.load_extension('bot.misc.referral')
    await bot.load_extension('bot.shop.shop')
    print("Extensions loaded")

    # Update the bot status to ONLINE
    script_path = os.path.join('bot', 'status', 'online.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to ONLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

bot.run(TOKEN)


.\resetdata.py
import json

def wipe_activity_data():
    with open('data/player_data.json', 'w') as f:
        json.dump({}, f, indent=4)


wipe_activity_data()

.\summary.py
import os

def generate_directory_tree(directory, exceptions):
    tree = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list or is a .git directory
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions) or '.git' in relative_root:
            continue
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        tree.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list or is a git-related file
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions) and '.git' not in file_relative_path:
                if any(file.endswith(ext) for ext in ['.py', '.env']):
                    tree.append(f"{subindent}{file}")
    return tree

def generate_summary(directory, exceptions, include_extensions):
    summary = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list or is a .git directory
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions) or '.git' in relative_root:
            continue
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list, has an allowed extension, or is a git-related file
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions) and '.git' not in file_relative_path:
                if any(file.endswith(ext) for ext in include_extensions):
                    file_path = os.path.join(root, file)
                    summary.append(file_path)
    return summary

def read_and_prepend_file(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        content = file.read()
    return f"{file_path}\n{content}"

if __name__ == "__main__":
    exceptions = [
        os.path.normpath('extensions/gulp'),
        os.path.normpath('assets/instance/database.db'),
        os.path.normpath('assets/migrations')
    ]  # Add more directories to this list if needed
    include_extensions = [
        '.py'
    ]  # Only include .py files for content
    with open('project_summary.txt', 'w', encoding='utf-8') as f:
        # Write directory tree
        directory_tree = generate_directory_tree('.', exceptions)
        for line in directory_tree:
            f.write(line + '\n')

        f.write('\n\n')  # Separate the directory tree from the file contents

        # Write file contents
        summary = generate_summary('.', exceptions, include_extensions)
        for file_path in summary:
            file_content = read_and_prepend_file(file_path)
            f.write(file_content + '\n\n')


.\test.py
INITIAL_LEVEL_POINTS_NEEDED = 1000  # Starting with a higher initial value
INITIAL_LEVEL = 1

def calculate_level_points(POINTS_NEEDED, CURRENT_LEVEL, growth_factor):
    if CURRENT_LEVEL == 1:
        return INITIAL_LEVEL_POINTS_NEEDED
    else:
        return round(POINTS_NEEDED * growth_factor)

# Calculate total points needed to reach a certain level
def total_points_to_reach_level(target_level, growth_factor):
    total_points = 0
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(2, target_level + 1):
        points_needed = calculate_level_points(points_needed, level, growth_factor)
        total_points += points_needed
    return total_points

# Adjust growth factor to fit the goal
def find_optimal_growth_factor(target_levels, target_points):
    growth_factor = 1.01
    while True:
        match = True
        for target_level, target_point in zip(target_levels, target_points):
            total_points = total_points_to_reach_level(target_level, growth_factor)
            if abs(total_points - target_point) > target_point * 0.01:  # Allow 1% tolerance
                match = False
                break
        if match:
            break
        growth_factor += 0.001
    return growth_factor - 0.001  # Step back to the last valid growth factor

# Target levels and their corresponding total points
target_levels = [10, 100, 300]
target_points = [12000, 97000, 600000]

# Calculate the optimal growth factor
optimal_growth_factor = find_optimal_growth_factor(target_levels, target_points)

# Print the optimal growth factor
print(f"Optimal growth factor: {optimal_growth_factor:.4f}")

# Calculate points needed for each level incrementally
def points_needed_per_level(target_level, growth_factor):
    points_per_level = []
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(1, target_level):
        next_level_points = calculate_level_points(points_needed, level, growth_factor)
        points_per_level.append((level, next_level_points))
        points_needed = next_level_points
    return points_per_level

# Print points needed for each level from 1 to target level
target_level = 500
points_per_level = points_needed_per_level(target_level, optimal_growth_factor)
for level, points in points_per_level:
    print(f"Points needed from level {level} to {level + 1}: {points} points")


.\bot\activity_tracker.py
# activity_tracker.py
import discord
from discord.ext import commands, tasks
import json
import os
import asyncio
import random
from datetime import datetime, timezone
from gtts import gTTS
from pydub import AudioSegment
from settings.settings import load_settings

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

# Variables for point increments and bot testing mode
MESSAGE_POINTS = 15
ONLINE_POINTS = 2
VOICE_CHAT_POINTS = 15

class ActivityTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.activity_data = self.load_activity_data()
        self.reset_daily_stats.start()
        self.track_activity.start()

    def load_activity_data(self):
        if os.path.exists('data/player_data.json'):
            with open('data/player_data.json', 'r') as f:
                return json.load(f)
        return {}

    def save_activity_data(self):
        with open('data/player_data.json', 'w') as f:
            json.dump(self.activity_data, f, indent=4)

    @tasks.loop(hours=24)
    async def reset_daily_stats(self):
        now = datetime.now(timezone.utc)
        if now.hour == 5:  # 5 AM UTC, midnight EST
            for user_id in self.activity_data:
                self.activity_data[user_id]['points_today'] = 0
                print(f"Reset Points Today for {user_id}")
            self.save_activity_data()

    @reset_daily_stats.before_loop
    async def before_reset_daily_stats(self):
        await self.bot.wait_until_ready()

    @tasks.loop(minutes=5)
    async def track_activity(self):
        for guild in self.bot.guilds:
            for member in guild.members:
                if member.status != discord.Status.offline and not member.bot:
                    user_id = str(member.id)
                    if user_id not in self.activity_data:
                        self.activity_data[user_id] = {
                            "username": member.name,
                            "points": 0,
                            "points_today": 0,
                            "level": 1,
                            "messages_sent": 0,
                            "characters_typed": 0,
                            "minutes_in_voice": 0,
                            "minutes_online": 0,
                            "total_talking_time": 0,
                            "coins": 0  # Add coins attribute
                        }
                    self.activity_data[user_id]['minutes_online'] += ONLINE_POINTS  # Increment by ONLINE_POINTS
                    self.save_activity_data()

    def update_user_activity(self, user, points=0, coins=0):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "points": 0,
                "points_today": 0,
                "level": 1,
                "messages_sent": 0,
                "characters_typed": 0,
                "minutes_in_voice": 0,
                "minutes_online": 0,
                "total_talking_time": 0,
                "coins": 0  # Add coins attribute
            }
        previous_level = self.activity_data[user_id]['level']
        self.activity_data[user_id]['points'] += points
        self.activity_data[user_id]['points_today'] += points
        self.activity_data[user_id]['coins'] += coins

        # Check for level up
        new_level, _ = get_current_level(self.activity_data[user_id]['points'])
        if new_level > previous_level:
            self.activity_data[user_id]['level'] = new_level
            # Announce level up in main chat
            self.bot.loop.create_task(
                self.announce_level_up_in_main_chat(user, previous_level, new_level)
            )
            
            # If user is in a voice channel, make the bot join and announce via TTS
            if user.voice and user.voice.channel:
                self.bot.loop.create_task(self.announce_level_up_in_voice(user, previous_level, new_level))

        self.save_activity_data()

    async def announce_level_up_in_main_chat(self, user, previous_level, new_level):
        main_channel = discord.utils.get(user.guild.text_channels, name='licker-talk')
        if main_channel:
            await main_channel.send(f"{user.mention} has leveled up from Level {previous_level} to Level {new_level}. Congratulations, Gilligano!")
            await main_channel.send(f"To celebrate, here's a gift!  Generating..")

            generated_coins = random.randint(0, 15000)
            digits = str(generated_coins)
        
            accumulated_digits = ""

            for digit in digits:
                accumulated_digits += digit
                await main_channel.send(f"{accumulated_digits}")
                await asyncio.sleep(0.5)
            
            await main_channel.send(f"{digits} {coin_icon}")

            user_id = str(user.id)
            self.activity_data[user_id]['coins'] += generated_coins

    async def announce_level_up_in_voice(self, user, previous_level, new_level):
        voice_channel = user.voice.channel
        vc = await voice_channel.connect()
        tts_message = f"{user.display_name} has leveled up from level {previous_level} to level {new_level}. Congratulations, gilligano!"
        
        tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts.mp3')
        tts = gTTS(tts_message, lang='en', tld='co.in')
        tts.save(tts_file_path)

        sound = AudioSegment.from_file(tts_file_path)

        # Deepen the pitch (lowering by 4 semitones)
        new_sound = sound._spawn(sound.raw_data, overrides={
            "frame_rate": int(sound.frame_rate * 0.7)
        }).set_frame_rate(sound.frame_rate)

        # Save the new sound
        new_tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts_deep.mp3')
        new_sound.export(new_tts_file_path, format="mp3")

        vc.play(discord.FFmpegPCMAudio(source=new_tts_file_path))

        while vc.is_playing():
            await asyncio.sleep(1)

        await vc.disconnect()

        # Delete the TTS files after 10 seconds
        await asyncio.sleep(5)
        if os.path.exists(tts_file_path):
            os.remove(tts_file_path)
        if os.path.exists(new_tts_file_path):
            os.remove(new_tts_file_path)

    def update_user_coins(self, user, coins):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "coins": 0,
                # Add other fields as necessary
            }
        self.activity_data[user_id]['coins'] += coins
        self.save_activity_data()

    def transfer_coins(self, from_user, to_user, amount):
        from_user_id = str(from_user.id)
        to_user_id = str(to_user.id)

        if from_user_id not in self.activity_data or to_user_id not in self.activity_data:
            return False, "User data not found."

        if self.activity_data[from_user_id]['coins'] < amount:
            return False, "Insufficient balance."

        self.activity_data[from_user_id]['coins'] -= amount
        self.activity_data[to_user_id]['coins'] += amount
        self.save_activity_data()

        return True, f"Transferred {amount} coins from {from_user.name} to {to_user.name}."

    @commands.Cog.listener()
    async def on_message(self, message):
        if not message.author.bot:
            self.update_user_activity(message.author, points=MESSAGE_POINTS)
            self.activity_data[str(message.author.id)]['messages_sent'] += 1
            self.activity_data[str(message.author.id)]['characters_typed'] += len(message.content)
            self.save_activity_data()

    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if not member.bot:
            user_id = str(member.id)
            if before.channel is None and after.channel is not None:
                # User has joined a voice channel
                print(f"{member.name} has joined a voice channel.")
                self.activity_data[user_id]['voice_join_time'] = datetime.now().timestamp()

            elif before.channel is not None and after.channel is None:
                # User has left a voice channel
                if 'voice_join_time' in self.activity_data[user_id]:
                    time_spent = datetime.now().timestamp() - self.activity_data[user_id]['voice_join_time']
                    points_earned = int(time_spent / 60) * VOICE_CHAT_POINTS
                    print(f"{member.name} has left the voice channel. Points earned: {points_earned}.")
                    self.update_user_activity(member, points=points_earned)
                    self.activity_data[user_id]['total_talking_time'] += int(time_spent / 60)
                    del self.activity_data[user_id]['voice_join_time']

            self.save_activity_data()

    def get_statistics(self, user_id):
        return self.activity_data.get(user_id, {})
    
    def get_User_balance(self, user):
        user_id = str(user.id)
        if user_id in self.activity_data:
            return self.activity_data[user_id].get('coins', 0)
        return 0
    
def points_for_level_transition(level):
    return 10000 if level == 1 else (level + 1) * 5000

def points_for_next_level(current_level):
    total_points = 0
    for level in range(1, current_level + 1):
        total_points += points_for_level_transition(level)
    return total_points

def get_current_level(points):
    level = 1
    while points >= points_for_next_level(level):
        level += 1
    return level, points_for_next_level(level) - points_for_next_level(level - 1)


async def setup(bot):
    await bot.add_cog(ActivityTracker(bot))


.\bot\commands.py
# commands.py
from discord.ext import commands
import discord
from utils.graphics import generate_level_image, generate_statistics_visualization
import pandas as pd
from datetime import datetime, timedelta
import random
import pytz
from settings.settings import load_settings
import subprocess
import sys
import os
import asyncio
from discord.ui import View
from bot.activity_tracker import get_current_level, points_for_next_level
import yt_dlp as youtube_dl
from pydub import AudioSegment
from dotenv import load_dotenv
from tabulate import tabulate
import matplotlib.pyplot as plt
from gtts import gTTS
from pydub import AudioSegment

# Load the .env file
load_dotenv()

# Set the path to ffmpeg from .env file
ffmpeg_path = os.getenv('FFMPEG_PATH')
os.environ["PATH"] += os.pathsep + ffmpeg_path
AudioSegment.converter = os.path.join(ffmpeg_path, 'ffmpeg.exe')
AudioSegment.ffmpeg = os.path.join(ffmpeg_path, 'ffmpeg.exe')
AudioSegment.ffprobe = os.path.join(ffmpeg_path, 'ffprobe.exe')

TESTING = False
settings = load_settings()
coin_icon = settings['coin_icon']

class GeneralCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    
    @commands.command(name='gift')
    async def gift(self, ctx, recipient: discord.Member, amount: int, *, reason: str):
        if amount <= 0:
            await ctx.send("Gift amount must be positive.")
            return

        if ctx.author == recipient:
            await ctx.send(f"You cannot gift {coin_icon} to yourself.")
            return

        activity_tracker = self.bot.get_cog('ActivityTracker')
        success, message = activity_tracker.transfer_coins(ctx.author, recipient, amount)
        
        if success:
            await ctx.send(f"{ctx.author.mention} gifted {amount} {coin_icon} to {recipient.mention} for: {reason}")
        else:
            await ctx.send(f"Failed to gift {coin_icon}: {message}")

    @commands.command(name='forbeslist')
    async def forbeslist(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        all_data = activity_tracker.activity_data

        # Convert data to a list of tuples and sort by coins
        coin_list = [(user_id, data['coins']) for user_id, data in all_data.items() if 'coins' in data]
        sorted_coin_list = sorted(coin_list, key=lambda x: x[1], reverse=True)[:10]

        # Create DataFrame
        data = {
            "Rank": list(range(1, len(sorted_coin_list) + 1)),
            "Player Name": [self.bot.get_user(int(user_id)).display_name if self.bot.get_user(int(user_id)) else "Unknown User" for user_id, _ in sorted_coin_list],
            "Coins": [f"{coins:,}" for _, coins in sorted_coin_list]  # This formats the coins with commas
        }
        df = pd.DataFrame(data)

        # Plot the table with a cleaner style
        fig, ax = plt.subplots(figsize=(5, 2))  # Adjusted figsize for better appearance
        ax.axis('tight')
        ax.axis('off')

        # Create table
        table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center', edges='horizontal')
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 1.2)  # Scale up the table for better readability

        # Customize header row
        for key, cell in table.get_celld().items():
            cell.set_edgecolor('black')
            cell.set_linewidth(1)
            if key[0] == 0:
                cell.set_text_props(weight='bold', color='black') # This should work for the background color

        # Save the table as an image
        image_path = 'utils/images/forbes_list.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)

        # Send the image in Discord
        file = discord.File(image_path, filename='forbes_list.png')
        embed = discord.Embed(title="Forbes List")
        embed.set_image(url="attachment://forbes_list.png")
        await ctx.send(embed=embed, file=file)

        # Clean up the saved image file
        os.remove(image_path)

    @commands.command(name='leaderboard')
    async def leaderboard(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        all_data = activity_tracker.activity_data

        # Convert data to a list of tuples and sort by points
        leaderboard_list = [
            (user_id, data.get('level', 0), data.get('points', 0), data.get('coins', 0))
            for user_id, data in all_data.items()
        ]
        sorted_leaderboard_list = sorted(leaderboard_list, key=lambda x: x[2], reverse=True)[:10]  # Sort by points

        # Create DataFrame
        data = {
            "Rank": list(range(1, len(sorted_leaderboard_list) + 1)),
            "Player Name": [
                self.bot.get_user(int(user_id)).display_name if self.bot.get_user(int(user_id)) else "Unknown User"
                for user_id, _, _, _ in sorted_leaderboard_list
            ],
            "Level": [level for _, level, _, _ in sorted_leaderboard_list],
            "Points": [points for _, _, points, _ in sorted_leaderboard_list],
            "Coins": [coins for _, _, _, coins in sorted_leaderboard_list]
        }
        df = pd.DataFrame(data)

        # Plot the table with a cleaner style
        fig, ax = plt.subplots(figsize=(6, 3))  # Adjusted figsize for better appearance
        ax.axis('tight')
        ax.axis('off')

        # Create table
        table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center', edges='horizontal')
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 1.2)  # Scale up the table for better readability

        # Customize header row
        for key, cell in table.get_celld().items():
            cell.set_edgecolor('black')
            cell.set_linewidth(1)
            if key[0] == 0:
                cell.set_text_props(weight='bold', color='black')  # Bold headers

        # Save the table as an image
        image_path = 'utils/images/leaderboard.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)

        # Send the image in Discord
        file = discord.File(image_path, filename='leaderboard.png')
        embed = discord.Embed(title="Leaderboard")
        embed.set_image(url="attachment://leaderboard.png")
        await ctx.send(embed=embed, file=file)

        # Clean up the saved image file
        os.remove(image_path)

    @commands.command(name='update_notes')
    async def update_notes(self, ctx, *, notes):
        try:
            # Determine if the bot is online or offline
            online_status = True  # Replace with your logic to determine the status

            script_path = os.path.join('bot', 'status', 'online.py' if online_status else 'offline.py')

            # Run the update_additional_notes method in the respective script
            process = subprocess.run([sys.executable, script_path, notes], capture_output=True, text=True)

            if process.returncode == 0:
                print("Successful Notes Change")
            else:
                await ctx.send(f"Failed to update additional notes. Error: {process.stderr}")
        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    @commands.command(name='daily')
    async def daily(self, ctx):
        if ctx.channel.id != 1252055670778368013 and ctx.channel.id != 1259664562924552213:
            await ctx.send("Please utilize the <#1252055670778368013> channel to use the `!daily` command.")
            return
    
        user_id = str(ctx.author.id)
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})

        if ctx.message.content.strip() != '!daily':
            return

        if TESTING:
            last_daily = None
        else:
            last_daily = user_data.get('last_daily', None)

        now = datetime.utcnow()

        if last_daily:
            last_daily_time = datetime.strptime(last_daily, "%Y-%m-%d %H:%M:%S")
            if now < last_daily_time + timedelta(hours = 24):
                next_claim_time = last_daily_time + timedelta(hours = 24)
                est = pytz.timezone('US/Eastern')
                next_claim_time_est = next_claim_time.replace(tzinfo=pytz.utc).astimezone(est)
                next_claim_time_str = next_claim_time_est.strftime('%Y-%m-%d %I:%M:%S %p')
                await ctx.send(f"You have already claimed your daily {coin_icon}.  NEXT CLAIM TIME: {next_claim_time_str} EST.")
                return
            
        daily_coins = random.randint(0, 10000)
        digits = str(daily_coins)

        await ctx.send(f"{ctx.author.mention}, generating your daily coins...")
        
        accumulated_digits = ""
        for digit in digits:
            accumulated_digits += digit
            await ctx.send(f"{accumulated_digits}")
            await asyncio.sleep(0.5)

        activity_tracker.update_user_coins(ctx.author, daily_coins)
        activity_tracker.activity_data[user_id]['last_daily'] = now.strftime('%Y-%m-%d %H:%M:%S')
        activity_tracker.save_activity_data()

        await ctx.send(f"You have been rewarded {daily_coins} {coin_icon} for the day!  Your balance is now {activity_tracker.activity_data[user_id]['coins']} {coin_icon}.")
        
    @commands.command(name='loandisbursement')
    async def loandisbursement(self, ctx):
        if ctx.channel.id != 1252055670778368013 and ctx.channel.id != 1259664562924552213:
            await ctx.send("Please utilize the <#1252055670778368013> channel to use the `!loandisbursement` command.")
            return

        user_id = str(ctx.author.id)
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})

        if ctx.message.content.strip() != '!loandisbursement':
            return

        if TESTING:
            last_loan_disbursement = None
        else:
            last_loan_disbursement = user_data.get('last_loan_disbursement', None)

        now = datetime.utcnow()

        if last_loan_disbursement:
            last_loan_time = datetime.strptime(last_loan_disbursement, "%Y-%m-%d %H:%M:%S")
            if now < last_loan_time + timedelta(hours=24):
                next_claim_time = last_loan_time + timedelta(hours=24)
                est = pytz.timezone('US/Eastern')
                next_claim_time_est = next_claim_time.replace(tzinfo=pytz.utc).astimezone(est)
                next_claim_time_str = next_claim_time_est.strftime('%Y-%m-%d %I:%M:%S %p')
                await ctx.send(f"You have already signaled a loan disbursement today. NEXT SIGNAL TIME: {next_claim_time_str} EST.")
                return

        members = ctx.guild.members
        eligible_members = [member for member in members if not member.bot and member.id != ctx.author.id]

        if not eligible_members:
            await ctx.send("No eligible members found for loan disbursement.")
            return

        random_member = random.choice(eligible_members)
        loan_amount = random.randint(0, 10000)
        digits = str(loan_amount)

        await ctx.send(f"{ctx.author.mention} has signaled a loan disbursement!")
        await ctx.send(f"A lucky member will be getting a loan disbursement!")

        accumulated_digits = ""
        for digit in digits:
            accumulated_digits += digit
            await ctx.send(f"{accumulated_digits}")
            await asyncio.sleep(0.5)

        activity_tracker.update_user_activity(random_member, coins=loan_amount)

        activity_tracker.activity_data[user_id]['last_loan_disbursement'] = now.strftime('%Y-%m-%d %H:%M:%S')
        activity_tracker.save_activity_data()

        await ctx.send(f"{random_member.mention} has been rewarded {loan_amount} {coin_icon} for the day! Their balance is now {activity_tracker.activity_data[str(random_member.id)]['coins']} {coin_icon}.")

    @commands.command(name='medicare')
    async def medicare(self, ctx):
        await ctx.send("Joe Biden has officially beat medicare!")
        await asyncio.sleep(5)
        await ctx.send("Oh wait.. ***I forgot.***")

        # Image URL
        image_url = 'https://www.indy100.com/media-library/image.png?id=33573844&width=1200&height=800&quality=85&coordinates=0%2C14%2C0%2C13'
        
        embed = discord.Embed()
        embed.set_image(url=image_url)
    
        await ctx.send(embed=embed)

    @commands.command(name='boner')
    async def boner(self, ctx):
        responses = [
            "You know you're getting old when your boner takes longer to rise than your morning coffee.",
            "Had a boner this morning...then realized I was just excited for breakfast.",
            "Why don't boners get arrested? They always get off with a stiff warning.",
            "Just saw a guy with a boner in public. I guess some people really are morning people.",
            "Got a boner today, but it was just my cat rubbing against me. Thanks, Fluffy.",
            "Why did my boner cross the road? To get away from my ex.",
            "My boner and I have an understanding: it shows up at the worst times possible.",
            "Ever had a boner so awkward it should come with an apology note?",
            "Boner in public? Just tell them it's your phone on vibrate. Works every time.",
            "My boner just texted me: 'Stop wearing tight pants!'",
            "Got a boner during a Zoom call. Thank God for the mute button.",
            "You know it's going to be a good day when your boner wakes up before you do.",
            "My boner and my alarm clock should synchronize. That way, I can hit snooze on both.",
            "Boner during a meeting? Just pretend you’re deeply pondering the budget report.",
            "If boners could talk, mine would constantly be saying, 'Not now, dude!'",
            "Boner and gym shorts: a match made in awkward heaven.",
            "Had a boner while reading...a menu. Guess I was really hungry.",
            "Boner in a tight spot? Just start a conversation about politics; it'll go away instantly.",
            "Ever had a boner so random you had to question your life choices?",
            "My boner has a better social life than I do. It's always up for something.",
            "Nothing like a boner to remind you that your body has a mind of its own.",
            "Got a boner while watching cartoons. Childhood nostalgia hit differently."
        ]
        response = random.choice(responses)
        await ctx.send(response)

    @commands.command(name='coinbalance')
    async def coinbalance(self, ctx, mentioned_user: discord.Member = None):
        if mentioned_user:
            user_id = str(mentioned_user.id)
            user_name = mentioned_user.display_name
        else:
            mentioned_user = ctx.author
            user_id = str(ctx.author.id)
            user_name = ctx.author.display_name

        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})
        coins = user_data.get('coins', 0)
        coin_icon = load_settings()['coin_icon']

        if mentioned_user == ctx.author:
            await ctx.send(f"{ctx.author.mention}, you have {coins} {coin_icon} in your account.")
        else:
            await ctx.send(f"{ctx.author.mention}, {user_name} has {coins} {coin_icon} in their account.")

    @commands.command(name='fredtalk')
    async def fredtalk(self, ctx, *, message: str = None):
        if ctx.author.voice and ctx.author.voice.channel:
            voice_channel = ctx.author.voice.channel
            vc = await voice_channel.connect()

            user_nicknames = [member.display_name for member in voice_channel.members if member.display_name != "Fred"]

            if message:
                tts_message = message
            else:
                if len(user_nicknames) == 1:
                    tts_message = f"Hello {user_nicknames[0]}"
                else:
                    tts_message = " ".join([f"Hello {name}" for name in user_nicknames])

            tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts.mp3')
            tts = gTTS(tts_message, lang='en', tld='co.in')
            tts.save(tts_file_path)

            # Load the TTS file with pydub
            sound = AudioSegment.from_file(tts_file_path)

            # Deepen the pitch (lowering by 4 semitones)
            new_sound = sound._spawn(sound.raw_data, overrides={
                "frame_rate": int(sound.frame_rate * 0.6)
            }).set_frame_rate(sound.frame_rate)

            # Save the new sound
            new_tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts_deep.mp3')
            new_sound.export(new_tts_file_path, format="mp3")

            vc.play(discord.FFmpegPCMAudio(source=new_tts_file_path))

            while vc.is_playing():
                await asyncio.sleep(1)

            await vc.disconnect()

            # Delete the TTS files after 10 seconds
            await asyncio.sleep(5)
            if os.path.exists(tts_file_path):
                os.remove(tts_file_path)
            if os.path.exists(new_tts_file_path):
                os.remove(new_tts_file_path)
        else:
            await ctx.send("You aren't in a voice chat.")

class LevelUIView(View):
    def __init__(self, username, avatar_url, points, current_level, next_level, progress_percentage, remaining_points):
        super().__init__(timeout=60)
        self.username = username
        self.avatar_url = avatar_url
        self.points = points
        self.current_level = current_level
        self.next_level = next_level
        self.progress_percentage = progress_percentage
        self.remaining_points = remaining_points

class LevelUI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='level')
    async def level(self, ctx, member: discord.Member = None):
        if member is None:
            member = ctx.author

        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_stats = activity_tracker.get_statistics(str(member.id))
        if not user_stats:
            await ctx.send("No statistics available for this user.")
            return

        username = member.display_name
        avatar_url = member.avatar.url
        points = user_stats.get("points", 0)
        current_level, remaining_points = get_current_level(points)
        next_level = current_level + 1
        progress_percentage = (points - points_for_next_level(current_level - 1)) / remaining_points * 100

        image_buffer = generate_level_image(username, current_level, progress_percentage, points, next_level, avatar_url)
    
        if image_buffer:
            file = discord.File(image_buffer, filename="level_image.png")
            embed = discord.Embed(title="Level Information", color=discord.Color.orange())
            embed.set_image(url="attachment://level_image.png")

            await ctx.send(embed=embed, file=file)
        else:
            await ctx.send("An error occurred while generating the level image.")

    @commands.command(name='leaderboard_today')
    async def leaderboard_today(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = {user_id: data for user_id, data in activity_tracker.activity_data.items()}
        sorted_stats = sorted(stats.items(), key=lambda x: x[1].get('points_today', 0), reverse=True)[:20]

        df = pd.DataFrame(columns=["Rank", "Username", "Points Today"])
        for idx, (user_id, data) in enumerate(sorted_stats, start=1):
            member = ctx.guild.get_member(int(user_id))
            if member:
                df = pd.concat([df, pd.DataFrame({"Rank": [idx], "Username": [member.display_name], "Points Today": [data.get('points_today', 0)]})], ignore_index=True)

        table_str = df.to_markdown(index=False)
        embed = discord.Embed(title="Today's Leaderboard", color=discord.Color.green())
        embed.add_field(name="Top 20 Users", value=f"```\n{table_str}\n```", inline=False)

        await ctx.send(embed=embed)

    @commands.command(name='statistics')
    async def statistics(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            embed = discord.Embed(title="Statistics", color=discord.Color.purple())
            embed.add_field(name="Username", value=member.display_name, inline=True)
            embed.add_field(name="Total Points", value=stats.get('points', 0), inline=True)
            embed.add_field(name="Level", value=stats.get('level', 1), inline=True)
            embed.add_field(name="XP to Next Level", value=stats.get('xp_to_next_level', 0), inline=True)
            embed.add_field(name="Minutes in Voice", value=stats.get('minutes_in_voice', 0), inline=True)
            embed.add_field(name="Minutes Online", value=stats.get('minutes_online', 0), inline=True)
            embed.add_field(name="Messages Sent", value=stats.get('messages_sent', 0), inline=True)
            embed.add_field(name="Characters Typed", value=stats.get('characters_typed', 0), inline=True)
            embed.add_field(name="Points Today", value=stats.get('points_today', 0), inline=True)

            # Add coin information
            coins = stats.get('coins', 0)
            coin_icon_url = "https://cdn4.iconfinder.com/data/icons/coins-virtual-currency/104/Guarani-256.png"
            embed.add_field(name=f"\u200b", value=f"[![coins]({coin_icon_url})]({coin_icon_url}) **{coins}**", inline=False)

            await ctx.send(embed=embed)
        else:
            await ctx.send("No statistics available for this user.")

    @commands.command(name='statistics_visualization')
    async def statistics_visualization(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            # Generate the visualization
            visualization_path = generate_statistics_visualization(stats)
            embed = discord.Embed(title="Statistics Visualization", color=discord.Color.purple())
            file = discord.File(visualization_path, filename="statistics_visualization.png")
            embed.set_image(url=f"attachment://statistics_visualization.png")
            await member.send(embed=embed, file=file)
        else:
            await ctx.send("No statistics available for this user.")
        
class Music(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.current_player = None
        self.voice_channel = None
        self.votes_to_skip = set()
        self.song_queue = asyncio.Queue()
        self.playing_song = None
        self.current_volume = 0.2

    @commands.command(name='play')
    async def play(self, ctx, url):
        user = ctx.author
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.get_statistics(str(user.id))
        user_coins = user_data.get('coins', 0)
        settings = load_settings()
        coin_icon = settings['coin_icon']

        try:
            video_info = await self.get_video_info(url)
            video_length = video_info['duration']  # Duration in seconds
            video_title = video_info['title']
            cost = video_length * 4

            if user_coins < cost:
                await ctx.send(f"{user.mention}, the cost is {cost} {coin_icon}, but you do not have enough {coin_icon}.")
                return

            await ctx.send(f"{user.mention}, the cost to play '{video_title}' is {cost} {coin_icon}. Type `!accept` to proceed.")
            
            def check(m):
                return m.author == user and m.content.lower() == '!accept'
            
            try:
                await self.bot.wait_for('message', check=check, timeout=30.0)
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond!")
                return

            activity_tracker.update_user_activity(user, coins=-cost)
            await ctx.send(f"{user.mention} has paid {cost} {coin_icon} to play '{video_title}'.")

            self.voice_channel = ctx.author.voice.channel
            if not self.voice_channel:
                await ctx.send("You are not connected to a voice channel.")
                return

            audio_file = await self.download_audio(url, video_title)
            await self.song_queue.put((ctx, audio_file, video_title, user))
            if not self.current_player:
                await self.play_next_song()

        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    async def play_next_song(self):
        if not self.song_queue.empty():
            ctx, audio_file, video_title, user = await self.song_queue.get()
            self.voice_channel = ctx.author.voice.channel
            voice = await self.voice_channel.connect()

            source = discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(audio_file), volume=self.current_volume)
            self.current_player = voice.play(source, after=lambda e: self.bot.loop.create_task(self.play_next_song()))

            self.playing_song = (ctx, video_title, user)
            await ctx.send(f"Now playing: '{video_title}'")

            while voice.is_playing():
                await asyncio.sleep(1)
            await voice.disconnect()
            os.remove(audio_file)
            await ctx.send(f"Finished playing: '{video_title}' and removed the file from the system.")
            self.playing_song = None
            self.current_player = None

    @commands.command(name='skip')
    async def skip(self, ctx):
        if not self.current_player:
            await ctx.send("No audio is currently playing.")
            return

        user = ctx.author
        if user == self.playing_song[2]:  # The user who requested the song
            self.current_player.source.cleanup()
            self.current_player.stop()
            await ctx.send(f"{user.mention} has skipped their own song.")
            self.votes_to_skip.clear()
        else:
            if user not in self.voice_channel.members:
                await ctx.send("You must be in the voice channel to vote to skip.")
                return

            self.votes_to_skip.add(user)
            total_members = len(self.voice_channel.members)
            if len(self.votes_to_skip) / total_members >= 0.5:
                self.current_player.source.cleanup()
                self.current_player.stop()
                await ctx.send("Vote passed! Skipping the current song.")
                self.votes_to_skip.clear()
            else:
                await ctx.send(f"{user.mention} has voted to skip. {len(self.votes_to_skip)}/{total_members} votes.")

    @commands.command(name='volume')
    async def volume(self, ctx, volume: float):
        user = ctx.author
        if user != self.playing_song[2]:
            await ctx.send(f"{user.mention}, only the song requester can change the volume.")
            return

        if volume < 0 or volume > 5:
            await ctx.send(f"{user.mention}, volume must be between 0 and 5.")
            return

        self.current_volume = volume * 0.1
        if self.current_player and self.current_player.source:
            self.current_player.source.volume = self.current_volume
        await ctx.send(f"{user.mention}, the volume has been set to {volume}.")

    async def get_video_info(self, url):
        ydl_opts = {
            'format': 'bestaudio/best',
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
            }
        }
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
        return {
            'duration': info['duration'],
            'title': info['title']
        }

    async def download_audio(self, url, title):
        ydl_opts = {
            'format': 'bestaudio/best',
            'outtmpl': f'utils/sounds/musicdump/{title}.%(ext)s',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }],
            'ffmpeg_location': os.getenv('FFMPEG_PATH'),
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
            }
        }
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url)
            filename = ydl.prepare_filename(info)
            mp3_filename = filename.replace('.webm', '.mp3')
        
        return mp3_filename

async def setup(bot):
    await bot.add_cog(GeneralCommands(bot))
    await bot.add_cog(LevelUI(bot))
    await bot.add_cog(Music(bot))



.\bot\level_widget.py
import discord
from discord.ext import commands

class LevelWidget(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        print("LevelWidget initialized")

async def setup(bot):
    print("Setting up LevelWidget")
    await bot.add_cog(LevelWidget(bot))
    print("LevelWidget added to bot")


.\bot\__init__.py


.\bot\games\blackjack.py
import random, os, discord, asyncio, json
from PIL import Image
from discord.ext import commands
from settings.settings import load_settings

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

CARD_VALUES = game_settings['blackjack']['card_values']  # Dictionary of card values
SUITS = game_settings['blackjack']['suits']  # List of suits
DECK = [f'{value}_of_{suit}' for suit in SUITS for value in CARD_VALUES.keys()]  # List of all cards in the deck
DECK_IMAGES_FOLDER = 'utils/images/deckofcards'
DUMP_IMAGES_FOLDER = 'utils/images/blackjackdump'

BLACKJACK_WIN_POINTS = 100
BLACKJACK_LOSS_POINTS = 20
BLACKJACK_PUSH_POINTS = 45

class BlackjackGame:
    def __init__(self, player, bot):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        self.player = player
        self.bot = bot
        self.player_hand = []
        self.dealer_hand = []
        self.player_points = 0
        self.dealer_points = 0
        self.bet = 0

    async def deal_initial_cards(self):
        self.player_hand = [self.deck.pop(), self.deck.pop()]
        self.dealer_hand = [self.deck.pop(), self.deck.pop()]
        self.player_points = self.calculate_hand_value(self.player_hand)
        self.dealer_points = self.calculate_hand_value(self.dealer_hand)

    def calculate_hand_value(self, hand):
        value = 0
        aces = 0
        for card in hand:
            card_value = card[:-1]  # Get the card value without the suit
            if card_value.isdigit():
                value += int(card_value)
            elif card_value in ['J', 'Q', 'K']:
                value += 10
            else:
                value += 11
                aces += 1
        while value > 21 and aces:
            value -= 10
            aces -= 1
        return value

    async def start_game(self, bet):
        self.bet = bet
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        await self.deal_initial_cards()

    async def player_hit(self):
        card = self.deck.pop()
        self.player_hand.append(card)
        self.player_points = self.calculate_hand_value(self.player_hand)
        return card

    async def dealer_play(self):
        while self.dealer_points < 17:
            card = self.deck.pop()
            self.dealer_hand.append(card)
            self.dealer_points = self.calculate_hand_value(self.dealer_hand)
        return self.dealer_hand

    def get_game_result(self):
        if self.player_points > 21:
            return "bust"
        elif self.dealer_points > 21 or self.player_points > self.dealer_points:
            return "win"
        elif self.player_points == self.dealer_points:
            return "push"
        else:
            return "lose"

    async def create_hand_image(self, hand, reveal_dealer=False):
        card_images = []
        for card in hand:
            if isinstance(card, dict) and card.get('value') == 'back':
                card_image_path = os.path.join(DECK_IMAGES_FOLDER, 'back.png')
            else:
                card_value = card[:-1]  # Extract the value part of the card string
                card_suit = card[-1].upper()  # Extract the suit part of the card string
                if card_value == '10':  # Check for '10' separately
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, '10', f'10{card_suit}.png')
                else:
                    card_value = card_value[0].upper()
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, card_value, f'{card_value}{card_suit}.png')
            card_images.append(card_image_path)
        return card_images

    async def concatenate_images(self, image_paths, filename):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        total_width = sum(widths)
        max_height = max(heights)
        new_image = Image.new('RGB', (total_width, max_height))

        x_offset = 0
        for img in images:
            new_image.paste(img, (x_offset, 0))
            x_offset += img.size[0]

        output_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path

    async def hit(self, ctx):
        card = await self.player_hit()
        await self.send_hand(ctx)

        if self.player_points > 21:
            await self.end_game(ctx, "bust")

    async def stand(self, ctx):
        dealer_hand = await self.dealer_play()
        await self.send_hand(ctx, reveal_dealer=True)

        result = self.get_game_result()
        await self.end_game(ctx, result)

    async def end_game(self, ctx, result):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if result == "win":
            payout = self.bet * 2
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_WIN_POINTS, coins=payout)
            await ctx.send(f"Congratulations {ctx.author.mention}, you win! You have been awarded {BLACKJACK_WIN_POINTS} points and {payout} {coin_icon}.")
        elif result == "bust":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_LOSS_POINTS)
            await ctx.send(f"Sorry {ctx.author.mention}, you busted! You lost {self.bet} {coin_icon}.")
        elif result == "lose":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_LOSS_POINTS)
            await ctx.send(f"Sorry {ctx.author.mention}, you lose! You lost {self.bet} {coin_icon}.")
        elif result == "push":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_PUSH_POINTS, coins=self.bet)
            await ctx.send(f"It's a push, {ctx.author.mention}. Your bet of {self.bet} {coin_icon} has been returned.")

        await self.cleanup_images()
        del self.bot.get_cog('GameManager').blackjack_games[ctx.author.id]

    async def send_hand(self, ctx, reveal_dealer=False):
        player_images = await self.create_hand_image(self.player_hand)
        dealer_hand = self.dealer_hand if reveal_dealer else self.dealer_hand[:1] + [{'value': 'back', 'suit': ''}]
        dealer_images = await self.create_hand_image(dealer_hand)

        concatenated_player_image = await self.concatenate_images(player_images, f'blackjack_{ctx.author.id}_player_hand.png')
        concatenated_dealer_image = await self.concatenate_images(dealer_images, f'blackjack_{ctx.author.id}_dealer_hand.png')

        player_hand_embed = discord.File(concatenated_player_image, filename="player_hand.png")
        dealer_hand_embed = discord.File(concatenated_dealer_image, filename="dealer_hand.png")

        embed = discord.Embed(title="Blackjack")
        embed.add_field(name="Your Hand", value=f"Points: {self.player_points}", inline=True)
        embed.add_field(name="Dealer's Hand", value=f"Points: {self.dealer_points if reveal_dealer else '?'}", inline=True)
        embed.set_image(url=f"attachment://player_hand.png")
        embed.set_thumbnail(url=f"attachment://dealer_hand.png")

        await ctx.send(embed=embed, files=[player_hand_embed, dealer_hand_embed])

    async def cleanup_images(self):
        for filename in os.listdir(DUMP_IMAGES_FOLDER):
            file_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
            if os.path.isfile(file_path):
                os.unlink(file_path)

.\bot\games\dealerpoker.py
import discord, random, os, asyncio, json, asyncio, itertools
from discord.ext import commands
from PIL import Image, ImageDraw, ImageFont
from settings.settings import load_settings

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

# Poker Settings
POKER_WIN_POINTS = 120
POKER_TIE_POINTS = 90
POKER_LOSS_POINTS = 30


class DealerPoker:
    def __init__(self, ctx, bot):
        self.bot = bot
        self.ctx = ctx
        self.player = ctx.author
        self.dealer_hand = []
        self.player_hands = {}
        self.community_cards = []
        self.DECK_OF_CARDS_FOLDER = 'utils/images/deckofcards'
        self.DUMP_IMAGES_FOLDER = 'utils/images/pokerdump'
        self.previous_community_cards_message = None
        self.game_cancelled = False
        self.raised = False
        self.player_bet = 0
        self.ante = 0
        self.bot_messages = []

    async def start_game(self):
        await self.ask_for_ante()
        if self.game_cancelled:
            return

        await self.deal_initial_cards()
        if self.game_cancelled:
            return

        await self.betting_round(stage='pre_flop')
        if self.game_cancelled:
            return

        await self.reveal_community_cards(3)
        if self.game_cancelled:
            return

        await self.betting_round(stage='flop')
        if self.game_cancelled:
            return

        await self.reveal_community_cards(1)
        if self.game_cancelled:
            return

        await self.betting_round(stage='turn')
        if self.game_cancelled:
            return

        await self.reveal_community_cards(1)
        if self.game_cancelled:
            return

        await self.betting_round(stage='river')
        if self.game_cancelled:
            return

        await self.showdown()
        if self.game_cancelled:
            return

        await self.cleanup()

    async def ask_for_ante(self):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.get_statistics(str(self.player.id))
        await self.ctx.send(f"{self.ctx.author.mention}, how many {coin_icon} would you like to ante?  Current balance: {int(user_data.get('coins', 0))} {coin_icon}")

        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel
        
        try:
            msg = await self.bot.wait_for('message', check=check, timeout=120)
            self.ante = int(msg.content)
            activity_tracker = self.bot.get_cog('ActivityTracker')
            user_data = activity_tracker.get_statistics(str(self.player.id))
            player_coins = user_data.get('coins', 0)

            if player_coins < self.ante:
                await self.ctx.send(f"{self.ctx.author.mention}, you do not have enough {coin_icon} to ante that amount.")
                self.game_cancelled = True
                return
            
            activity_tracker.update_user_activity(self.ctx.author, coins=-(self.ante))
            self.player_bet = self.ante
            self.player_hands[self.ctx.author] = []
            await self.ctx.send(f"{self.ctx.author.mention}, you have anted {self.ante} {coin_icon}.  Starting Dealer Poker..")
        except asyncio.TimeoutError:
            await self.ctx.send(f"{self.ctx.author.mention} took too long to respond.  Game has been cancelled without refund.")
            self.game_cancelled = True
        except ValueError:
            await self.ctx.send(f"{msg.content} is not a valid number.  Game cancelled.")
            self.game_cancelled = True

    async def deal_initial_cards(self):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)

        self.player_hands[self.player] = [self.deck.pop(), self.deck.pop()]
        await self.send_hand(self.ctx, self.player)

        self.dealer_hand = [self.deck.pop(), self.deck.pop()]

    async def betting_round(self, stage='pre_flop'):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.get_statistics(str(self.player.id))
        player_total_coins = int(user_data.get('coins', 0))

        # Determine the max bet based on the game stage
        if stage == 'pre_flop':
            max_bet = self.ante * 4
        elif stage == 'flop':
            max_bet = self.ante * 2 + self.player_bet
        elif stage == 'turn':
            max_bet = int(self.ante * 1.75 + self.player_bet)
        elif stage == 'river':
            max_bet = int(self.ante * 1.35 + self.player_bet)
        else:
            max_bet = self.player_bet  # In case of an invalid stage, default to the current bet

        # Calculate the additional amount needed to reach the max bet
        additional_amount = max_bet - self.player_bet

        # Determine the action message based on the game stage
        if self.raised == True:
            await asyncio.sleep(2)
            return
        
        if stage == 'river':
            if additional_amount > player_total_coins:
                action_message = (f"you can `!fold` or go `!allin` with {player_total_coins} {coin_icon}.")
            else:
                action_message = (f"you can `!fold`, raise the `!bet` to {max_bet} {coin_icon} "
                                  f"({additional_amount} more).")
        else:
            action_message = (f"you can `!check` or raise the `!bet` to {max_bet} {coin_icon} "
                                f"({additional_amount} more).")

        # Send the message with the current bet, action options, and player's balance at the end
        message = await self.ctx.send(f"{self.ctx.author.mention}, the current bet is {self.player_bet} {coin_icon}. "
                            f"{action_message} Your current balance is {player_total_coins} {coin_icon}.")
        
        self.bot_messages.append(message)

        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel

        try:
            while True:
                msg = await self.bot.wait_for('message', check=check, timeout=50)
                content = msg.content.lower().split()
                
                if content[0] == '!check' and stage != 'river':
                    rsp_msg = await self.ctx.send(f"{self.ctx.author.mention} checks.")
                    self.bot_messages.append(rsp_msg)
                    break  # Exit the loop as a valid action was taken

                elif content[0] == '!fold' and stage == 'river':
                    await self.ctx.send(f"{self.ctx.author.mention} folds. Game over.")
                    await self.display_winner_if_folded()
                    self.game_cancelled = True
                    return

                elif content[0] == '!bet':
                    try:
                        bet_amount = max_bet if len(content) == 1 else int(content[1])

                        if bet_amount < self.player_bet or bet_amount > max_bet:
                            rsp_msg = await self.ctx.send(f"{self.ctx.author.mention}, invalid bet amount. Please bet between {self.player_bet} and {max_bet} {coin_icon}.")
                            self.bot_messages.append(rsp_msg)
                        elif additional_amount > player_total_coins:
                            rsp_msg = await self.ctx.send(f"{self.ctx.author.mention}, you do not have enough balance to place this bet.")
                            self.bot_messages.append(rsp_msg)
                        else:
                            self.player_bet = bet_amount  # Update player's total bet to include the new bet amount
                            player_total_coins -= additional_amount
                            activity_tracker.update_user_activity(self.ctx.author, coins=-additional_amount)
                            rsp_msg = await self.ctx.send(f"{self.ctx.author.mention} places a bet of {additional_amount} {coin_icon}. Total bet: {self.player_bet} {coin_icon}. Current balance: {player_total_coins} {coin_icon}.")
                            self.bot_messages.append(rsp_msg)
                            self.raised = True
                            break  # Exit the loop as a valid action was taken
                    except ValueError:
                        rsp_msg = await self.ctx.send(f"{self.ctx.author.mention}, please enter a valid bet amount.")
                        self.bot_messages.append(rsp_msg)
                
                elif content[0] == '!allin' and stage == 'river' and (additional_amount > player_total_coins):
                    if additional_amount > player_total_coins:
                        # Going all-in
                        additional_amount = player_total_coins
                        self.player_bet += player_total_coins
                        activity_tracker.update_user_activity(self.ctx.author, coins=-player_total_coins)
                        rsp_msg = await self.ctx.send(f"{self.ctx.author.mention} goes all-in with {player_total_coins} {coin_icon}. Total bet: {self.player_bet} {coin_icon}.")
                        self.bot_messages.append(rsp_msg)
                        self.raised = True
                        break
                    else:
                        continue
                else:
                    rsp_msg = await self.ctx.send("Invalid action. Please try again.")
                    self.bot_messages.append(rsp_msg)
        except asyncio.TimeoutError:
            await self.ctx.send(f"{self.ctx.author.mention} took too long to respond. Game over.")
            self.game_cancelled = True

    async def display_winner_if_folded(self):
        # Simulate a showdown to determine who would have won
        player_hand = self.player_hands[self.ctx.author]
        dealer_hand = self.dealer_hand
        player_best_hand = self.get_best_hand(player_hand + self.community_cards)
        dealer_best_hand = self.get_best_hand(dealer_hand + self.community_cards)

        player_rank = self.hand_rank(player_best_hand)
        dealer_rank = self.hand_rank(dealer_best_hand)

        # Determine the winner based on ranks
        if player_rank > dealer_rank:
            result = f"Would have won: {self.ctx.author.display_name} with a {self.rank_description(player_rank)}"
        elif player_rank < dealer_rank:
            result = f"Would have won: Dealer with a {self.rank_description(dealer_rank)}"
        else:
            result = "It would have been a tie!"

        await asyncio.sleep(1)
        await self.ctx.send(f"**HYPOTHETICAL RESULT**")
        await asyncio.sleep(1)

        # Create and send Player's Hand embed
        player_hand_images = [await self.get_card_image(card) for card in player_hand]
        player_hand_image_path = await self.concatenate_images(player_hand_images, 'player_hand.png')
        player_hand_file = discord.File(player_hand_image_path, filename="player_hand.png")
        player_embed = discord.Embed(title="Player's Hand")
        player_embed.set_image(url="attachment://player_hand.png")
        await self.ctx.send(file=player_hand_file, embed=player_embed)

        await asyncio.sleep(2)

        # Create and send Community Cards embed
        community_cards_images = [await self.get_card_image(card) for card in self.community_cards]
        community_cards_image_path = await self.concatenate_images(community_cards_images, 'community_cards.png')
        community_cards_file = discord.File(community_cards_image_path, filename="community_cards.png")
        community_embed = discord.Embed(title="Community Cards")
        community_embed.set_image(url="attachment://community_cards.png")
        await self.ctx.send(file=community_cards_file, embed=community_embed)

        await asyncio.sleep(2)

        # Create and send Dealer's Hand embed
        dealer_hand_images = [await self.get_card_image(card) for card in dealer_hand]
        dealer_hand_image_path = await self.concatenate_images(dealer_hand_images, 'dealer_hand.png')
        dealer_hand_file = discord.File(dealer_hand_image_path, filename="dealer_hand.png")
        dealer_embed = discord.Embed(title="Dealer's Hand")
        dealer_embed.set_image(url="attachment://dealer_hand.png")
        await self.ctx.send(file=dealer_hand_file, embed=dealer_embed)

        await asyncio.sleep(3)

        # Send the result message
        await self.ctx.send(result)

        await self.clear_messages()

        # Clean up images
        os.remove(player_hand_image_path)
        os.remove(community_cards_image_path)
        os.remove(dealer_hand_image_path)

    async def reveal_community_cards(self, num):
        for _ in range(num):
            self.deck.pop()  # Burn card
            self.community_cards.append(self.deck.pop())

        await self.display_community_cards()

    async def display_community_cards(self):
        if self.previous_community_cards_message:
            await self.previous_community_cards_message.delete()
        
        message = await self.ctx.send("**|**")
        await asyncio.sleep(1)
        await message.edit(content="**| |**")
        await asyncio.sleep(1)
        await message.edit(content="**| | |**")
        await asyncio.sleep(1)
        
        await message.delete()

        cards = [await self.get_card_image(card) for card in self.community_cards]
        concatenated_image_path = await self.concatenate_images(cards, 'community_cards.png')
        file = discord.File(concatenated_image_path, filename="community_cards.png")

        embed = discord.Embed(title="Community Cards")
        embed.set_image(url="attachment://community_cards.png")
        
        self.previous_community_cards_message = await self.ctx.send(file=file, embed=embed)

    async def clear_messages(self):
        for message in self.bot_messages:
            try:
                await message.delete()
            except discord.NotFound:
                pass
        
        self.bot_messages.clear()
        await self.previous_community_cards_message.delete()

    async def showdown(self):
        player_hand = self.player_hands[self.ctx.author]
        dealer_hand = self.dealer_hand
        player_best_hand = self.get_best_hand(player_hand + self.community_cards)
        dealer_best_hand = self.get_best_hand(dealer_hand + self.community_cards)

        player_rank = self.hand_rank(player_best_hand)
        dealer_rank = self.hand_rank(dealer_best_hand)

        activity_tracker = self.bot.get_cog('ActivityTracker')
        if player_rank > dealer_rank:
            result = f"{self.ctx.author.mention} wins with a {self.rank_description(player_rank)} and has won {POKER_WIN_POINTS} points and {self.player_bet * 2} {coin_icon}!"
            payout = self.player_bet * 2
            activity_tracker.update_user_activity(self.ctx.author, points=POKER_WIN_POINTS, coins=payout)
        elif player_rank < dealer_rank:
            result = f"The dealer wins with a {self.rank_description(dealer_rank)}. Better luck next time! You have received {POKER_LOSS_POINTS} points."
            payout = 0
            activity_tracker.update_user_activity(self.ctx.author, points=POKER_LOSS_POINTS)
        else:
            result = f"It's a tie! Both you and the dealer have the same hand. You have received {POKER_TIE_POINTS} points, and your ante of {self.ante} {coin_icon} has been returned."
            payout = self.player_bet  # Usually, in a tie, the player gets their ante back or a portion of it
            activity_tracker.update_user_activity(self.ctx.author, points=POKER_TIE_POINTS, coins=payout)

        await asyncio.sleep(1)
        await self.ctx.send(f"**SHOWDOWN**")
        await asyncio.sleep(1)

        # Create and send Player's Hand embed
        player_hand_images = [await self.get_card_image(card) for card in player_hand]
        player_hand_image_path = await self.concatenate_images(player_hand_images, 'player_hand.png')
        player_hand_file = discord.File(player_hand_image_path, filename="player_hand.png")
        player_embed = discord.Embed(title="Player's Hand")
        player_embed.set_image(url="attachment://player_hand.png")
        await self.ctx.send(file=player_hand_file, embed=player_embed)

        await asyncio.sleep(2)

        # Create and send Community Cards embed
        community_cards_images = [await self.get_card_image(card) for card in self.community_cards]
        community_cards_image_path = await self.concatenate_images(community_cards_images, 'community_cards.png')
        community_cards_file = discord.File(community_cards_image_path, filename="community_cards.png")
        community_embed = discord.Embed(title="Community Cards")
        community_embed.set_image(url="attachment://community_cards.png")
        await self.ctx.send(file=community_cards_file, embed=community_embed)

        await asyncio.sleep(2)

        # Create and send Dealer's Hand embed
        dealer_hand_images = [await self.get_card_image(card) for card in dealer_hand]
        dealer_hand_image_path = await self.concatenate_images(dealer_hand_images, 'dealer_hand.png')
        dealer_hand_file = discord.File(dealer_hand_image_path, filename="dealer_hand.png")
        dealer_embed = discord.Embed(title="Dealer's Hand")
        dealer_embed.set_image(url="attachment://dealer_hand.png")
        await self.ctx.send(file=dealer_hand_file, embed=dealer_embed)

        await asyncio.sleep(3)

        # Send the result message
        await self.ctx.send(result)

        await self.clear_messages()

        # Clean up images
        os.remove(player_hand_image_path)
        os.remove(community_cards_image_path)
        os.remove(dealer_hand_image_path)

    async def display_final_hands(self, player_hand, dealer_hand):
        player_hand_images = [await self.get_card_image(card) for card in player_hand]
        dealer_hand_images = [await self.get_card_image(card) for card in dealer_hand]

        # Create a combined image of the player and dealer hands
        player_hand_image = await self.concatenate_images(player_hand_images, 'player_final_hand.png')
        dealer_hand_image = await self.concatenate_images(dealer_hand_images, 'dealer_final_hand.png')

        embed = discord.Embed(title="Final Hands")
        embed.set_image(url="attachment://player_final_hand.png")
        player_file = discord.File(player_hand_image, filename="player_final_hand.png")
        dealer_file = discord.File(dealer_hand_image, filename="dealer_final_hand.png")

        msg = await self.ctx.send(file=player_file, embed=embed)

        # Wait and reveal the dealer's hand
        await asyncio.sleep(2)
        embed.set_image(url="attachment://dealer_final_hand.png")
        await msg.edit(embed=embed)
        await self.ctx.send(file=dealer_file)

    def rank_description(self, rank):
        descriptions = [
            "High Card", 
            "One Pair", 
            "Two Pair", 
            "Three of a Kind", 
            "Straight", 
            "Flush", 
            "Full House", 
            "Four of a Kind", 
            "Straight Flush", 
            "Royal Flush"
        ]
        return descriptions[rank[0]]

    async def get_hand_image(self, hand):
        cards = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(cards, 'showdown_hand.png')
        return concatenated_image_path

    async def send_hand(self, ctx, player, reveal=False, dealer=False):
        hand = self.player_hands[player] if not dealer else self.dealer_hand
        card_images = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(card_images, f'poker_{player.id}_hand.png')
        file = discord.File(concatenated_image_path, filename="hand.png")

        title = f"{player.display_name}'s Hand" if not dealer else "Dealer's Hand"
        embed = discord.Embed(title=title)
        embed.set_image(url="attachment://hand.png")
        initial = await ctx.send(file=file, embed=embed)

        self.bot_messages.append(initial)

    async def get_card_image(self, card):
        card_value = card[:-1]
        card_suit = card[-1].upper()
        if card_value == '10':
            card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, '10', f'10{card_suit}.png')
        else:
            card_value = card_value[0].upper()
            card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, card_value, f'{card_value}{card_suit}.png')
        return card_image_path

    async def concatenate_images(self, image_paths, filename, vertical=False):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        
        if vertical:
            total_width = max(widths)
            total_height = sum(heights)
        else:
            total_width = sum(widths)
            total_height = max(heights)

        new_image = Image.new('RGB', (total_width, total_height))

        x_offset, y_offset = 0, 0
        for img in images:
            if vertical:
                new_image.paste(img, (0, y_offset))
                y_offset += img.size[1]
            else:
                new_image.paste(img, (x_offset, 0))
                x_offset += img.size[0]

        output_path = os.path.join(self.DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path

    def hand_rank(self, hand):
        # Define ranks and handle '10' separately using 'T'
        ranks = '23456789TJQKA'
        values = {r: i for i, r in enumerate(ranks, start=2)}
        values['T'] = 10

        # Extract ranks and suits from hand
        hand_ranks = sorted([values[card[:-1].replace('10', 'T')] for card in hand], reverse=True)
        suits = [card[-1] for card in hand]

        # Check for flush
        is_flush = len(set(suits)) == 1
        flush_ranks = hand_ranks if is_flush else []

        # Check for straight
        is_straight = len(set(hand_ranks)) == 5 and (hand_ranks[0] - hand_ranks[-1] == 4)
        # Special case: Ace can be low in a straight (A-2-3-4-5)
        if set(hand_ranks) == {14, 5, 4, 3, 2}:
            is_straight = True
            hand_ranks = [5, 4, 3, 2, 1]

        # Check for other hands using rank counts
        rank_counter = {r: hand_ranks.count(r) for r in hand_ranks}
        rank_values = sorted(((count, rank) for rank, count in rank_counter.items()), reverse=True)

        # Determine the hand ranking
        if is_straight and is_flush:
            if hand_ranks == [14, 13, 12, 11, 10]:
                return (9, hand_ranks)  # Royal Flush
            return (8, hand_ranks)      # Straight Flush
        if rank_values[0][0] == 4:
            return (7, rank_values[0][1], rank_values[1][1])  # Four of a Kind
        if rank_values[0][0] == 3 and rank_values[1][0] == 2:
            return (6, rank_values[0][1], rank_values[1][1])  # Full House
        if is_flush:
            return (5, flush_ranks)  # Flush
        if is_straight:
            return (4, hand_ranks)   # Straight
        if rank_values[0][0] == 3:
            return (3, rank_values[0][1], rank_values[1][1])  # Three of a Kind
        if rank_values[0][0] == 2 and rank_values[1][0] == 2:
            return (2, rank_values[0][1], rank_values[1][1], rank_values[2][1])  # Two Pair
        if rank_values[0][0] == 2:
            return (1, rank_values[0][1], rank_values[1][1], rank_values[2][1], rank_values[3][1])  # One Pair
        return (0, hand_ranks)  # High Card

    def get_best_hand(self, hand):
        all_combinations = itertools.combinations(hand, 5)
        best_hand = max(all_combinations, key=self.hand_rank)
        return best_hand

    async def reveal_hand(self, player, hand, dealer=False):
        cards = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(cards, f'poker_{player.id}_hand.png')
        file = discord.File(concatenated_image_path, filename="hand.png")

        title = f"{player.display_name}'s Hand" if not dealer else "Dealer's Hand"
        embed = discord.Embed(title=title)
        embed.set_image(url="attachment://hand.png")
        msg = await self.ctx.send(file=file, embed=embed)

        # Dramatic reveal of each card
        for i, card in enumerate(cards):
            await asyncio.sleep(1)  # Adding delay for dramatic effect
            if i < len(cards) - 1:
                await msg.edit(content=f"{player.display_name} reveals {card}.")
            else:
                await self.ctx.send(f"{player.display_name} reveals {card}.")

    async def create_final_showdown_image(self, player_hand, dealer_hand):
        # Get image paths for each hand and community cards
        player_hand_images = [await self.get_card_image(card) for card in player_hand]
        dealer_hand_images = [await self.get_card_image(card) for card in dealer_hand]
        community_cards_images = [await self.get_card_image(card) for card in self.community_cards]

        # Create and send Player's Hand embed
        player_hand_image_path = await self.concatenate_images(player_hand_images, 'player_hand.png')
        player_hand_file = discord.File(player_hand_image_path, filename="player_hand.png")
        player_embed = discord.Embed(title="Player's Hand")
        player_embed.set_image(url="attachment://player_hand.png")
        await self.ctx.send(file=player_hand_file, embed=player_embed)

        # Create and send Community Cards embed
        community_cards_image_path = await self.concatenate_images(community_cards_images, 'community_cards.png')
        community_cards_file = discord.File(community_cards_image_path, filename="community_cards.png")
        community_embed = discord.Embed(title="Community Cards")
        community_embed.set_image(url="attachment://community_cards.png")
        await self.ctx.send(file=community_cards_file, embed=community_embed)

        # Create and send Dealer's Hand embed
        dealer_hand_image_path = await self.concatenate_images(dealer_hand_images, 'dealer_hand.png')
        dealer_hand_file = discord.File(dealer_hand_image_path, filename="dealer_hand.png")
        dealer_embed = discord.Embed(title="Dealer's Hand")
        dealer_embed.set_image(url="attachment://dealer_hand.png")
        await self.ctx.send(file=dealer_hand_file, embed=dealer_embed)

        # Determine winner and hand rank description
        player_best_hand = self.get_best_hand(player_hand + self.community_cards)
        dealer_best_hand = self.get_best_hand(dealer_hand + self.community_cards)
        player_rank = self.hand_rank(player_best_hand)
        dealer_rank = self.hand_rank(dealer_best_hand)

        if player_rank > dealer_rank:
            result = f"{self.ctx.author.display_name} wins with a {self.rank_description(player_rank)}!"
        elif player_rank < dealer_rank:
            result = f"The dealer wins with a {self.rank_description(dealer_rank)}. Better luck next time!"
        else:
            result = "It's a tie!"

        # Send the result message
        await self.ctx.send(result)

        # Clean up images
        os.remove(player_hand_image_path)
        os.remove(community_cards_image_path)
        os.remove(dealer_hand_image_path)


    async def cleanup(self):
        """Clean up temporary images and reset state if needed."""
        for filename in os.listdir(self.DUMP_IMAGES_FOLDER):
            file_path = os.path.join(self.DUMP_IMAGES_FOLDER, filename)
            try:
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            except Exception as e:
                print(f"Failed to delete {file_path}. Reason: {e}")

    def cleanup_image(self, image_path):
        """Remove the image file after it's used."""
        try:
            os.remove(image_path)
        except Exception as e:
            print(f"Error deleting image {image_path}: {e}")



.\bot\games\duel.py
import random, aiohttp, discord, json
from settings.settings import load_settings
from discord.ext import commands

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

DUEL_WIN_POINTS = game_settings['duel']['win_points']  # Points awarded for winning a duel
DUEL_WIN_COINS = game_settings['duel']['win_coins']  # Coins awarded for winning a duel

settings = load_settings()
coin_icon = settings['coin_icon']

class Duel:
    def __init__(self, player1, player2):
        self.player1 = player1  # ID of player 1
        self.player2 = player2  # ID of player 2
        self.health = {player1: 100, player2: 100}  # Initial health for both players
        self.letter = None  # The current letter for the duel
        self.used_words = set()  # Set of words that have already been used

    def generate_letter(self):
        self.letter = random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')  # Generate a random letter

    @commands.command(name='challenge')
    async def challenge(self, ctx, opponent_name: str):
        opponent = self.find_member(ctx.guild, opponent_name)
        if opponent is None:
            await ctx.send(f"Could not find a unique member with the name '{opponent_name}'. Please specify a more exact name or use mention.")
            return

        if ctx.author.id in self.duels or opponent.id in self.duels:
            await ctx.send("One of the players is already in a duel!")
            return

        self.duels[ctx.author.id] = Duel(ctx.author.id, opponent.id)
        self.duels[opponent.id] = self.duels[ctx.author.id]

        if opponent == self.bot.user:
            await self.accept_duel(ctx)
        else:
            await ctx.send(f"{ctx.author.mention} has challenged {opponent.mention} to a duel! Use `!accept` to accept the challenge.")

    async def is_valid_word(self, word):
        url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word.lower()}"  # URL to check if the word is valid
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                return resp.status == 200  # Return True if the word is valid

    def calculate_damage(self, words):
        valid_words = [word for word in words if word.lower().startswith(self.letter.lower()) and word.lower() not in self.used_words]
        self.used_words.update(word.lower() for word in valid_words)  # Add valid words to the set of used words
        return sum(len(word) for word in valid_words)  # Calculate damage as the sum of the lengths of valid words

    def get_winner(self):
        if self.health[self.player1] <= 0:
            return self.player2  # Player 2 wins if player 1's health is 0 or less
        elif self.health[self.player2] <= 0:
            return self.player1  # Player 1 wins if player 2's health is 0 or less
        return None  # No winner if both players have health above 0

    def adjust_health(self, player_id, damage):
        self.health[player_id] = max(self.health[player_id] - damage, 0)  # Reduce health by the damage amount, but not below 0

    async def handle_duel(self, ctx, duel):
        def check(m):
            return m.channel == ctx.channel and m.author.id in [duel.player1, duel.player2]

        while True:
            msg = await self.bot.wait_for('message', check=check)
            damage = await self.process_message(msg, duel)
            opponent_id = duel.player1 if msg.author.id == duel.player2 else duel.player2
            duel.adjust_health(opponent_id, damage)

            embed = discord.Embed(
                title="Duel Status",
                description=f"{self.bot.get_user(duel.player1).mention} vs {self.bot.get_user(duel.player2).mention}",
                color=discord.Color.red()
            )
            embed.add_field(name=f"{self.bot.get_user(duel.player1).display_name} HP", value=duel.health[duel.player1])
            embed.add_field(name=f"{self.bot.get_user(duel.player2).display_name} HP", value=duel.health[duel.player2])
            await ctx.send(embed=embed)

            winner_id = duel.get_winner()
            if winner_id:
                winner = self.bot.get_user(winner_id)
                await ctx.send(f"{winner.mention} wins the duel!")
                activity_tracker = self.bot.get_cog('ActivityTracker')
                activity_tracker.update_user_activity(winner, points=DUEL_WIN_POINTS, coins=DUEL_WIN_COINS)
                await ctx.send(f"{winner.mention} has been awarded {DUEL_WIN_POINTS} points and {DUEL_WIN_COINS} {coin_icon}! Total {coin_icon}: {activity_tracker.activity_data[str(winner.id)]['coins']}")
                
                del self.duels[duel.player1]
                del self.duels[duel.player2]
                return

    async def process_message(self, msg, duel):
        words = msg.content.split()
        valid_words = []
        for word in words:
            if await duel.is_valid_word(word):
                if word.lower() not in duel.used_words:
                    valid_words.append(word)
                else:
                    await msg.channel.send(f"The word '{word}' has already been used.")
            else:
                await msg.channel.send(f"The word '{word}' is not a valid word.")
        return duel.calculate_damage(valid_words)


.\bot\games\game_manager.py
import discord, asyncio, json, logging
from discord.ext import commands
from discord.ext.commands import CommandOnCooldown
from .duel import Duel
from .blackjack import BlackjackGame
from .lottery import Lottery
from .dealerpoker import DealerPoker
from .slots import SlotMachine
from settings.settings import load_settings

logging.basicConfig(level=logging.INFO)

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

BOT_TESTING_MODE = game_settings['game']['bot_testing_mode']  # Whether bot testing mode is enabled
if BOT_TESTING_MODE:
    POKER_MIN_PLAYERS = 1
    POKER_MAX_PLAYERS = 1

settings = load_settings()
coin_icon = settings['coin_icon']

TICKET_COST = 100

class GameManager(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.duels = {}
        self.blackjack_games = {}
        self.dealerpoker_games = {}
        self.slot_games = {}
        self.lottery = Lottery(bot)
        self.load_game_data()

    def load_game_data(self):
        try:
            with open('data/games/game_data.json', 'r') as file:
                self.game_data = json.load(file)
        except FileNotFoundError:
            self.game_data = self.initialize_game_data()

    def save_game_data(self):
        with open('game_data.json', 'w') as file:
            json.dump(self.game_data, file, indent=4)

    def update_game_stats(self, game, key, value):
        if game in self.game_data:
            if key in self.game_data[game]:
                self.game_data[game][key] += value
            else:
                self.game_data[game][key] = value
        else:
            self.game_data[game] = {}
            self.game_data[game][key] = value
        self.save_game_data()   

    @commands.command(name='accept')
    async def accept_duel(self, ctx):
        if ctx.author.id not in self.duels:
            return

        duel = self.duels[ctx.author.id]
        duel.generate_letter()
        await ctx.send(f"The duel between {self.bot.get_user(duel.player1).mention} and {self.bot.get_user(duel.player2).mention} has begun! The challenge is to type as many words as you can that start with '{duel.letter}'. The duel will continue until one player's health reaches zero. Type your words separated by spaces.")

        await self.handle_duel(ctx, duel)

    @commands.command(name='blackjack')
    @commands.cooldown(1, 60, commands.BucketType.channel)
    async def blackjack(self, ctx):
        if ctx.channel.id != 1268242188328763474 and ctx.channel.id != 1259664562924552213:
            await ctx.send("Please utilize the <#1268242188328763474> channel to use the `!blackjack` command.")
            return
        
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(ctx.author.id))
        current_coins = stats.get('coins', 0)

        await ctx.send(f"You have {current_coins} {coin_icon}. How many {coin_icon} would you like to bet?")

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content.isdigit()

        while True:
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=30.0)
                bet = int(msg.content)
                if bet < 500:
                    await ctx.send(f"Bet must be at least 500 {coin_icon}. You have 30 seconds to respond accurately.")
                elif bet > 0 and bet <= current_coins:
                    break
                else:
                    await ctx.send(f"Invalid response. Bet must be a positive number and less than or equal to your balance ({current_coins} {coin_icon}). You have 30 seconds to respond accurately.")
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond! Please use !blackjack again.")
                return

        reduction_amt = -(bet)
        activity_tracker.update_user_activity(ctx.author, coins=reduction_amt)

        game = BlackjackGame(ctx.author, self.bot)
        await game.start_game(bet)
        self.blackjack_games[ctx.author.id] = game

        await game.send_hand(ctx)

    @commands.command(name='hit')
    async def hit(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.hit(ctx)

    @commands.command(name='stand')
    async def stand(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.stand(ctx)

    # Command to enter the lottery
    @commands.command(name='enterlottery')
    async def enter_lottery(self, ctx):
        user_id = str(ctx.author.id)

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        current_lottery_pot = self.lottery.get_current_lottery_pot()
        await ctx.send(f"Each ticket is worth {TICKET_COST} {coin_icon}. How many tickets would you like to buy? Current Lottery Pot: {current_lottery_pot} {coin_icon}")

        try:
            msg = await self.bot.wait_for('message', check=check, timeout=50.0)
            num_tickets = int(msg.content)
            cost = num_tickets * TICKET_COST

            await ctx.send(f"Are you sure you want to purchase {num_tickets} tickets for {cost} {coin_icon}? Say `!accept` if you wish to proceed.")

            msg = await self.bot.wait_for('message', check=check, timeout=50.0)
            if msg.content.lower() == '!accept':
                activity_tracker = self.bot.get_cog('ActivityTracker')
                user_data = activity_tracker.get_statistics(user_id)
                user_balance = user_data.get('coins', 0)

                if user_balance < cost:
                    await ctx.send(f"{ctx.author.mention}, you do not have enough {coin_icon} to buy {num_tickets} tickets. Your current balance is {user_balance} {coin_icon}.")
                    return

                activity_tracker.update_user_activity(ctx.author, coins=-cost)
                self.lottery.add_tickets(user_id, num_tickets)
                total_tickets = self.lottery.load_lottery_data()['participants'][user_id]

                current_lottery_pot = self.lottery.get_current_lottery_pot()
                await ctx.send(f"Purchase Successful. Check back at 11 PM EST for the lottery results. You now have a total of {total_tickets} tickets in the lottery. \nYour {coin_icon} Balance: {user_balance - cost} {coin_icon}, Current Lottery Pot: {current_lottery_pot} {coin_icon}")
            else:
                await ctx.send("Purchase canceled.")
        except ValueError:
            await ctx.send("Invalid number of tickets.")
        except asyncio.TimeoutError:
            await ctx.send("You took too long to respond.")

    @commands.command(name='lotterystatus')
    async def lottery_status(self, ctx):
        data = self.lottery.load_lottery_data()
        total_tickets = data['total_tickets']
        participants = len(data['participants'])
        current_lottery_pot = self.lottery.get_current_lottery_pot()
        await ctx.send(f"__**Current Lottery Status:**__\nTotal Tickets Sold: {total_tickets}\nNumber of Participants: {participants}\nCurrent Lottery Pot: {current_lottery_pot} {coin_icon}")

    @commands.command(name='dealerpoker', help='Starts a dealer vs. player poker game')
    @commands.cooldown(1, 90, commands.BucketType.channel)
    async def start_dealer_poker(self, ctx):
        if ctx.channel.id != 1268244378787254354 and ctx.channel.id != 1259664562924552213:
            await ctx.send("Please utilize the <#1268244378787254354> channel to use the `!dealerpoker` command.")
            return
        
        if ctx.channel.id in self.dealerpoker_games:
            await ctx.send("A dealer poker game is already running in this channel!")
            return

        self.dealerpoker_games[ctx.channel.id] = True

        try:
            poker_game = DealerPoker(ctx, self.bot)
            await poker_game.start_game()
        finally:
            self.dealerpoker_games.pop(ctx.channel.id, None)

    @commands.command(name='slots')
    @commands.cooldown(1, 45, commands.BucketType.channel)
    async def play_slots(self, ctx):
        if ctx.channel.id != 1269351770107285575 and ctx.channel.id != 1259664562924552213:
            await ctx.send("Please utilize the <#1269351770107285575> channel to use the `!slots` command.")
            return
        
        if ctx.channel.id in self.slot_games:
            await ctx.send("A slot game is already running in this channel!")
            return
    
        self.slot_games[ctx.channel.id] = True
        
        try:
            slots = SlotMachine(ctx, self.bot)
            await slots.start_game()
        finally:
            self.slot_games.pop(ctx.channel.id, None)

    @play_slots.error
    async def play_slots_error(self, ctx, error):
        if isinstance(error, CommandOnCooldown):
            await ctx.send(f"`!slots` is on cooldown.  Please wait {error.retry_after:.2f} seconds.")

    @start_dealer_poker.error
    async def start_dealer_poker_error(self, ctx, error):
        if isinstance(error, CommandOnCooldown):
            await ctx.send(f"`!dealerpoker` is on cooldown.  Please wait {error.retry_after:.2f} seconds.")

    @blackjack.error
    async def blackjack_error(self, ctx, error):
        if isinstance(error, CommandOnCooldown):
            await ctx.send(f"`!blackjack` is on cooldown.  Please wait {error.retry_after:.2f} seconds.")


async def setup(bot):
    await bot.add_cog(GameManager(bot))


.\bot\games\lottery.py
import os, random, json, math, asyncio, logging
from datetime import datetime, timedelta, timezone
from discord.ext import commands, tasks
from settings.settings import load_settings

logging.basicConfig(level=logging.INFO)

TICKET_COST = 100

settings = load_settings()
coin_icon = settings['coin_icon']

class Lottery:
    def __init__(self, bot):
        self.bot = bot  # Set the bot for the lottery.
        self.check_lottery_draw.start()  # Starting the task that checks the lottery draw time.
        self.initial_pot = 30000  # Initial pot amount
        self.LOTTERY_FILE = 'data/games/lottery/lottery.json'

    def load_lottery_data(self):
        if not os.path.exists(self.LOTTERY_FILE):
            data = {'total_tickets': 0, 'participants': {}, 'current_pot': self.initial_pot}
            self.save_lottery_data(data)
        else:
            with open(self.LOTTERY_FILE, 'r') as file:
                data = json.load(file)
                if 'total_tickets' not in data:
                    data['total_tickets'] = 0
                if 'participants' not in data:
                    data['participants'] = {}
                if 'current_pot' not in data:
                    data['current_pot'] = self.initial_pot
        return data

    def save_lottery_data(self, data):
        with open(self.LOTTERY_FILE, 'w') as file:
            json.dump(data, file, indent=4)

    def get_current_lottery_pot(self):
        data = self.load_lottery_data()
        return data.get('current_pot', self.initial_pot)

    def add_tickets(self, user_id, ticket_count):
        data = self.load_lottery_data()
        if user_id not in data['participants']:
            data['participants'][user_id] = 0
        data['participants'][user_id] += ticket_count
        data['total_tickets'] += ticket_count
        data['current_pot'] += ticket_count * TICKET_COST
        self.save_lottery_data(data)

    def draw_winner(self):
        data = self.load_lottery_data()
        if data['total_tickets'] > 0:
            tickets = [user_id for user_id, count in data['participants'].items() for _ in range(count)]
            winner = random.choice(tickets)
            current_pot = data['current_pot']
            data['participants'] = {}
            data['total_tickets'] = 0
            data['current_pot'] = self.initial_pot
            self.save_lottery_data(data)
            return winner, current_pot
        return None, 0

    @tasks.loop(minutes=1)
    async def check_lottery_draw(self):
        data = self.load_lottery_data()
        channel = self.bot.get_channel(1252055670778368013)
        now = datetime.now(timezone.utc)
        if now.hour == 3 and now.minute == 0:
            await self.announce_winner()
        elif (now.hour == 16 and now.minute == 0) or (now.hour == 19 and now.minute == 0) or (now.hour == 1 and now.minute == 0): 
            await channel.send(f"Remember that 11 PM, the lottery will be drawn!  Type `!enterlottery` to buy tickets.")
            await channel.send(f"Current Pot: {data['current_pot']} {coin_icon}")

    async def announce_winner(self):
        data = self.load_lottery_data()
        if not data['participants']:
            logging.info("No participants in the lottery.")
            return

        channel = self.bot.get_channel(1252055670778368013)

        message = await channel.send("Today's Lottery Winner: ...")

        start_time = datetime.now(timezone.utc)
        duration = 60
        end_time = start_time + timedelta(seconds=duration)

        initial_sleep_time = 1
        final_sleep_time = 3
        total_steps = 1000

        current_step = 0
        while datetime.now(timezone.utc) < end_time:
            participant = random.choice(list(data['participants'].items()))
            user_id, tickets = participant
            ticket_number = random.choice(list(range(tickets)))
            member = await self.bot.fetch_user(user_id)
            await message.edit(content=f"Picking Lottery Winner... {member.display_name} (Ticket #{ticket_number})")

            sleep_time = initial_sleep_time + (final_sleep_time - initial_sleep_time) * (1 - math.exp(-current_step / total_steps))
            await asyncio.sleep(sleep_time)

            current_step += 1

        winner_id, current_pot = self.draw_winner()
        winner = await self.bot.fetch_user(winner_id)
        await message.edit(content=f"Today's Lottery Winner: {winner.display_name} (Ticket #{ticket_number})")
        await channel.send(content=f"{winner.display_name} has won {current_pot} {coin_icon}!")

        # Update the winner's activity
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if winner:
            activity_tracker.update_user_activity(winner, coins=current_pot)
            await channel.send(content=f"Congratulations {winner.display_name}! Your new balance is {activity_tracker.get_statistics(str(winner.id)).get('coins', 0)} {coin_icon}.")

.\bot\games\slots.py
import discord, random, os, asyncio, json, asyncio, itertools
from discord.ext import commands
from PIL import Image, ImageDraw, ImageFont
from settings.settings import load_settings

class SlotMachine:
    def __init__(self, ctx, bot):
        self.bot = bot
        self.ctx = ctx
    
    def NotAvailable(self, ctx):
        self.ctx.send("Slots are currently in development.")

.\bot\games\__init__.py


.\bot\misc\referral.py
import discord
import json
import os
from discord.ext import commands
from settings.settings import load_settings
from datetime import datetime, timezone

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

# Load settings from a settings file
settings = load_settings()
coin_icon = settings['coin_icon']

# The reward for inviting a new member
INVITE_REWARD = 50000

INVITE_TRACKER_FILE = 'data/serverside/invitetracker.json'

def initialize_invite_tracker():
    if not os.path.exists(INVITE_TRACKER_FILE):
        with open(INVITE_TRACKER_FILE, 'w') as f:
            json.dump({}, f)

def load_invite_tracker():
    with open(INVITE_TRACKER_FILE, 'r') as f:
        return json.load(f)

def save_invite_tracker(invite_tracker):
    with open(INVITE_TRACKER_FILE, 'w') as f:
        json.dump(invite_tracker, f, indent=4)

initialize_invite_tracker()
invite_tracker = load_invite_tracker()

class ReferralTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.invite_tracker = invite_tracker  # Load the invite tracker from the JSON file

    @commands.Cog.listener()
    async def on_ready(self):
        # Initializes the invite tracker with the current invite uses for each guild.
        for guild in self.bot.guilds:
            self.invite_tracker[guild.id] = {invite.code: invite.uses for invite in await guild.invites()}
        save_invite_tracker(self.invite_tracker)
        print("Invite tracker initialized.")

    @commands.Cog.listener()
    async def on_member_join(self, member):
        # Check if the member's account is older than 60 days
        if (datetime.now(timezone.utc) - member.created_at).days < 60:
            lickertalk_channel = discord.utils.get(member.guild.text_channels, name='licker-talk')
            if lickertalk_channel:
                await lickertalk_channel.send(f"{member.mention}'s account is not eligible for the referral reward (account must be over 60 days old).")
            return

        # Get the invites before the member joined
        invites_before_join = self.invite_tracker.get(member.guild.id, {})
        # Get the current invites after the member joined
        invites_after_join = await member.guild.invites()

        # Determine which invite was used by comparing the uses before and after
        used_invite = None
        for invite in invites_after_join:
            if invite.uses > invites_before_join.get(invite.code, 0):
                used_invite = invite
                break

        if used_invite:
            inviter = used_invite.inviter
            activity_tracker = self.bot.get_cog('ActivityTracker')

            if activity_tracker:
                try:
                    # Update the inviter's and the new member's coin balance
                    activity_tracker.update_user_coins(inviter, INVITE_REWARD)
                    activity_tracker.update_user_coins(member, INVITE_REWARD)

                    # Announce the successful invite in the "lickertalk" channel
                    lickertalk_channel = discord.utils.get(member.guild.text_channels, name='licker-talk')
                    if lickertalk_channel:
                        await lickertalk_channel.send(
                            f"{inviter.mention} has successfully invited {member.mention} to this server. Both have been rewarded {INVITE_REWARD} {coin_icon}!"
                        )

                    # Update the invite tracker with the new number of uses
                    self.invite_tracker[member.guild.id][used_invite.code] = used_invite.uses
                    save_invite_tracker(self.invite_tracker)

                except Exception as e:
                    print(f"Error updating coins: {e}")
            else:
                print("ActivityTracker cog not found.")
        else:
            print("No used invite found.")

    @commands.command(name='invitemessage')
    async def invitemessage(self, ctx):
        # Create a new invite link with a maximum of 1 use and a 1-day expiration time
        invite = await ctx.channel.create_invite(max_uses=1, max_age=86400, unique=True)
        invite_message = (
            f"Hey! Join Gilligan Lickers for you and me to get {INVITE_REWARD} {coin_icon}. "
            f"Use my referral link (valid for one day): {invite.url}"
        )

        await ctx.send(
            f"{ctx.author.mention}, here's your invite link and message to share:\n\n"
            f"{invite_message}"
        )

async def setup(bot):
    await bot.add_cog(ReferralTracker(bot))


.\bot\misc\__init__.py


.\bot\shop\shop.py
import discord
from discord.ext import commands
import pandas as pd
import os
import json
import matplotlib.pyplot as plt
from settings.settings import load_settings

# Load the bot's settings, including coin icon
settings = load_settings()
coin_icon = settings['coin_icon']

class Shop(commands.Cog):
    def __init__(self, bot):
        """Initialize the bot and load upgrades and user data"""
        self.bot = bot
        self.upgrades = self.load_upgrades()  # Load the available upgrades
        self.load_user_data()  # Load user data

    def load_upgrades(self):
        """Load the available upgrades. These can be customized as needed."""
        return [
            {"name": "Intimidation", "max_level": 99},
            {"name": "Alertness", "max_level": 99},
            {"name": "Intelligence", "max_level": 99}
        ]

    def load_user_data(self):
        """Load user data from a JSON file. If the file doesn't exist, initialize an empty dictionary."""
        if os.path.exists('data/player_data.json'):
            with open('data/player_data.json', 'r') as f:
                self.user_data = json.load(f)
        else:
            self.user_data = {}

    def save_user_data(self):
        """Save user data to a JSON file."""
        with open('data/player_data.json', 'w') as f:
            json.dump(self.user_data, f, indent=4)

    def get_user_level(self, user_id, upgrade_name):
        """Retrieve the level of a specific upgrade for a user. Defaults to 0 if not found."""
        if str(user_id) in self.user_data:
            return self.user_data[str(user_id)].get(f"{upgrade_name.lower()}_level", 0)
        return 0

    @commands.command(name='shop')
    async def shop(self, ctx):
        """Command to display the shop to the user"""
        user_id = str(ctx.author.id)

        # Prepare data for the shop table
        data = {
            "ATTRIBUTES": [upgrade['name'] for upgrade in self.upgrades],  # List of attribute names
            "LEVEL": [self.get_user_level(user_id, upgrade['name']) for upgrade in self.upgrades]  # Corresponding levels
        }

        # Create a DataFrame from the data
        df = pd.DataFrame(data)

        # Create a matplotlib figure for the shop table
        fig, ax = plt.subplots(figsize=(20, 20))  # Figure size: width 15, height 20
        # figsize=(15, 20):
        # - This sets the size of the entire figure.
        # - 15 is the width of the figure. Increasing this makes the figure wider.
        # - 20 is the height of the figure. Increasing this makes the figure taller.
        
        ax.axis('tight')  # Remove axis lines to make the table look cleaner
        ax.axis('off')  # Hide the axes completely

        # Create the table with invisible lines
        table = ax.table(
            cellText=df.values,  # The actual data to be displayed in the table
            colLabels=df.columns,  # Column headers: 'ATTRIBUTES' and 'LEVEL'
            cellLoc='left',  # Align text in cells to the left
            loc='upper left',  # Position the table at the upper left of the figure
            edges='horizontal'  # Only horizontal lines are visible
        )
        table.auto_set_font_size(False)  # Disable automatic font resizing
        table.set_fontsize(60)  # Set the font size for the table content
        # set_fontsize(60):
        # - This sets the font size for the text in the table cells (excluding headers).
        # - Increase this value to make the text larger.
        
        table.scale(1, 1)  # Scale the table: width factor 1.5, height factor 2.5
        # table.scale(1.5, 2.5):
        # - This scales the size of the table itself.
        # - 1.5 is the width scaling factor. Increasing this value makes the table wider.
        # - 2.5 is the height scaling factor. Increasing this value makes the table taller.

        # Adjust column widths and row heights
        cell_dict = table.get_celld()  # Get a dictionary of cells
        for i in range(len(df) + 1):  # Loop through all rows (+1 to include header row)
            for j in range(len(df.columns)):  # Loop through all columns
                cell = cell_dict[(i, j)]  # Get the specific cell
                cell.set_height(0.075)  # Set height for each row; increase for more space
                # set_height(0.2):
                # - This sets the height of each row in the table.
                # - 0.2 is a fraction of the table's total height.
                # - Increasing this value makes each row taller.
                
                if j == 0:
                    cell.set_width(0.6)  # Set width for the first column (attributes)
                    # set_width(0.6):
                    # - This sets the width of the first column.
                    # - 0.6 is a fraction of the table's total width.
                    # - Increasing this value makes the first column wider.
                    
                else:
                    cell.set_width(0.4)  # Set width for the second column (levels)
                    # set_width(0.4):
                    # - This sets the width of the second column.
                    # - 0.4 is a fraction of the table's total width.
                    # - Increasing this value makes the second column wider.

                if i == 0:
                    cell.set_height(0.1)

        # Customize the table header
        for (i, j), cell in table.get_celld().items():
            cell.set_edgecolor('black')  # Set edge color to white to make lines invisible
            cell.set_linewidth(1)  # Set line width to 0 to remove lines
            if i == 0:  # Header row
                cell.set_text_props(weight='bold', color='black', ha='right', va='center')  # Bold and black header text, center-aligned horizontally, 
                cell.set_fontsize(90) 
                cell.set_facecolor('white') # Set font size for header
                # set_fontsize(90):
                # - This sets the font size for the header text.
                # - Increase this value to make the header text larger.
                # set_text_props(ha='center'):
                # - ha stands for horizontal alignment.
                # - 'center' aligns the text in the center of the cell.
            else:  # Data rows
                cell.set_text_props(color='black')
                if j == 0:
                    cell.set_text_props(ha='left')  # Left-align attribute names
                    # set_text_props(ha='left'):
                    # - ha stands for horizontal alignment.
                    # - 'left' aligns the text to the left of the cell.
                elif j == 1:
                    cell.set_text_props(ha='center')  # Center-align levels
                    # set_text_props(ha='center'):
                    # - ha stands for horizontal alignment.
                    # - 'center' aligns the text in the center of the cell.

        # Save the figure to a file
        image_path = 'utils/images/shop_list.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)  # Save the image with tight bounding box and high resolution
        # bbox_inches='tight':
        # - Ensures the bounding box of the plot is tightly fit around the content.
        # dpi=300:
        # - Sets the dots per inch (DPI) for the saved image. Higher DPI means higher resolution.

        # Create the embed and add the action message
        file = discord.File(image_path, filename='shop_list.png')
        embed = discord.Embed(title="Shop")
        embed.set_image(url="attachment://shop_list.png")
        await ctx.send(embed=embed, file=file)

        # Remove the saved image file after sending
        os.remove(image_path)

    @commands.command(name='upgrade')
    async def upgrade(self, ctx, upgrade_name: str):
        """Command to upgrade a specific upgrade for the user"""
        upgrade_name = upgrade_name.capitalize()  # Ensure the upgrade name is capitalized
        user_id = str(ctx.author.id)

        # Check if the specified upgrade is valid
        if upgrade_name not in [u['name'] for u in self.upgrades]:
            await ctx.send(f"{ctx.author.mention}, {upgrade_name} is not a valid upgrade.")
            return

        # Retrieve the upgrade details
        upgrade = next(u for u in self.upgrades if u['name'] == upgrade_name)
        current_level = self.get_user_level(user_id, upgrade_name)

        # Check if the upgrade is already at max level
        if current_level >= upgrade['max_level']:
            await ctx.send(f"{ctx.author.mention}, {upgrade_name} is already at max level.")
            return

        # Add logic to deduct coins and upgrade the level (implement as needed)
        # Update the user's level for the specified upgrade
        self.user_data[user_id][f"{upgrade_name.lower()}_level"] = current_level + 1
        self.save_user_data()

        # Notify the user of the successful upgrade
        await ctx.send(f"{ctx.author.mention}, {upgrade_name} has been upgraded to level {current_level + 1}.")

# Setup function to add the Shop cog to the bot
async def setup(bot):
    await bot.add_cog(Shop(bot))


.\bot\status\offline.py
import aiohttp
import asyncio
import pytz
from datetime import datetime, timedelta
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    def get_estimated_time_back_up(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        estimated_time = now + timedelta(hours=16)
        hour = estimated_time.hour if estimated_time.hour <= 12 else estimated_time.hour - 12
        period = "AM" if estimated_time.hour < 12 else "PM"
        formatted_time = f"{hour}:{estimated_time.strftime('%M')} {period} EST"
        return estimated_time.strftime("%m/%d/%Y"), formatted_time

    def get_most_recent_script(self):
        scripts_directory = 'bot'
        scripts = [os.path.join(root, file) for root, _, files in os.walk(scripts_directory) for file in files if file.endswith('.py')]
        if not scripts:
            return "Unknown Script", "No recent updates detected"

        most_recent_script = max(scripts, key=lambda x: os.path.getmtime(x))
        script_name = os.path.basename(most_recent_script).replace('.py', '').capitalize()
        return script_name, f"Developing/Fixing the {script_name} feature"

    async def update_status_offline(self):
        current_date, current_time = self.get_current_time()
        estimated_date, estimated_time_back_up = self.get_estimated_time_back_up()
        script_name, reasoning = self.get_most_recent_script()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** OFFLINE

**Reasoning:** {reasoning}
**Estimated Date Back Up:** {estimated_date}
**Estimated Time Back Up:** {estimated_time_back_up}
**Impact on Users:** Inability to use bot
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to OFFLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_offline()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_offline()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\online.py
import aiohttp
import asyncio
import pytz
from datetime import datetime
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    async def update_status_online(self):
        current_date, current_time = self.get_current_time()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** ONLINE

**Reasoning:** Bot started successfully
**Estimated Date Back Up:** N/A
**Estimated Time Back Up:** N/A
**Impact on Users:** Fully operational
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to ONLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_online()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_online()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\setup.py
from . import offline, online

async def setup(bot):
    pass  # No need to add any cogs or extensions here as the status scripts are executed separately


.\settings\settings.py
import json 
import os

def load_settings():
    # Get the current directory of the settings.py file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    # Construct the path to the settings.json file
    settings_path = os.path.join(current_dir, 'json', 'settings.json')
    # Open and load the settings.json file
    with open(settings_path, 'r', encoding='utf-8') as f:
        settings = json.load(f)
    return settings

.\utils\graphics.py
import matplotlib.pyplot as plt  # Import Matplotlib for creating visualizations
import matplotlib.patches as patches  # Import patches to draw shapes
import requests  # Import requests to download images from the web
from PIL import Image, ImageDraw, ImageOps  # Import Pillow to handle image processing
from io import BytesIO  # Import BytesIO to handle image data in memory
import numpy as np  # Import NumPy for numerical operations
import os  # Import os to handle file paths

# Function to generate an image showing the user's level information.
def generate_level_image(username, level, progress, points, next_level, avatar_url):
    try:
        # Download the avatar image from the provided URL
        response = requests.get(avatar_url)
        avatar = Image.open(BytesIO(response.content)).resize((250, 225))  # Resize avatar to 225x225 pixels

        shadow_offset = 2  # Offset for the shadow
        font_name = 'Verdana'

        # Create a new figure (canvas)
        fig, ax = plt.subplots(figsize=(7, 2))  # Set figure size
        fig.patch.set_facecolor((255/255, 127/255, 80/255))  # Set figure background color (light pink)
        ax.set_facecolor((173/255, 216/255, 230/255))  # Set axis background color (light blue)

        ax.set_xlim(0, 1000)  # Set x-axis limit
        ax.set_ylim(0, 250)  # Set y-axis limit
        ax.axis('off')  # Hide axes

        # Draw the avatar image on the canvas
        plt.imshow(avatar, aspect='auto', extent=(10, 10 + avatar.size[0], 12.5, 12.5 + avatar.size[1]))

        font_properties1 = {'family': font_name, 'weight': 'extra bold', 'size': 25}  # Font properties for username
        font_properties2 = {'family': font_name, 'weight': 'bold', 'size': 15}  # Font properties for points text
        font_properties3 = {'family': font_name, 'weight': 'extra bold', 'size': 20}

        # Draw the username text next to the avatar
        plt.text(275 + shadow_offset, 200 - shadow_offset, username, fontdict=font_properties1, color='black', ha='left', va='center')
        plt.text(275, 200, username, fontdict=font_properties1, color='white', ha='left', va='center')
        # Draw the points text
        plt.text(275 + shadow_offset, 150 - shadow_offset, f"Points: {points}", fontdict=font_properties2, color='black', ha='left', va='center')
        plt.text(275, 150, f"Points: {points}", fontdict=font_properties2, color='white', ha='left', va='center')

        # Define the position and size of the progress bar
        canvas_width = 1000  # Width of the canvas
        bar_width = 450  # Width of the progress bar
        bar_height = 70  # Height of the progress bar
        bar_x = ((canvas_width - bar_width + 225) / 2) + 10  # X-coordinate of the progress bar (centered horizontally)
        bar_y = 20  # Y-coordinate of the progress bar

        # Draw the background of the progress bar
        ax.add_patch(patches.Rectangle((bar_x, bar_y), bar_width, bar_height, color=(255/255, 255/255, 255/255), alpha=0.3))

        # Calculate the width of the filled part of the progress bar
        fill_width = (progress / 100) * bar_width
        # Draw the filled part of the progress bar
        ax.add_patch(patches.Rectangle((bar_x, bar_y), fill_width, bar_height, color=(76/255, 175/255, 80/255)))

        # Draw the current level text
        plt.text(bar_x - 10 + shadow_offset, (bar_y + bar_height / 2) - 12.5 - shadow_offset, f"{level}", fontdict=font_properties1, color='black', ha='right', va='center')
        plt.text(bar_x - 10, (bar_y + bar_height / 2) - 12.5, f"{level}", fontdict=font_properties1, color='white', ha='right', va='center')

        plt.text((bar_x + (bar_width / 2))  + shadow_offset, (bar_y + (bar_height / 2)) - shadow_offset, f"{progress:.2f}%", fontdict=font_properties3, color='black', ha='center', va='center')
        plt.text((bar_x + (bar_width / 2)), (bar_y + (bar_height / 2)), f"{progress:.2f}%", fontdict=font_properties3, color='white', ha='center', va='center')

        # Draw the next level text
        plt.text(bar_x + bar_width + 10 + shadow_offset, (bar_y + bar_height / 2) - 12.5 - shadow_offset, f"{next_level}", fontdict=font_properties1, color='black', ha='left', va='center')
        plt.text(bar_x + bar_width + 10, (bar_y + bar_height / 2) - 12.5, f"{next_level}", fontdict=font_properties1, color='white', ha='left', va='center')

        # Save the figure to a BytesIO object
        image_buffer = BytesIO()
        plt.savefig(image_buffer, format='png', bbox_inches='tight', pad_inches=0, dpi=100)
        plt.close()
        image_buffer.seek(0)  # Move the cursor to the start of the BytesIO object

        return image_buffer

    except Exception as e:
        print(f"Error in generate_level_image: {e}")
        return None

def generate_statistics_visualization(stats):
    labels = ['Messages Sent', 'Minutes in Voice', 'Minutes Online']  # Labels for the bars
    user_values = [stats.get('messages_sent', 0), stats.get('minutes_in_voice', 0), stats.get('minutes_online', 0)]  # User's stats
    server_averages = [100, 50, 300]  # Server average stats (dummy values, should be replaced with real data)

    x = np.arange(len(labels))  # X-axis positions for the bars

    fig, ax = plt.subplots()  # Create a new figure and axis
    ax.bar(x - 0.2, user_values, width=0.4, label='User')  # Draw user bars
    ax.bar(x + 0.2, server_averages, width=0.4, label='Server Average')  # Draw server average bars

    ax.set_xlabel('Activity')  # Set x-axis label
    ax.set_ylabel('Count')  # Set y-axis label
    ax.set_title('User Activity vs Server Average')  # Set title
    ax.set_xticks(x)  # Set x-axis ticks
    ax.set_xticklabels(labels)  # Set x-axis labels
    ax.legend()  # Add legend

    plt.tight_layout()  # Adjust layout to fit everything
    image_path = 'utils/images/statistics_visualization.png'  # Define the file path to save the image
    plt.savefig(image_path)  # Save the figure to a file
    plt.close()  # Close the figure to free up memory

    return image_path  # Return the path to the generated image


.\utils\__init__.py


