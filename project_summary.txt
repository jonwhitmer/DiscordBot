./
    main.py
    resetdata.py
    summary.py
    test.py
    bot/
        activity_tracker.py
        commands.py
        level_widget.py
        shop.py
        __init__.py
        games/
            blackjack.py
            dealerpoker.py
            duel.py
            game_manager.py
            lottery.py
            __init__.py
            __pycache__/
        misc/
            referral.py
            __init__.py
            __pycache__/
        status/
            offline.py
            online.py
            setup.py
            __pycache__/
        __pycache__/
    data/
        games/
            lottery/
    settings/
        .env
        settings.py
        json/
        __pycache__/
    utils/
        graphics.py
        __init__.py
        images/
            blackjackdump/
            deckofcards/
                10/
                2/
                3/
                4/
                5/
                6/
                7/
                8/
                9/
                A/
                J/
                K/
                Q/
            levelimages/
            pokerdump/
        sounds/
            bottalking/
            musicdump/
        __pycache__/


.\main.py
import discord
from discord.ext import commands
import os
import subprocess
import sys
import signal
from settings.settings import load_settings
from dotenv import load_dotenv

load_dotenv(dotenv_path='settings/.env')
TOKEN = os.getenv('TOKEN')

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

def update_status_offline():
    script_path = os.path.join('bot', 'status', 'offline.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to OFFLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

def signal_handler(signal, frame):
    print("Signal received, updating status to OFFLINE...")
    update_status_offline()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    await bot.load_extension('bot.activity_tracker')
    await bot.load_extension('bot.commands')
    await bot.load_extension('bot.shop')
    await bot.load_extension('bot.games.game_manager')
    await bot.load_extension('bot.misc.referral')
    print("Extensions loaded")

    # Update the bot status to ONLINE
    script_path = os.path.join('bot', 'status', 'online.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to ONLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

bot.run(TOKEN)


.\resetdata.py
import json

def wipe_activity_data():
    with open('data/player_data.json', 'w') as f:
        json.dump({}, f, indent=4)


wipe_activity_data()

.\summary.py
import os

def generate_directory_tree(directory, exceptions):
    tree = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list or is a .git directory
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions) or '.git' in relative_root:
            continue
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        tree.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list or is a git-related file
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions) and '.git' not in file_relative_path:
                if any(file.endswith(ext) for ext in ['.py', '.env']):
                    tree.append(f"{subindent}{file}")
    return tree

def generate_summary(directory, exceptions, include_extensions):
    summary = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list or is a .git directory
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions) or '.git' in relative_root:
            continue
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list, has an allowed extension, or is a git-related file
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions) and '.git' not in file_relative_path:
                if any(file.endswith(ext) for ext in include_extensions):
                    file_path = os.path.join(root, file)
                    summary.append(file_path)
    return summary

def read_and_prepend_file(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        content = file.read()
    return f"{file_path}\n{content}"

if __name__ == "__main__":
    exceptions = [
        os.path.normpath('extensions/gulp'),
        os.path.normpath('assets/instance/database.db'),
        os.path.normpath('assets/migrations')
    ]  # Add more directories to this list if needed
    include_extensions = [
        '.py'
    ]  # Only include .py files for content
    with open('project_summary.txt', 'w', encoding='utf-8') as f:
        # Write directory tree
        directory_tree = generate_directory_tree('.', exceptions)
        for line in directory_tree:
            f.write(line + '\n')

        f.write('\n\n')  # Separate the directory tree from the file contents

        # Write file contents
        summary = generate_summary('.', exceptions, include_extensions)
        for file_path in summary:
            file_content = read_and_prepend_file(file_path)
            f.write(file_content + '\n\n')


.\test.py
INITIAL_LEVEL_POINTS_NEEDED = 1000  # Starting with a higher initial value
INITIAL_LEVEL = 1

def calculate_level_points(POINTS_NEEDED, CURRENT_LEVEL, growth_factor):
    if CURRENT_LEVEL == 1:
        return INITIAL_LEVEL_POINTS_NEEDED
    else:
        return round(POINTS_NEEDED * growth_factor)

# Calculate total points needed to reach a certain level
def total_points_to_reach_level(target_level, growth_factor):
    total_points = 0
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(2, target_level + 1):
        points_needed = calculate_level_points(points_needed, level, growth_factor)
        total_points += points_needed
    return total_points

# Adjust growth factor to fit the goal
def find_optimal_growth_factor(target_levels, target_points):
    growth_factor = 1.01
    while True:
        match = True
        for target_level, target_point in zip(target_levels, target_points):
            total_points = total_points_to_reach_level(target_level, growth_factor)
            if abs(total_points - target_point) > target_point * 0.01:  # Allow 1% tolerance
                match = False
                break
        if match:
            break
        growth_factor += 0.001
    return growth_factor - 0.001  # Step back to the last valid growth factor

# Target levels and their corresponding total points
target_levels = [10, 100, 300]
target_points = [12000, 97000, 600000]

# Calculate the optimal growth factor
optimal_growth_factor = find_optimal_growth_factor(target_levels, target_points)

# Print the optimal growth factor
print(f"Optimal growth factor: {optimal_growth_factor:.4f}")

# Calculate points needed for each level incrementally
def points_needed_per_level(target_level, growth_factor):
    points_per_level = []
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(1, target_level):
        next_level_points = calculate_level_points(points_needed, level, growth_factor)
        points_per_level.append((level, next_level_points))
        points_needed = next_level_points
    return points_per_level

# Print points needed for each level from 1 to target level
target_level = 500
points_per_level = points_needed_per_level(target_level, optimal_growth_factor)
for level, points in points_per_level:
    print(f"Points needed from level {level} to {level + 1}: {points} points")


.\bot\activity_tracker.py
# activity_tracker.py
import discord
from discord.ext import commands, tasks
import json
import os
import asyncio
from datetime import datetime, timezone
from gtts import gTTS
from pydub import AudioSegment

# Variables for point increments and bot testing mode
MESSAGE_POINTS = 15
ONLINE_POINTS = 2
VOICE_CHAT_POINTS = 15

class ActivityTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.activity_data = self.load_activity_data()
        self.reset_daily_stats.start()
        self.track_activity.start()

    def load_activity_data(self):
        if os.path.exists('data/player_data.json'):
            with open('data/player_data.json', 'r') as f:
                return json.load(f)
        return {}

    def save_activity_data(self):
        with open('data/player_data.json', 'w') as f:
            json.dump(self.activity_data, f, indent=4)

    @tasks.loop(hours=24)
    async def reset_daily_stats(self):
        now = datetime.now(timezone.utc)
        if now.hour == 5:  # 5 AM UTC, midnight EST
            for user_id in self.activity_data:
                self.activity_data[user_id]['points_today'] = 0
                print(f"Reset Points Today for {user_id}")
            self.save_activity_data()

    @reset_daily_stats.before_loop
    async def before_reset_daily_stats(self):
        await self.bot.wait_until_ready()

    @tasks.loop(minutes=5)
    async def track_activity(self):
        for guild in self.bot.guilds:
            for member in guild.members:
                if member.status != discord.Status.offline and not member.bot:
                    user_id = str(member.id)
                    if user_id not in self.activity_data:
                        self.activity_data[user_id] = {
                            "username": member.name,
                            "points": 0,
                            "points_today": 0,
                            "level": 1,
                            "messages_sent": 0,
                            "characters_typed": 0,
                            "minutes_in_voice": 0,
                            "minutes_online": 0,
                            "total_talking_time": 0,
                            "coins": 0  # Add coins attribute
                        }
                    self.activity_data[user_id]['minutes_online'] += ONLINE_POINTS  # Increment by ONLINE_POINTS
                    self.save_activity_data()

    def update_user_activity(self, user, points=0, coins=0):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "points": 0,
                "points_today": 0,
                "level": 1,
                "messages_sent": 0,
                "characters_typed": 0,
                "minutes_in_voice": 0,
                "minutes_online": 0,
                "total_talking_time": 0,
                "coins": 0  # Add coins attribute
            }
        previous_level = self.activity_data[user_id]['level']
        self.activity_data[user_id]['points'] += points
        self.activity_data[user_id]['points_today'] += points
        self.activity_data[user_id]['coins'] += coins

        # Check for level up
        new_level, _ = get_current_level(self.activity_data[user_id]['points'])
        if new_level > previous_level:
            self.activity_data[user_id]['level'] = new_level
            # Announce level up in main chat
            self.bot.loop.create_task(
                self.announce_level_up_in_main_chat(user, previous_level, new_level)
            )
            
            # If user is in a voice channel, make the bot join and announce via TTS
            if user.voice and user.voice.channel:
                self.bot.loop.create_task(self.announce_level_up_in_voice(user, previous_level, new_level))

        self.save_activity_data()

    async def announce_level_up_in_main_chat(self, user, previous_level, new_level):
        main_channel = discord.utils.get(user.guild.text_channels, name='licker-talk')
        if main_channel:
            await main_channel.send(f"{user.mention} has leveled up from level {previous_level} to level {new_level}. Congratulations, gilligano!")

    async def announce_level_up_in_voice(self, user, previous_level, new_level):
        voice_channel = user.voice.channel
        vc = await voice_channel.connect()
        tts_message = f"{user.display_name} has leveled up from level {previous_level} to level {new_level}. Congratulations, gilligano!"
        
        tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts.mp3')
        tts = gTTS(tts_message, lang='en', tld='co.in')
        tts.save(tts_file_path)

        sound = AudioSegment.from_file(tts_file_path)

        # Deepen the pitch (lowering by 4 semitones)
        new_sound = sound._spawn(sound.raw_data, overrides={
            "frame_rate": int(sound.frame_rate * 0.7)
        }).set_frame_rate(sound.frame_rate)

        # Save the new sound
        new_tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts_deep.mp3')
        new_sound.export(new_tts_file_path, format="mp3")

        vc.play(discord.FFmpegPCMAudio(source=new_tts_file_path))

        while vc.is_playing():
            await asyncio.sleep(1)

        await vc.disconnect()

        # Delete the TTS files after 10 seconds
        await asyncio.sleep(5)
        if os.path.exists(tts_file_path):
            os.remove(tts_file_path)
        if os.path.exists(new_tts_file_path):
            os.remove(new_tts_file_path)

    def update_user_coins(self, user, coins):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "coins": 0,
                # Add other fields as necessary
            }
        self.activity_data[user_id]['coins'] += coins
        self.save_activity_data()

    def transfer_coins(self, from_user, to_user, amount):
        from_user_id = str(from_user.id)
        to_user_id = str(to_user.id)

        if from_user_id not in self.activity_data or to_user_id not in self.activity_data:
            return False, "User data not found."

        if self.activity_data[from_user_id]['coins'] < amount:
            return False, "Insufficient balance."

        self.activity_data[from_user_id]['coins'] -= amount
        self.activity_data[to_user_id]['coins'] += amount
        self.save_activity_data()

        return True, f"Transferred {amount} coins from {from_user.name} to {to_user.name}."

    @commands.Cog.listener()
    async def on_message(self, message):
        if not message.author.bot:
            self.update_user_activity(message.author, points=MESSAGE_POINTS)
            self.activity_data[str(message.author.id)]['messages_sent'] += 1
            self.activity_data[str(message.author.id)]['characters_typed'] += len(message.content)
            self.save_activity_data()

    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        if not member.bot:
            user_id = str(member.id)
            if before.channel is None and after.channel is not None:
                # User has joined a voice channel
                print(f"{member.name} has joined a voice channel.")
                self.activity_data[user_id]['voice_join_time'] = datetime.now().timestamp()

            elif before.channel is not None and after.channel is None:
                # User has left a voice channel
                if 'voice_join_time' in self.activity_data[user_id]:
                    time_spent = datetime.now().timestamp() - self.activity_data[user_id]['voice_join_time']
                    points_earned = int(time_spent / 60) * VOICE_CHAT_POINTS
                    print(f"{member.name} has left the voice channel. Points earned: {points_earned}.")
                    self.update_user_activity(member, points=points_earned)
                    self.activity_data[user_id]['total_talking_time'] += int(time_spent / 60)
                    del self.activity_data[user_id]['voice_join_time']

            self.save_activity_data()

    def get_statistics(self, user_id):
        return self.activity_data.get(user_id, {})
    
    def get_User_balance(self, user):
        user_id = str(user.id)
        if user_id in self.activity_data:
            return self.activity_data[user_id].get('coins', 0)
        return 0
    
def points_for_level_transition(level):
    return 10000 if level == 1 else (level + 1) * 5000

def points_for_next_level(current_level):
    total_points = 0
    for level in range(1, current_level + 1):
        total_points += points_for_level_transition(level)
    return total_points

def get_current_level(points):
    level = 1
    while points >= points_for_next_level(level):
        level += 1
    return level, points_for_next_level(level) - points_for_next_level(level - 1)


async def setup(bot):
    await bot.add_cog(ActivityTracker(bot))


.\bot\commands.py
# commands.py
from discord.ext import commands
import discord
from utils.graphics import generate_level_image, generate_statistics_visualization
import pandas as pd
from datetime import datetime, timedelta
import random
import pytz
from settings.settings import load_settings
import subprocess
import sys
import os
import asyncio
from discord.ui import View
from bot.activity_tracker import get_current_level, points_for_next_level
import yt_dlp as youtube_dl
from pydub import AudioSegment
from dotenv import load_dotenv
from tabulate import tabulate
import matplotlib.pyplot as plt
from gtts import gTTS
from pydub import AudioSegment

# Load the .env file
load_dotenv()

# Set the path to ffmpeg from .env file
ffmpeg_path = os.getenv('FFMPEG_PATH')
os.environ["PATH"] += os.pathsep + ffmpeg_path
AudioSegment.converter = os.path.join(ffmpeg_path, 'ffmpeg.exe')
AudioSegment.ffmpeg = os.path.join(ffmpeg_path, 'ffmpeg.exe')
AudioSegment.ffprobe = os.path.join(ffmpeg_path, 'ffprobe.exe')

TESTING = False
settings = load_settings()
coin_icon = settings['coin_icon']

class GeneralCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    
    @commands.command(name='gift')
    async def gift(self, ctx, recipient: discord.Member, amount: int, *, reason: str):
        if amount <= 0:
            await ctx.send("Gift amount must be positive.")
            return

        if ctx.author == recipient:
            await ctx.send(f"You cannot gift {coin_icon} to yourself.")
            return

        activity_tracker = self.bot.get_cog('ActivityTracker')
        success, message = activity_tracker.transfer_coins(ctx.author, recipient, amount)
        
        if success:
            await ctx.send(f"{ctx.author.mention} gifted {amount} {coin_icon} to {recipient.mention} for: {reason}")
        else:
            await ctx.send(f"Failed to gift {coin_icon}: {message}")

    @commands.command(name='forbeslist')
    async def forbeslist(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        all_data = activity_tracker.activity_data

        # Convert data to a list of tuples and sort by coins
        coin_list = [(user_id, data['coins']) for user_id, data in all_data.items() if 'coins' in data]
        sorted_coin_list = sorted(coin_list, key=lambda x: x[1], reverse=True)[:10]

        # Create DataFrame
        data = {
            "Rank": list(range(1, len(sorted_coin_list) + 1)),
            "Player Name": [self.bot.get_user(int(user_id)).display_name if self.bot.get_user(int(user_id)) else "Unknown User" for user_id, _ in sorted_coin_list],
            f"Coins": [coins for _, coins in sorted_coin_list]
        }
        df = pd.DataFrame(data)

        # Plot the table with a cleaner style
        fig, ax = plt.subplots(figsize=(5, 2))  # Adjusted figsize for better appearance
        ax.axis('tight')
        ax.axis('off')

        # Create table
        table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center', edges='horizontal')
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 1.2)  # Scale up the table for better readability

        # Customize header row
        for key, cell in table.get_celld().items():
            cell.set_edgecolor('black')
            cell.set_linewidth(1)
            if key[0] == 0:
                cell.set_text_props(weight='bold', color='black') # This should work for the background color

        # Save the table as an image
        image_path = 'utils/images/forbes_list.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)

        # Send the image in Discord
        file = discord.File(image_path, filename='forbes_list.png')
        embed = discord.Embed(title="Forbes List")
        embed.set_image(url="attachment://forbes_list.png")
        await ctx.send(embed=embed, file=file)

        # Clean up the saved image file
        os.remove(image_path)

    @commands.command(name='leaderboard')
    async def leaderboard(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        all_data = activity_tracker.activity_data

        # Convert data to a list of tuples and sort by points
        leaderboard_list = [
            (user_id, data.get('level', 0), data.get('points', 0), data.get('coins', 0))
            for user_id, data in all_data.items()
        ]
        sorted_leaderboard_list = sorted(leaderboard_list, key=lambda x: x[2], reverse=True)[:10]  # Sort by points

        # Create DataFrame
        data = {
            "Rank": list(range(1, len(sorted_leaderboard_list) + 1)),
            "Player Name": [
                self.bot.get_user(int(user_id)).display_name if self.bot.get_user(int(user_id)) else "Unknown User"
                for user_id, _, _, _ in sorted_leaderboard_list
            ],
            "Level": [level for _, level, _, _ in sorted_leaderboard_list],
            "Points": [points for _, _, points, _ in sorted_leaderboard_list],
            "Coins": [coins for _, _, _, coins in sorted_leaderboard_list]
        }
        df = pd.DataFrame(data)

        # Plot the table with a cleaner style
        fig, ax = plt.subplots(figsize=(6, 3))  # Adjusted figsize for better appearance
        ax.axis('tight')
        ax.axis('off')

        # Create table
        table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center', edges='horizontal')
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 1.2)  # Scale up the table for better readability

        # Customize header row
        for key, cell in table.get_celld().items():
            cell.set_edgecolor('black')
            cell.set_linewidth(1)
            if key[0] == 0:
                cell.set_text_props(weight='bold', color='black')  # Bold headers

        # Save the table as an image
        image_path = 'utils/images/leaderboard.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)

        # Send the image in Discord
        file = discord.File(image_path, filename='leaderboard.png')
        embed = discord.Embed(title="Leaderboard")
        embed.set_image(url="attachment://leaderboard.png")
        await ctx.send(embed=embed, file=file)

        # Clean up the saved image file
        os.remove(image_path)

    @commands.command(name='update_notes')
    async def update_notes(self, ctx, *, notes):
        try:
            # Determine if the bot is online or offline
            online_status = True  # Replace with your logic to determine the status

            script_path = os.path.join('bot', 'status', 'online.py' if online_status else 'offline.py')

            # Run the update_additional_notes method in the respective script
            process = subprocess.run([sys.executable, script_path, notes], capture_output=True, text=True)

            if process.returncode == 0:
                print("Successful Notes Change")
            else:
                await ctx.send(f"Failed to update additional notes. Error: {process.stderr}")
        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    @commands.command(name='daily')
    async def daily(self, ctx):
        user_id = str(ctx.author.id)
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})

        if ctx.message.content.strip() != '!daily':
            return

        if TESTING:
            last_daily = None
        else:
            last_daily = user_data.get('last_daily', None)

        now = datetime.utcnow()

        if last_daily:
            last_daily_time = datetime.strptime(last_daily, "%Y-%m-%d %H:%M:%S")
            if now < last_daily_time + timedelta(hours = 24):
                next_claim_time = last_daily_time + timedelta(hours = 24)
                est = pytz.timezone('US/Eastern')
                next_claim_time_est = next_claim_time.replace(tzinfo=pytz.utc).astimezone(est)
                next_claim_time_str = next_claim_time_est.strftime('%Y-%m-%d %I:%M:%S %p')
                await ctx.send(f"You have already claimed your daily {coin_icon}.  NEXT CLAIM TIME: {next_claim_time_str} EST.")
                return
            
        daily_coins = random.randint(0, 10000)
        digits = str(daily_coins)

        await ctx.send(f"{ctx.author.mention}, generating your daily coins...")
        
        accumulated_digits = ""
        for digit in digits:
            accumulated_digits += digit
            await ctx.send(f"{accumulated_digits}")
            await asyncio.sleep(0.5)

        activity_tracker.update_user_coins(ctx.author, daily_coins)
        activity_tracker.activity_data[user_id]['last_daily'] = now.strftime('%Y-%m-%d %H:%M:%S')
        activity_tracker.save_activity_data()

        await ctx.send(f"You have been rewarded {daily_coins} {coin_icon} for the day!  Your balance is now {activity_tracker.activity_data[user_id]['coins']} {coin_icon}.")

    @commands.command(name='coinbalance')
    async def coinbalance(self, ctx, mentioned_user: discord.Member = None):
        if mentioned_user:
            user_id = str(mentioned_user.id)
            user_name = mentioned_user.display_name
        else:
            mentioned_user = ctx.author
            user_id = str(ctx.author.id)
            user_name = ctx.author.display_name

        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})
        coins = user_data.get('coins', 0)
        coin_icon = load_settings()['coin_icon']

        if mentioned_user == ctx.author:
            await ctx.send(f"{ctx.author.mention}, you have {coins} {coin_icon} in your account.")
        else:
            await ctx.send(f"{ctx.author.mention}, {user_name} has {coins} {coin_icon} in their account.")

    @commands.command(name='fredtalk')
    async def fredtalk(self, ctx, *, message: str = None):
        if ctx.author.voice and ctx.author.voice.channel:
            voice_channel = ctx.author.voice.channel
            vc = await voice_channel.connect()

            user_nicknames = [member.display_name for member in voice_channel.members if member.display_name != "Fred"]

            if message:
                tts_message = message
            else:
                if len(user_nicknames) == 1:
                    tts_message = f"Hello {user_nicknames[0]}"
                else:
                    tts_message = " ".join([f"Hello {name}" for name in user_nicknames])

            tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts.mp3')
            tts = gTTS(tts_message, lang='en', tld='co.in')
            tts.save(tts_file_path)

            # Load the TTS file with pydub
            sound = AudioSegment.from_file(tts_file_path)

            # Deepen the pitch (lowering by 4 semitones)
            new_sound = sound._spawn(sound.raw_data, overrides={
                "frame_rate": int(sound.frame_rate * 0.7)
            }).set_frame_rate(sound.frame_rate)

            # Save the new sound
            new_tts_file_path = os.path.join('utils', 'sounds', 'bottalking', 'tts_deep.mp3')
            new_sound.export(new_tts_file_path, format="mp3")

            vc.play(discord.FFmpegPCMAudio(source=new_tts_file_path))

            while vc.is_playing():
                await asyncio.sleep(1)

            await vc.disconnect()

            # Delete the TTS files after 10 seconds
            await asyncio.sleep(5)
            if os.path.exists(tts_file_path):
                os.remove(tts_file_path)
            if os.path.exists(new_tts_file_path):
                os.remove(new_tts_file_path)
        else:
            await ctx.send("You aren't in a voice chat.")

class LevelUIView(View):
    def __init__(self, username, avatar_url, points, current_level, next_level, progress_percentage, remaining_points):
        super().__init__(timeout=60)
        self.username = username
        self.avatar_url = avatar_url
        self.points = points
        self.current_level = current_level
        self.next_level = next_level
        self.progress_percentage = progress_percentage
        self.remaining_points = remaining_points

class LevelUI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='level')
    async def level(self, ctx, member: discord.Member = None):
        if member is None:
            member = ctx.author

        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_stats = activity_tracker.get_statistics(str(member.id))
        if not user_stats:
            await ctx.send("No statistics available for this user.")
            return

        username = member.display_name
        avatar_url = member.avatar.url
        points = user_stats.get("points", 0)
        current_level, remaining_points = get_current_level(points)
        next_level = current_level + 1
        progress_percentage = (points - points_for_next_level(current_level - 1)) / remaining_points * 100

        image_buffer = generate_level_image(username, current_level, progress_percentage, points, next_level, avatar_url)
    
        if image_buffer:
            file = discord.File(image_buffer, filename="level_image.png")
            embed = discord.Embed(title="Level Information", color=discord.Color.orange())
            embed.set_image(url="attachment://level_image.png")

            await ctx.send(embed=embed, file=file)
        else:
            await ctx.send("An error occurred while generating the level image.")

    @commands.command(name='leaderboard_today')
    async def leaderboard_today(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = {user_id: data for user_id, data in activity_tracker.activity_data.items()}
        sorted_stats = sorted(stats.items(), key=lambda x: x[1].get('points_today', 0), reverse=True)[:20]

        df = pd.DataFrame(columns=["Rank", "Username", "Points Today"])
        for idx, (user_id, data) in enumerate(sorted_stats, start=1):
            member = ctx.guild.get_member(int(user_id))
            if member:
                df = pd.concat([df, pd.DataFrame({"Rank": [idx], "Username": [member.display_name], "Points Today": [data.get('points_today', 0)]})], ignore_index=True)

        table_str = df.to_markdown(index=False)
        embed = discord.Embed(title="Today's Leaderboard", color=discord.Color.green())
        embed.add_field(name="Top 20 Users", value=f"```\n{table_str}\n```", inline=False)

        await ctx.send(embed=embed)

    @commands.command(name='statistics')
    async def statistics(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            embed = discord.Embed(title="Statistics", color=discord.Color.purple())
            embed.add_field(name="Username", value=member.display_name, inline=True)
            embed.add_field(name="Total Points", value=stats.get('points', 0), inline=True)
            embed.add_field(name="Level", value=stats.get('level', 1), inline=True)
            embed.add_field(name="XP to Next Level", value=stats.get('xp_to_next_level', 0), inline=True)
            embed.add_field(name="Minutes in Voice", value=stats.get('minutes_in_voice', 0), inline=True)
            embed.add_field(name="Minutes Online", value=stats.get('minutes_online', 0), inline=True)
            embed.add_field(name="Messages Sent", value=stats.get('messages_sent', 0), inline=True)
            embed.add_field(name="Characters Typed", value=stats.get('characters_typed', 0), inline=True)
            embed.add_field(name="Points Today", value=stats.get('points_today', 0), inline=True)

            # Add coin information
            coins = stats.get('coins', 0)
            coin_icon_url = "https://cdn4.iconfinder.com/data/icons/coins-virtual-currency/104/Guarani-256.png"
            embed.add_field(name=f"\u200b", value=f"[![coins]({coin_icon_url})]({coin_icon_url}) **{coins}**", inline=False)

            await ctx.send(embed=embed)
        else:
            await ctx.send("No statistics available for this user.")

    @commands.command(name='statistics_visualization')
    async def statistics_visualization(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            # Generate the visualization
            visualization_path = generate_statistics_visualization(stats)
            embed = discord.Embed(title="Statistics Visualization", color=discord.Color.purple())
            file = discord.File(visualization_path, filename="statistics_visualization.png")
            embed.set_image(url=f"attachment://statistics_visualization.png")
            await member.send(embed=embed, file=file)
        else:
            await ctx.send("No statistics available for this user.")

    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        if isinstance(error, commands.CommandNotFound):
            botlog_channel = discord.utils.get(ctx.guild.channels, name='botlog')
            if botlog_channel:
                await botlog_channel.send("Invalid Command Called.")
        else:
            raise error
        
class Music(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.current_player = None
        self.voice_channel = None
        self.votes_to_skip = set()
        self.song_queue = asyncio.Queue()
        self.playing_song = None
        self.current_volume = 0.2

    @commands.command(name='play')
    async def play(self, ctx, url):
        user = ctx.author
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.get_statistics(str(user.id))
        user_coins = user_data.get('coins', 0)
        settings = load_settings()
        coin_icon = settings['coin_icon']

        try:
            video_info = await self.get_video_info(url)
            video_length = video_info['duration']  # Duration in seconds
            video_title = video_info['title']
            cost = video_length * 4

            if user_coins < cost:
                await ctx.send(f"{user.mention}, the cost is {cost} {coin_icon}, but you do not have enough {coin_icon}.")
                return

            await ctx.send(f"{user.mention}, the cost to play '{video_title}' is {cost} {coin_icon}. Type `!accept` to proceed.")
            
            def check(m):
                return m.author == user and m.content.lower() == '!accept'
            
            try:
                await self.bot.wait_for('message', check=check, timeout=30.0)
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond!")
                return

            activity_tracker.update_user_activity(user, coins=-cost)
            await ctx.send(f"{user.mention} has paid {cost} {coin_icon} to play '{video_title}'.")

            self.voice_channel = ctx.author.voice.channel
            if not self.voice_channel:
                await ctx.send("You are not connected to a voice channel.")
                return

            audio_file = await self.download_audio(url, video_title)
            await self.song_queue.put((ctx, audio_file, video_title, user))
            if not self.current_player:
                await self.play_next_song()

        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    async def play_next_song(self):
        if not self.song_queue.empty():
            ctx, audio_file, video_title, user = await self.song_queue.get()
            self.voice_channel = ctx.author.voice.channel
            voice = await self.voice_channel.connect()

            source = discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(audio_file), volume=self.current_volume)
            self.current_player = voice.play(source, after=lambda e: self.bot.loop.create_task(self.play_next_song()))

            self.playing_song = (ctx, video_title, user)
            await ctx.send(f"Now playing: '{video_title}'")

            while voice.is_playing():
                await asyncio.sleep(1)
            await voice.disconnect()
            os.remove(audio_file)
            await ctx.send(f"Finished playing: '{video_title}' and removed the file from the system.")
            self.playing_song = None
            self.current_player = None

    @commands.command(name='skip')
    async def skip(self, ctx):
        if not self.current_player:
            await ctx.send("No audio is currently playing.")
            return

        user = ctx.author
        if user == self.playing_song[2]:  # The user who requested the song
            self.current_player.source.cleanup()
            self.current_player.stop()
            await ctx.send(f"{user.mention} has skipped their own song.")
            self.votes_to_skip.clear()
        else:
            if user not in self.voice_channel.members:
                await ctx.send("You must be in the voice channel to vote to skip.")
                return

            self.votes_to_skip.add(user)
            total_members = len(self.voice_channel.members)
            if len(self.votes_to_skip) / total_members >= 0.5:
                self.current_player.source.cleanup()
                self.current_player.stop()
                await ctx.send("Vote passed! Skipping the current song.")
                self.votes_to_skip.clear()
            else:
                await ctx.send(f"{user.mention} has voted to skip. {len(self.votes_to_skip)}/{total_members} votes.")

    @commands.command(name='volume')
    async def volume(self, ctx, volume: float):
        user = ctx.author
        if user != self.playing_song[2]:
            await ctx.send(f"{user.mention}, only the song requester can change the volume.")
            return

        if volume < 0 or volume > 5:
            await ctx.send(f"{user.mention}, volume must be between 0 and 5.")
            return

        self.current_volume = volume * 0.1
        if self.current_player and self.current_player.source:
            self.current_player.source.volume = self.current_volume
        await ctx.send(f"{user.mention}, the volume has been set to {volume}.")

    async def get_video_info(self, url):
        ydl_opts = {
            'format': 'bestaudio/best',
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
            }
        }
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
        return {
            'duration': info['duration'],
            'title': info['title']
        }

    async def download_audio(self, url, title):
        ydl_opts = {
            'format': 'bestaudio/best',
            'outtmpl': f'utils/sounds/musicdump/{title}.%(ext)s',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }],
            'ffmpeg_location': os.getenv('FFMPEG_PATH'),
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
            }
        }
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url)
            filename = ydl.prepare_filename(info)
            mp3_filename = filename.replace('.webm', '.mp3')
        
        return mp3_filename

async def setup(bot):
    await bot.add_cog(GeneralCommands(bot))
    await bot.add_cog(LevelUI(bot))
    await bot.add_cog(Music(bot))



.\bot\level_widget.py
import discord
from discord.ext import commands

class LevelWidget(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        print("LevelWidget initialized")

async def setup(bot):
    print("Setting up LevelWidget")
    await bot.add_cog(LevelWidget(bot))
    print("LevelWidget added to bot")


.\bot\shop.py
# bot/shop.py
import discord
from discord.ext import commands
from discord.ui import View, Button
import os

class PaginatedShopView(View):
    def __init__(self, items, per_page=5):
        super().__init__(timeout=60)
        self.items = items
        self.per_page = per_page
        self.current_page = 0
        self.add_item(Button(label="Previous", style=discord.ButtonStyle.secondary, custom_id="previous_page"))
        self.add_item(Button(label="Next", style=discord.ButtonStyle.secondary, custom_id="next_page"))

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user == self.message.author

    @discord.ui.button(label='Previous', style=discord.ButtonStyle.secondary)
    async def previous_page(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.current_page -= 1
        await self.update_embed(interaction)

    @discord.ui.button(label='Next', style=discord.ButtonStyle.secondary)
    async def next_page(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.current_page += 1
        await self.update_embed(interaction)

    async def update_embed(self, interaction: discord.Interaction):
        start = self.current_page * self.per_page
        end = start + self.per_page
        items = self.items[start:end]
        
        embed = discord.Embed(
            title="Casino Shop",
            description="Welcome to the Casino Shop! Here are some items you can purchase:",
            color=discord.Color.blue()
        )
        
        for item in items:
            embed.add_field(name=item['name'], value=f"{item['description']} - {item['price']} {item['icon']}", inline=False)
        
        await interaction.response.edit_message(embed=embed, view=self)

class Shop(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='shop')
    async def shop(self, ctx):
        items = [
            {'name': 'Virtual Pet', 'description': 'A cute virtual pet.', 'price': 100, 'icon': "<:coin:>"},
            {'name': 'Badge', 'description': 'A collectible badge.', 'price': 50, 'icon': "<:coin:>"},
            {'name': 'Game Tokens', 'description': 'Tokens for playing games.', 'price': 20, 'icon': "<:coin:>"}
        ]
        view = PaginatedShopView(items)
        await ctx.send(embed=view.create_embed(), view=view)


async def setup(bot):
    await bot.add_cog(Shop(bot))


.\bot\__init__.py


.\bot\games\blackjack.py
import random, os, discord, asyncio, json
from PIL import Image
from discord.ext import commands
from settings.settings import load_settings

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

CARD_VALUES = game_settings['blackjack']['card_values']  # Dictionary of card values
SUITS = game_settings['blackjack']['suits']  # List of suits
DECK = [f'{value}_of_{suit}' for suit in SUITS for value in CARD_VALUES.keys()]  # List of all cards in the deck
DECK_IMAGES_FOLDER = 'utils/images/deckofcards'
DUMP_IMAGES_FOLDER = 'utils/images/blackjackdump'

BLACKJACK_WIN_POINTS = 100
BLACKJACK_LOSS_POINTS = 20
BLACKJACK_PUSH_POINTS = 45

class BlackjackGame:
    def __init__(self, player, bot):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        self.player = player
        self.bot = bot
        self.player_hand = []
        self.dealer_hand = []
        self.player_points = 0
        self.dealer_points = 0
        self.bet = 0

    async def deal_initial_cards(self):
        self.player_hand = [self.deck.pop(), self.deck.pop()]
        self.dealer_hand = [self.deck.pop(), self.deck.pop()]
        self.player_points = self.calculate_hand_value(self.player_hand)
        self.dealer_points = self.calculate_hand_value(self.dealer_hand)

    def calculate_hand_value(self, hand):
        value = 0
        aces = 0
        for card in hand:
            card_value = card[:-1]  # Get the card value without the suit
            if card_value.isdigit():
                value += int(card_value)
            elif card_value in ['J', 'Q', 'K']:
                value += 10
            else:
                value += 11
                aces += 1
        while value > 21 and aces:
            value -= 10
            aces -= 1
        return value

    async def start_game(self, bet):
        self.bet = bet
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        await self.deal_initial_cards()

    async def player_hit(self):
        card = self.deck.pop()
        self.player_hand.append(card)
        self.player_points = self.calculate_hand_value(self.player_hand)
        return card

    async def dealer_play(self):
        while self.dealer_points < 17:
            card = self.deck.pop()
            self.dealer_hand.append(card)
            self.dealer_points = self.calculate_hand_value(self.dealer_hand)
        return self.dealer_hand

    def get_game_result(self):
        if self.player_points > 21:
            return "bust"
        elif self.dealer_points > 21 or self.player_points > self.dealer_points:
            return "win"
        elif self.player_points == self.dealer_points:
            return "push"
        else:
            return "lose"

    async def create_hand_image(self, hand, reveal_dealer=False):
        card_images = []
        for card in hand:
            if isinstance(card, dict) and card.get('value') == 'back':
                card_image_path = os.path.join(DECK_IMAGES_FOLDER, 'back.png')
            else:
                card_value = card[:-1]  # Extract the value part of the card string
                card_suit = card[-1].upper()  # Extract the suit part of the card string
                if card_value == '10':  # Check for '10' separately
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, '10', f'10{card_suit}.png')
                else:
                    card_value = card_value[0].upper()
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, card_value, f'{card_value}{card_suit}.png')
            card_images.append(card_image_path)
        return card_images

    async def concatenate_images(self, image_paths, filename):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        total_width = sum(widths)
        max_height = max(heights)
        new_image = Image.new('RGB', (total_width, max_height))

        x_offset = 0
        for img in images:
            new_image.paste(img, (x_offset, 0))
            x_offset += img.size[0]

        output_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path

    async def hit(self, ctx):
        card = await self.player_hit()
        await self.send_hand(ctx)

        if self.player_points > 21:
            await self.end_game(ctx, "bust")

    async def stand(self, ctx):
        dealer_hand = await self.dealer_play()
        await self.send_hand(ctx, reveal_dealer=True)

        result = self.get_game_result()
        await self.end_game(ctx, result)

    async def end_game(self, ctx, result):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if result == "win":
            payout = self.bet * 2
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_WIN_POINTS, coins=payout)
            await ctx.send(f"Congratulations {ctx.author.mention}, you win! You have been awarded {BLACKJACK_WIN_POINTS} points and {payout} {coin_icon}.")
        elif result == "bust":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_LOSS_POINTS)
            await ctx.send(f"Sorry {ctx.author.mention}, you busted! You lost {self.bet} {coin_icon}.")
        elif result == "lose":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_LOSS_POINTS)
            await ctx.send(f"Sorry {ctx.author.mention}, you lose! You lost {self.bet} {coin_icon}.")
        elif result == "push":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_PUSH_POINTS, coins=self.bet)
            await ctx.send(f"It's a push, {ctx.author.mention}. Your bet of {self.bet} {coin_icon} has been returned.")

        await self.cleanup_images()
        del self.bot.get_cog('CommandHandler').blackjack_games[ctx.author.id]

    async def send_hand(self, ctx, reveal_dealer=False):
        player_images = await self.create_hand_image(self.player_hand)
        dealer_hand = self.dealer_hand if reveal_dealer else self.dealer_hand[:1] + [{'value': 'back', 'suit': ''}]
        dealer_images = await self.create_hand_image(dealer_hand)

        concatenated_player_image = await self.concatenate_images(player_images, f'blackjack_{ctx.author.id}_player_hand.png')
        concatenated_dealer_image = await self.concatenate_images(dealer_images, f'blackjack_{ctx.author.id}_dealer_hand.png')

        player_hand_embed = discord.File(concatenated_player_image, filename="player_hand.png")
        dealer_hand_embed = discord.File(concatenated_dealer_image, filename="dealer_hand.png")

        embed = discord.Embed(title="Blackjack")
        embed.add_field(name="Your Hand", value=f"Points: {self.player_points}", inline=True)
        embed.add_field(name="Dealer's Hand", value=f"Points: {self.dealer_points if reveal_dealer else '?'}", inline=True)
        embed.set_image(url=f"attachment://player_hand.png")
        embed.set_thumbnail(url=f"attachment://dealer_hand.png")

        await ctx.send(embed=embed, files=[player_hand_embed, dealer_hand_embed])

    async def cleanup_images(self):
        for filename in os.listdir(DUMP_IMAGES_FOLDER):
            file_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
            if os.path.isfile(file_path):
                os.unlink(file_path)

.\bot\games\dealerpoker.py
import discord, random, os, asyncio, json, asyncio, itertools
from discord.ext import commands
from PIL import Image, ImageDraw, ImageFont
from settings.settings import load_settings

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

# Poker Settings
POKER_WIN_POINTS = 120


class DealerPoker:
    def __init__(self, ctx, bot):
        self.bot = bot
        self.ctx = ctx
        self.player = ctx.author
        self.dealer_hand = []
        self.player_hands = {}
        self.community_cards = []
        self.DECK_OF_CARDS_FOLDER = 'utils/images/deckofcards'
        self.DUMP_IMAGES_FOLDER = 'utils/images/pokerdump'
        self.game_cancelled = False
        self.player_bet = 0
        self.ante = 0
        self.player_balance = 0

    async def start_game(self):
        await self.ask_for_ante()
        if self.game_cancelled:
            return
        
        await self.deal_initial_cards()
        await self.betting_round(pre_flop = True)
        await self.reveal_community_cards(3)
        await self.betting_round()
        await self.reveal_community_cards(1)
        await self.betting_round()
        await self.reveal_community_cards(1)
        await self.betting_round(final = True)
        await self.showdown()
        await self.cleanup()

    async def ask_for_ante(self):
        await self.ctx.send(f"{self.ctx.author.mention}, how many {coin_icon} would you like to ante?")

        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel
        
        try:
            msg = await self.bot.wait_for('message', check=check, timeout=120)
            self.ante = int(msg.content)
            activity_tracker = self.bot.get_cog('ActivityTracker')
            user_data = activity_tracker.get_statistics(str(self.player.id))
            player_coins = user_data.get('coins', 0)

            if player_coins < self.ante:
                await self.ctx.send(f"{self.ctx.author.mention}, you do not have enough {coin_icon} to ante that amount.")
                self.game_cancelled = True
                return
            
            activity_tracker.update_user_activity(self.ctx.author, coins=-(self.ante))
            self.player_balance = self.ante
            self.player_hands[self.ctx.author] = []
            await self.ctx.send(f"{self.ctx.author.mention}, you have anted {self.ante} {coin_icon}.  Starting Dealer Poker..")
        except asyncio.TimeoutError:
            await self.ctx.send(f"{self.ctx.author.mention} took too long to respond.  Game has been cancelled without refund.")
            self.game_cancelled = True
        except ValueError:
            await self.ctx.send(f"{msg.content} is not a valid number.  Game cancelled.")
            self.game_cancelled = True

    async def deal_initial_cards(self):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)

        self.player_hands[self.player] = [self.deck.pop(), self.deck.pop()]
        await self.send_hand(self.ctx, self.player)

        self.dealer_hand = [self.deck.pop(), self.deck.pop()]

    async def betting_round(self, pre_flop=False, final=False):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.get_statistics(str(self.player.id))
        player_total_coins = int(user_data.get('coins', 0))

        max_bet = int(4 * self.ante if pre_flop else 1.5 * self.ante if final else 2 * self.ante)
        action_message = "you can `!check` or place a `!bet`" if not final else "you can `!fold` or place a `!bet`"
        await self.ctx.send(f"{self.ctx.author.mention}, {action_message} of {max_bet} {coin_icon}. Your current balance is {player_total_coins} {coin_icon}.")

        def check(m):
            return m.author == self.ctx.author and m.channel == self.ctx.channel

        try:
            while True:
                msg = await self.bot.wait_for('message', check=check, timeout=120)
                content = msg.content.lower().split()
                
                if content[0] == '!check' and not final:
                    await self.ctx.send(f"{self.ctx.author.mention} checks.")
                    break  # Exit the loop as a valid action was taken

                elif content[0] == '!bet':
                    try:
                        bet_amount = max_bet if len(content) == 1 else int(content[1])

                        if bet_amount < 1 or bet_amount > max_bet:
                            await self.ctx.send(f"{self.ctx.author.mention}, invalid bet amount. Please bet up to {max_bet} {coin_icon}.")
                        elif bet_amount > player_total_coins:
                            await self.ctx.send(f"{self.ctx.author.mention}, you do not have enough balance to place this bet.")
                        else:
                            self.player_bet += bet_amount
                            player_total_coins -= bet_amount
                            activity_tracker.update_user_activity(self.ctx.author, coins=-bet_amount)
                            await self.ctx.send(f"{self.ctx.author.mention} places a bet of {bet_amount} {coin_icon}. Total bet: {self.player_bet} {coin_icon}. Current balance: {player_total_coins} {coin_icon}.")
                            break  # Exit the loop as a valid action was taken
                    except ValueError:
                        await self.ctx.send(f"{self.ctx.author.mention}, please enter a valid bet amount.")

                elif content[0] == '!fold' and final:
                    await self.ctx.send(f"{self.ctx.author.mention} folds. Game over.")
                    self.game_cancelled = True
                    return

                else:
                    await self.ctx.send("Invalid action. Please try again.")
        except asyncio.TimeoutError:
            await self.ctx.send(f"{self.ctx.author.mention} took too long to respond. Game over.")
            self.game_cancelled = True

    def get_max_bet(self, pre_flop, final):
        if pre_flop:
            return 4 * self.ante
        elif final:
            return 1 * self.ante
        return 2 * self.ante

    async def reveal_community_cards(self, num):
        for _ in range(num):
            self.deck.pop()  # Burn card
            self.community_cards.append(self.deck.pop())

        await self.display_community_cards()

    async def display_community_cards(self):
        cards = [await self.get_card_image(card) for card in self.community_cards]
        concatenated_image_path = await self.concatenate_images(cards, 'community_cards.png')
        file = discord.File(concatenated_image_path, filename="community_cards.png")

        embed = discord.Embed(title="Community Cards")
        embed.set_image(url="attachment://community_cards.png")
        await self.ctx.send(file=file, embed=embed)

    async def showdown(self):
        player_hand = self.player_hands[self.ctx.author]
        dealer_hand = self.dealer_hand
        player_best_hand = self.get_best_hand(player_hand + self.community_cards)
        dealer_best_hand = self.get_best_hand(dealer_hand + self.community_cards)

        player_rank = self.hand_rank(player_best_hand)
        dealer_rank = self.hand_rank(dealer_best_hand)
        if player_rank > dealer_rank:
            result = f"{self.ctx.author.mention} wins with {self.rank_description(player_rank)}!"
        elif player_rank < dealer_rank:
            result = f"The dealer wins with {self.rank_description(dealer_rank)}. Better luck next time!"
        else:
            result = "It's a tie!"

        # Create images for the showdown
        player_hand_image = await self.get_hand_image(player_hand)
        dealer_hand_image = await self.get_hand_image(dealer_hand)
        community_cards_image = await self.get_hand_image(self.community_cards)

        # Concatenate all parts into one image
        final_showdown_image = await self.concatenate_images([player_hand_image, community_cards_image, dealer_hand_image], 'final_showdown.png')

        # Send the result with the final image
        file = discord.File(final_showdown_image, filename="final_showdown.png")
        embed = discord.Embed(title="Final Showdown", description=result)
        embed.set_image(url="attachment://final_showdown.png")
        await self.ctx.send(file=file, embed=embed)

        # Clean up images
        for img_path in [player_hand_image, dealer_hand_image, community_cards_image, final_showdown_image]:
            os.remove(img_path)

    async def display_final_hands(self, player_hand, dealer_hand):
        player_hand_images = [await self.get_card_image(card) for card in player_hand]
        dealer_hand_images = [await self.get_card_image(card) for card in dealer_hand]

        # Create a combined image of the player and dealer hands
        player_hand_image = await self.concatenate_images(player_hand_images, 'player_final_hand.png')
        dealer_hand_image = await self.concatenate_images(dealer_hand_images, 'dealer_final_hand.png')

        embed = discord.Embed(title="Final Hands")
        embed.set_image(url="attachment://player_final_hand.png")
        player_file = discord.File(player_hand_image, filename="player_final_hand.png")
        dealer_file = discord.File(dealer_hand_image, filename="dealer_final_hand.png")

        msg = await self.ctx.send(file=player_file, embed=embed)

        # Wait and reveal the dealer's hand
        await asyncio.sleep(2)
        embed.set_image(url="attachment://dealer_final_hand.png")
        await msg.edit(embed=embed)
        await self.ctx.send(file=dealer_file)

    def rank_description(self, rank):
        descriptions = [
            "High Card", 
            "One Pair", 
            "Two Pair", 
            "Three of a Kind", 
            "Straight", 
            "Flush", 
            "Full House", 
            "Four of a Kind", 
            "Straight Flush", 
            "Royal Flush"
        ]
        return descriptions[rank[0]]

    async def get_hand_image(self, hand):
        cards = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(cards, 'showdown_hand.png')
        return concatenated_image_path

    async def send_hand(self, ctx, player, reveal=False, dealer=False):
        hand = self.player_hands[player] if not dealer else self.dealer_hand
        card_images = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(card_images, f'poker_{player.id}_hand.png')
        file = discord.File(concatenated_image_path, filename="hand.png")

        title = f"{player.display_name}'s Hand" if not dealer else "Dealer's Hand"
        embed = discord.Embed(title=title)
        embed.set_image(url="attachment://hand.png")
        await ctx.send(file=file, embed=embed)

    async def get_card_image(self, card):
        card_value = card[:-1]
        card_suit = card[-1].upper()
        if card_value == '10':
            card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, '10', f'10{card_suit}.png')
        else:
            card_value = card_value[0].upper()
            card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, card_value, f'{card_value}{card_suit}.png')
        return card_image_path

    async def concatenate_images(self, image_paths, filename, vertical=False):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        
        if vertical:
            total_width = max(widths)
            total_height = sum(heights)
        else:
            total_width = sum(widths)
            total_height = max(heights)

        new_image = Image.new('RGB', (total_width, total_height))

        x_offset, y_offset = 0, 0
        for img in images:
            if vertical:
                new_image.paste(img, (0, y_offset))
                y_offset += img.size[1]
            else:
                new_image.paste(img, (x_offset, 0))
                x_offset += img.size[0]

        output_path = os.path.join(self.DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path


    def hand_rank(self, hand):
        # Define ranks and handle '10' separately
        ranks = '23456789JQKA'
        values = {r: i for i, r in enumerate(ranks, start=2)}
        values['10'] = 10  # Explicitly add '10' to the values

        # Extract ranks and suits from hand
        hand_ranks = sorted([values[card[:-1]] for card in hand], reverse=True)
        suits = [card[-1] for card in hand]

        # Check for flush
        is_flush = len(set(suits)) == 1
        flush_ranks = [values[card[:-1]] for card in hand if card[-1] == suits[0]]
        flush_ranks.sort(reverse=True)

        # Check for straight within the flush cards
        is_straight_flush = len(set(flush_ranks)) == 5 and (flush_ranks[0] - flush_ranks[-1] == 4)

        # Special case: Ace can be low in a straight (A-2-3-4-5)
        if set(flush_ranks) == {14, 5, 4, 3, 2}:
            is_straight_flush = True
            flush_ranks = [5, 4, 3, 2, 1]

        # Check for Royal Flush
        if is_straight_flush and flush_ranks == [14, 13, 12, 11, 10]:
            return (9, flush_ranks)  # Royal Flush

        # Check for Straight Flush
        if is_straight_flush:
            return (8, flush_ranks)  # Straight Flush

        # Check for normal Straight
        is_straight = len(set(hand_ranks)) == 5 and (hand_ranks[0] - hand_ranks[-1] == 4)
        if set(hand_ranks) == {14, 5, 4, 3, 2}:
            is_straight = True
            hand_ranks = [5, 4, 3, 2, 1]

        # Other rankings
        rank_counter = {r: hand_ranks.count(r) for r in hand_ranks}
        rank_values = sorted(((count, rank) for rank, count in rank_counter.items()), reverse=True)

        # Four of a kind
        if rank_values[0][0] == 4:
            return (7, rank_values[0][1], rank_values[1][1])

        # Full house
        if rank_values[0][0] == 3 and rank_values[1][0] == 2:
            return (6, rank_values[0][1], rank_values[1][1])

        # Flush (not a straight flush)
        if is_flush:
            return (5, flush_ranks)

        # Straight (not a straight flush)
        if is_straight:
            return (4, hand_ranks)

        # Three of a kind
        if rank_values[0][0] == 3:
            return (3, rank_values[0][1], hand_ranks)

        # Two pair
        if rank_values[0][0] == 2 and rank_values[1][0] == 2:
            return (2, rank_values[0][1], rank_values[1][1], hand_ranks)

        # One pair
        if rank_values[0][0] == 2:
            return (1, rank_values[0][1], hand_ranks)

        # High card
        return (0, hand_ranks)

    def get_best_hand(self, hand):
        all_combinations = itertools.combinations(hand, 5)
        best_hand = max(all_combinations, key=self.hand_rank)
        return best_hand

    async def reveal_hand(self, player, hand, dealer=False):
        cards = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(cards, f'poker_{player.id}_hand.png')
        file = discord.File(concatenated_image_path, filename="hand.png")

        title = f"{player.display_name}'s Hand" if not dealer else "Dealer's Hand"
        embed = discord.Embed(title=title)
        embed.set_image(url="attachment://hand.png")
        msg = await self.ctx.send(file=file, embed=embed)

        # Dramatic reveal of each card
        for i, card in enumerate(cards):
            await asyncio.sleep(1)  # Adding delay for dramatic effect
            if i < len(cards) - 1:
                await msg.edit(content=f"{player.display_name} reveals {card}.")
            else:
                await self.ctx.send(f"{player.display_name} reveals {card}.")

    async def create_final_showdown_image(self, player_hand, dealer_hand):
        # Get image paths for each hand and community cards
        player_hand_images = [await self.get_card_image(card) for card in player_hand]
        dealer_hand_images = [await self.get_card_image(card) for card in dealer_hand]
        community_cards_images = [await self.get_card_image(card) for card in self.community_cards]

        # Load all images
        player_imgs = [Image.open(img) for img in player_hand_images]
        dealer_imgs = [Image.open(img) for img in dealer_hand_images]
        community_imgs = [Image.open(img) for img in community_cards_images]

        # Determine maximum width and height for card images
        max_card_width = max(img.width for img in player_imgs + dealer_imgs + community_imgs)
        max_card_height = max(img.height for img in player_imgs + dealer_imgs + community_imgs)

        # Define spacing
        spacing = 10
        text_height = 30

        # Calculate total width and height
        total_width = max_card_width * max(len(player_imgs), len(dealer_imgs), len(community_imgs)) + spacing * 2
        total_height = max_card_height * 3 + text_height * 3 + spacing * 5

        # Create a new image
        combined_image = Image.new('RGB', (total_width, total_height), (255, 255, 255))
        draw = ImageDraw.Draw(combined_image)
        font = ImageFont.truetype("arial.ttf", 20)  # You may need to specify the path to a font file

        # Draw Player's Hand
        draw.text((spacing, spacing), "Player's Hand", font=font, fill="black")
        y_offset = spacing + text_height
        x_offset = spacing
        for img in player_imgs:
            combined_image.paste(img, (x_offset, y_offset))
            x_offset += img.width + spacing

        # Draw Community Cards
        draw.text((spacing, y_offset + max_card_height + spacing), "Community Cards", font=font, fill="black")
        y_offset += max_card_height + spacing + text_height
        x_offset = spacing
        for img in community_imgs:
            combined_image.paste(img, (x_offset, y_offset))
            x_offset += img.width + spacing

        # Draw Dealer's Hand
        draw.text((spacing, y_offset + max_card_height + spacing), "Dealer's Hand", font=font, fill="black")
        y_offset += max_card_height + spacing + text_height
        x_offset = spacing
        for img in dealer_imgs:
            combined_image.paste(img, (x_offset, y_offset))
            x_offset += img.width + spacing

        # Save the combined image
        final_image_path = os.path.join(self.DUMP_IMAGES_FOLDER, 'final_showdown.png')
        combined_image.save(final_image_path)

        return final_image_path


    async def cleanup(self):
        """Clean up temporary images and reset state if needed."""
        for filename in os.listdir(self.DUMP_IMAGES_FOLDER):
            file_path = os.path.join(self.DUMP_IMAGES_FOLDER, filename)
            try:
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            except Exception as e:
                print(f"Failed to delete {file_path}. Reason: {e}")

    def cleanup_image(self, image_path):
        """Remove the image file after it's used."""
        try:
            os.remove(image_path)
        except Exception as e:
            print(f"Error deleting image {image_path}: {e}")



.\bot\games\duel.py
import random, aiohttp, discord, json
from settings.settings import load_settings


# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

DUEL_WIN_POINTS = game_settings['duel']['win_points']  # Points awarded for winning a duel
DUEL_WIN_COINS = game_settings['duel']['win_coins']  # Coins awarded for winning a duel

settings = load_settings()
coin_icon = settings['coin_icon']

class Duel:
    def __init__(self, player1, player2):
        self.player1 = player1  # ID of player 1
        self.player2 = player2  # ID of player 2
        self.health = {player1: 100, player2: 100}  # Initial health for both players
        self.letter = None  # The current letter for the duel
        self.used_words = set()  # Set of words that have already been used

    def generate_letter(self):
        self.letter = random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')  # Generate a random letter

    async def is_valid_word(self, word):
        url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word.lower()}"  # URL to check if the word is valid
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                return resp.status == 200  # Return True if the word is valid

    def calculate_damage(self, words):
        valid_words = [word for word in words if word.lower().startswith(self.letter.lower()) and word.lower() not in self.used_words]
        self.used_words.update(word.lower() for word in valid_words)  # Add valid words to the set of used words
        return sum(len(word) for word in valid_words)  # Calculate damage as the sum of the lengths of valid words

    def get_winner(self):
        if self.health[self.player1] <= 0:
            return self.player2  # Player 2 wins if player 1's health is 0 or less
        elif self.health[self.player2] <= 0:
            return self.player1  # Player 1 wins if player 2's health is 0 or less
        return None  # No winner if both players have health above 0

    def adjust_health(self, player_id, damage):
        self.health[player_id] = max(self.health[player_id] - damage, 0)  # Reduce health by the damage amount, but not below 0

    async def handle_duel(self, ctx, duel):
        def check(m):
            return m.channel == ctx.channel and m.author.id in [duel.player1, duel.player2]

        while True:
            msg = await self.bot.wait_for('message', check=check)
            damage = await self.process_message(msg, duel)
            opponent_id = duel.player1 if msg.author.id == duel.player2 else duel.player2
            duel.adjust_health(opponent_id, damage)

            embed = discord.Embed(
                title="Duel Status",
                description=f"{self.bot.get_user(duel.player1).mention} vs {self.bot.get_user(duel.player2).mention}",
                color=discord.Color.red()
            )
            embed.add_field(name=f"{self.bot.get_user(duel.player1).display_name} HP", value=duel.health[duel.player1])
            embed.add_field(name=f"{self.bot.get_user(duel.player2).display_name} HP", value=duel.health[duel.player2])
            await ctx.send(embed=embed)

            winner_id = duel.get_winner()
            if winner_id:
                winner = self.bot.get_user(winner_id)
                await ctx.send(f"{winner.mention} wins the duel!")
                activity_tracker = self.bot.get_cog('ActivityTracker')
                activity_tracker.update_user_activity(winner, points=DUEL_WIN_POINTS, coins=DUEL_WIN_COINS)
                await ctx.send(f"{winner.mention} has been awarded {DUEL_WIN_POINTS} points and {DUEL_WIN_COINS} {coin_icon}! Total {coin_icon}: {activity_tracker.activity_data[str(winner.id)]['coins']}")
                
                del self.duels[duel.player1]
                del self.duels[duel.player2]
                return

    async def process_message(self, msg, duel):
        words = msg.content.split()
        valid_words = []
        for word in words:
            if await duel.is_valid_word(word):
                if word.lower() not in duel.used_words:
                    valid_words.append(word)
                else:
                    await msg.channel.send(f"The word '{word}' has already been used.")
            else:
                await msg.channel.send(f"The word '{word}' is not a valid word.")
        return duel.calculate_damage(valid_words)


.\bot\games\game_manager.py
import discord, asyncio, json, logging
from discord.ext import commands
from .duel import Duel
from .blackjack import BlackjackGame
from .lottery import Lottery
from .dealerpoker import DealerPoker
from settings.settings import load_settings

logging.basicConfig(level=logging.INFO)

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

BOT_TESTING_MODE = game_settings['game']['bot_testing_mode']  # Whether bot testing mode is enabled
if BOT_TESTING_MODE:
    POKER_MIN_PLAYERS = 1
    POKER_MAX_PLAYERS = 1

settings = load_settings()
coin_icon = settings['coin_icon']

TICKET_COST = 100

class CommandHandler(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.duels = {}
        self.blackjack_games = {}
        self.dealerpoker_games = {}
        self.lottery = Lottery(bot)

    @commands.command(name='challenge')
    async def challenge(self, ctx, opponent_name: str):
        opponent = self.find_member(ctx.guild, opponent_name)
        if opponent is None:
            await ctx.send(f"Could not find a unique member with the name '{opponent_name}'. Please specify a more exact name or use mention.")
            return

        if ctx.author.id in self.duels or opponent.id in self.duels:
            await ctx.send("One of the players is already in a duel!")
            return

        self.duels[ctx.author.id] = Duel(ctx.author.id, opponent.id)
        self.duels[opponent.id] = self.duels[ctx.author.id]

        if opponent == self.bot.user and BOT_TESTING_MODE:
            await self.accept_duel(ctx)
        else:
            await ctx.send(f"{ctx.author.mention} has challenged {opponent.mention} to a duel! Use `!accept` to accept the challenge.")

    @commands.command(name='accept')
    async def accept_duel(self, ctx):
        if ctx.author.id not in self.duels:
            return

        duel = self.duels[ctx.author.id]
        duel.generate_letter()
        await ctx.send(f"The duel between {self.bot.get_user(duel.player1).mention} and {self.bot.get_user(duel.player2).mention} has begun! The challenge is to type as many words as you can that start with '{duel.letter}'. The duel will continue until one player's health reaches zero. Type your words separated by spaces.")

        await self.handle_duel(ctx, duel)

    @commands.command(name='blackjack')
    async def blackjack(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(ctx.author.id))
        current_coins = stats.get('coins', 0)

        await ctx.send(f"You have {current_coins} {coin_icon}. How many {coin_icon} would you like to bet?")

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content.isdigit()

        while True:
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=30.0)
                bet = int(msg.content)
                if bet > 0 and bet <= current_coins:
                    break
                else:
                    await ctx.send(f"Invalid response. Bet must be a positive number and less than or equal to your balance ({current_coins} {coin_icon}). You have 30 seconds to respond accurately.")
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond! Please use !blackjack again.")
                return

        reduction_amt = -(bet)
        activity_tracker.update_user_activity(ctx.author, coins=reduction_amt)

        game = BlackjackGame(ctx.author, self.bot)
        await game.start_game(bet)
        self.blackjack_games[ctx.author.id] = game

        await game.send_hand(ctx)

    @commands.command(name='hit')
    async def hit(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.hit(ctx)

    @commands.command(name='stand')
    async def stand(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.stand(ctx)

    # Command to enter the lottery
    @commands.command(name='enterlottery')
    async def enter_lottery(self, ctx):
        user_id = str(ctx.author.id)

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        current_lottery_pot = self.lottery.get_current_lottery_pot()
        await ctx.send(f"Each ticket is worth {TICKET_COST} {coin_icon}. How many tickets would you like to buy? Current Lottery Pot: {current_lottery_pot} {coin_icon}")

        try:
            msg = await self.bot.wait_for('message', check=check, timeout=50.0)
            num_tickets = int(msg.content)
            cost = num_tickets * TICKET_COST

            await ctx.send(f"Are you sure you want to purchase {num_tickets} tickets for {cost} {coin_icon}? Say `!accept` if you wish to proceed.")

            msg = await self.bot.wait_for('message', check=check, timeout=50.0)
            if msg.content.lower() == '!accept':
                activity_tracker = self.bot.get_cog('ActivityTracker')
                user_data = activity_tracker.get_statistics(user_id)
                user_balance = user_data.get('coins', 0)

                if user_balance < cost:
                    await ctx.send(f"{ctx.author.mention}, you do not have enough {coin_icon} to buy {num_tickets} tickets. Your current balance is {user_balance} {coin_icon}.")
                    return

                activity_tracker.update_user_activity(ctx.author, coins=-cost)
                self.lottery.add_tickets(user_id, num_tickets)
                total_tickets = self.lottery.load_lottery_data()['participants'][user_id]

                current_lottery_pot = self.lottery.get_current_lottery_pot()
                await ctx.send(f"Purchase Successful. Check back at 11 PM EST for the lottery results. You now have a total of {total_tickets} tickets in the lottery. \nYour {coin_icon} Balance: {user_balance - cost} {coin_icon}, Current Lottery Pot: {current_lottery_pot} {coin_icon}")
            else:
                await ctx.send("Purchase canceled.")
        except ValueError:
            await ctx.send("Invalid number of tickets.")
        except asyncio.TimeoutError:
            await ctx.send("You took too long to respond.")

    @commands.command(name='lotterystatus')
    async def lottery_status(self, ctx):
        data = self.lottery.load_lottery_data()
        total_tickets = data['total_tickets']
        participants = len(data['participants'])
        current_lottery_pot = self.lottery.get_current_lottery_pot()
        await ctx.send(f"__**Current Lottery Status:**__\nTotal Tickets Sold: {total_tickets}\nNumber of Participants: {participants}\nCurrent Lottery Pot: {current_lottery_pot} {coin_icon}")

    @commands.command(name='dealerpoker', help='Starts a dealer vs. player poker game')
    async def start_dealer_poker(self, ctx):
        if ctx.channel.id in self.dealerpoker_games:
            await ctx.send("A dealer poker game is already running in this channel!")
            return

        self.dealerpoker_games[ctx.channel.id] = True

        try:
            poker_game = DealerPoker(ctx, self.bot)
            await poker_game.start_game()
        finally:
            self.dealerpoker_games.pop(ctx.channel.id, None)


async def setup(bot):
    await bot.add_cog(CommandHandler(bot))


.\bot\games\lottery.py
import os, random, json, math, asyncio, logging
from datetime import datetime, timedelta, timezone
from discord.ext import commands, tasks
from settings.settings import load_settings

logging.basicConfig(level=logging.INFO)

TICKET_COST = 100

settings = load_settings()
coin_icon = settings['coin_icon']

class Lottery:
    def __init__(self, bot):
        self.bot = bot  # Set the bot for the lottery.
        self.check_lottery_draw.start()  # Starting the task that checks the lottery draw time.
        self.initial_pot = 15000  # Initial pot amount
        self.LOTTERY_FILE = 'data/games/lottery/lottery.json'

    def load_lottery_data(self):
        if not os.path.exists(self.LOTTERY_FILE):
            data = {'total_tickets': 0, 'participants': {}, 'current_pot': self.initial_pot}
            self.save_lottery_data(data)
        else:
            with open(self.LOTTERY_FILE, 'r') as file:
                data = json.load(file)
                if 'total_tickets' not in data:
                    data['total_tickets'] = 0
                if 'participants' not in data:
                    data['participants'] = {}
                if 'current_pot' not in data:
                    data['current_pot'] = self.initial_pot
        return data

    def save_lottery_data(self, data):
        with open(self.LOTTERY_FILE, 'w') as file:
            json.dump(data, file, indent=4)

    def get_current_lottery_pot(self):
        data = self.load_lottery_data()
        return data.get('current_pot', self.initial_pot)

    def add_tickets(self, user_id, ticket_count):
        data = self.load_lottery_data()
        if user_id not in data['participants']:
            data['participants'][user_id] = 0
        data['participants'][user_id] += ticket_count
        data['total_tickets'] += ticket_count
        data['current_pot'] += ticket_count * TICKET_COST
        self.save_lottery_data(data)

    def draw_winner(self):
        data = self.load_lottery_data()
        if data['total_tickets'] > 0:
            tickets = [user_id for user_id, count in data['participants'].items() for _ in range(count)]
            winner = random.choice(tickets)
            current_pot = data['current_pot']
            data['participants'] = {}
            data['total_tickets'] = 0
            data['current_pot'] = self.initial_pot
            self.save_lottery_data(data)
            return winner, current_pot
        return None, 0

    @tasks.loop(minutes=1)
    async def check_lottery_draw(self):
        data = self.load_lottery_data()
        channel = self.bot.get_channel(1252055670778368013)
        now = datetime.now(timezone.utc)
        logging.info(f"Current UTC time: {now}")
        if now.hour == 3 and now.minute == 0:
            logging.info("It's time to announce the winner!")
            await self.announce_winner()
        elif (now.hour == 16 and now.minute == 0) or (now.hour == 19 and now.minute == 0) or (now.hour == 1 and now.minute == 0): 
            await channel.send(f"Remember that 11 PM, the lottery will be drawn!  Type `!enterlottery` to buy tickets.")
            await channel.send(f"Current Pot: {data['current_pot']} {coin_icon}")

    async def announce_winner(self):
        data = self.load_lottery_data()
        if not data['participants']:
            logging.info("No participants in the lottery.")
            return

        channel = self.bot.get_channel(1252055670778368013)

        message = await channel.send("Today's Lottery Winner: ...")

        start_time = datetime.now(timezone.utc)
        duration = 60
        end_time = start_time + timedelta(seconds=duration)

        initial_sleep_time = 1
        final_sleep_time = 3
        total_steps = 1000

        current_step = 0
        while datetime.now(timezone.utc) < end_time:
            participant = random.choice(list(data['participants'].items()))
            user_id, tickets = participant
            ticket_number = random.choice(list(range(tickets)))
            member = await self.bot.fetch_user(user_id)
            await message.edit(content=f"Picking Lottery Winner... {member.display_name} (Ticket #{ticket_number})")

            sleep_time = initial_sleep_time + (final_sleep_time - initial_sleep_time) * (1 - math.exp(-current_step / total_steps))
            await asyncio.sleep(sleep_time)

            current_step += 1

        winner_id, current_pot = self.draw_winner()
        winner = await self.bot.fetch_user(winner_id)
        await message.edit(content=f"Today's Lottery Winner: {winner.display_name} (Ticket #{ticket_number})")
        await channel.send(content=f"{winner.display_name} has won {current_pot} {coin_icon}!")

        # Update the winner's activity
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if winner:
            activity_tracker.update_user_activity(winner, coins=current_pot)
            await channel.send(content=f"Congratulations {winner.display_name}! Your new balance is {activity_tracker.get_statistics(str(winner.id)).get('coins', 0)} {coin_icon}.")

.\bot\games\__init__.py


.\bot\misc\referral.py
import discord
import json
from discord.ext import commands
from settings.settings import load_settings
from datetime import datetime, timezone, timedelta

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

# Load settings from a settings file
settings = load_settings()
coin_icon = settings['coin_icon']

# The reward for inviting a new member
INVITE_REWARD = 50000

class ReferralTracker(commands.Cog):
    """
    A Cog for tracking member invites and rewarding both the inviter and the new member with coins.
    """

    def __init__(self, bot):
        """
        Initialize the ReferralTracker cog.

        Parameters:
            bot (commands.Bot): The bot instance.
        """
        self.bot = bot
        self.invite_tracker = {}  # Dictionary to track the current invite uses

    @commands.Cog.listener()
    async def on_member_join(self, member):
        """
        Event listener for when a member joins the server.

        Parameters:
            member (discord.Member): The member who joined the server.
        """
        # Check if the member's account is older than 60 days
        if (datetime.now(timezone.utc) - member.created_at).days < 60:
            lickertalk_channel = discord.utils.get(member.guild.text_channels, name='licker-talk')
            if lickertalk_channel:
                await lickertalk_channel.send(f"{member.mention}'s account is not eligible for the referral reward (account must be over 60 days old).")
            return

        # Get the invites before the member joined
        invites_before_join = self.invite_tracker.get(member.guild.id, {})
        # Get the current invites after the member joined
        invites_after_join = await member.guild.invites()

        # Determine which invite was used by comparing the uses before and after
        for invite in invites_after_join:
            if invite.uses > invites_before_join.get(invite.code, 0):
                inviter = invite.inviter
                activity_tracker = self.bot.get_cog('ActivityTracker')
                # Update the inviter's and the new member's coin balance
                activity_tracker.update_user_coins(inviter, INVITE_REWARD)
                activity_tracker.update_user_coins(member, INVITE_REWARD)

                # Announce the successful invite in the "lickertalk" channel
                lickertalk_channel = discord.utils.get(member.guild.text_channels, name='licker-talk')
                if lickertalk_channel:
                    await lickertalk_channel.send(
                        f"{inviter.mention} has successfully invited {member.mention} to this server. Both have been rewarded {INVITE_REWARD} {coin_icon}!"
                    )

                # Update the invite tracker with the new number of uses
                self.invite_tracker[member.guild.id][invite.code] = invite.uses
                break

    @commands.Cog.listener()
    async def on_ready(self):
        """
        Event listener for when the bot is ready.
        Initializes the invite tracker with the current invite uses for each guild.
        """
        for guild in self.bot.guilds:
            self.invite_tracker[guild.id] = {invite.code: invite.uses for invite in await guild.invites()}

    @commands.command(name='invitemessage')
    async def invitemessage(self, ctx):
        """
        Command to generate an invite link and provide a message template for the user to share.
        """
        # Create a new invite link with a maximum of 1 use and a 1-day expiration time
        invite = await ctx.channel.create_invite(max_uses=1, max_age=86400, unique=True)
        invite_message = (
            f"Hey! Join Gilligan Lickers for you and me to get {INVITE_REWARD} {coin_icon}. "
            f"Use my referral link (valid for one day): {invite.url}"
        )

        await ctx.send(
            f"{ctx.author.mention}, here's your invite link and message to share:\n\n"
            f"{invite_message}"
        )

async def setup(bot):
    """
    Setup function to add the ReferralTracker cog to the bot.

    Parameters:
        bot (commands.Bot): The bot instance.
    """
    await bot.add_cog(ReferralTracker(bot))


.\bot\misc\__init__.py


.\bot\status\offline.py
import aiohttp
import asyncio
import pytz
from datetime import datetime, timedelta
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    def get_estimated_time_back_up(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        estimated_time = now + timedelta(hours=16)
        hour = estimated_time.hour if estimated_time.hour <= 12 else estimated_time.hour - 12
        period = "AM" if estimated_time.hour < 12 else "PM"
        formatted_time = f"{hour}:{estimated_time.strftime('%M')} {period} EST"
        return estimated_time.strftime("%m/%d/%Y"), formatted_time

    def get_most_recent_script(self):
        scripts_directory = 'bot'
        scripts = [os.path.join(root, file) for root, _, files in os.walk(scripts_directory) for file in files if file.endswith('.py')]
        if not scripts:
            return "Unknown Script", "No recent updates detected"

        most_recent_script = max(scripts, key=lambda x: os.path.getmtime(x))
        script_name = os.path.basename(most_recent_script).replace('.py', '').capitalize()
        return script_name, f"Developing/Fixing the {script_name} feature"

    async def update_status_offline(self):
        current_date, current_time = self.get_current_time()
        estimated_date, estimated_time_back_up = self.get_estimated_time_back_up()
        script_name, reasoning = self.get_most_recent_script()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** OFFLINE

**Reasoning:** {reasoning}
**Estimated Date Back Up:** {estimated_date}
**Estimated Time Back Up:** {estimated_time_back_up}
**Impact on Users:** Inability to use bot
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to OFFLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_offline()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_offline()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\online.py
import aiohttp
import asyncio
import pytz
from datetime import datetime
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    async def update_status_online(self):
        current_date, current_time = self.get_current_time()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** ONLINE

**Reasoning:** Bot started successfully
**Estimated Date Back Up:** N/A
**Estimated Time Back Up:** N/A
**Impact on Users:** Fully operational
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to ONLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_online()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_online()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\setup.py
from . import offline, online

async def setup(bot):
    pass  # No need to add any cogs or extensions here as the status scripts are executed separately


.\settings\settings.py
import json 
import os

def load_settings():
    # Get the current directory of the settings.py file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    # Construct the path to the settings.json file
    settings_path = os.path.join(current_dir, 'json', 'settings.json')
    # Open and load the settings.json file
    with open(settings_path, 'r', encoding='utf-8') as f:
        settings = json.load(f)
    return settings

.\utils\graphics.py
import matplotlib.pyplot as plt  # Import Matplotlib for creating visualizations
import matplotlib.patches as patches  # Import patches to draw shapes
import requests  # Import requests to download images from the web
from PIL import Image, ImageDraw, ImageOps  # Import Pillow to handle image processing
from io import BytesIO  # Import BytesIO to handle image data in memory
import numpy as np  # Import NumPy for numerical operations
import os  # Import os to handle file paths

# Function to generate an image showing the user's level information.
def generate_level_image(username, level, progress, points, next_level, avatar_url):
    try:
        # Download the avatar image from the provided URL
        response = requests.get(avatar_url)
        avatar = Image.open(BytesIO(response.content)).resize((250, 225))  # Resize avatar to 225x225 pixels

        shadow_offset = 2  # Offset for the shadow
        font_name = 'Verdana'

        # Create a new figure (canvas)
        fig, ax = plt.subplots(figsize=(7, 2))  # Set figure size
        fig.patch.set_facecolor((255/255, 127/255, 80/255))  # Set figure background color (light pink)
        ax.set_facecolor((173/255, 216/255, 230/255))  # Set axis background color (light blue)

        ax.set_xlim(0, 1000)  # Set x-axis limit
        ax.set_ylim(0, 250)  # Set y-axis limit
        ax.axis('off')  # Hide axes

        # Draw the avatar image on the canvas
        plt.imshow(avatar, aspect='auto', extent=(10, 10 + avatar.size[0], 12.5, 12.5 + avatar.size[1]))

        font_properties1 = {'family': font_name, 'weight': 'extra bold', 'size': 25}  # Font properties for username
        font_properties2 = {'family': font_name, 'weight': 'bold', 'size': 15}  # Font properties for points text
        font_properties3 = {'family': font_name, 'weight': 'extra bold', 'size': 20}

        # Draw the username text next to the avatar
        plt.text(275 + shadow_offset, 200 - shadow_offset, username, fontdict=font_properties1, color='black', ha='left', va='center')
        plt.text(275, 200, username, fontdict=font_properties1, color='white', ha='left', va='center')
        # Draw the points text
        plt.text(275 + shadow_offset, 150 - shadow_offset, f"Points: {points}", fontdict=font_properties2, color='black', ha='left', va='center')
        plt.text(275, 150, f"Points: {points}", fontdict=font_properties2, color='white', ha='left', va='center')

        # Define the position and size of the progress bar
        canvas_width = 1000  # Width of the canvas
        bar_width = 450  # Width of the progress bar
        bar_height = 70  # Height of the progress bar
        bar_x = ((canvas_width - bar_width + 225) / 2) + 10  # X-coordinate of the progress bar (centered horizontally)
        bar_y = 20  # Y-coordinate of the progress bar

        # Draw the background of the progress bar
        ax.add_patch(patches.Rectangle((bar_x, bar_y), bar_width, bar_height, color=(255/255, 255/255, 255/255), alpha=0.3))

        # Calculate the width of the filled part of the progress bar
        fill_width = (progress / 100) * bar_width
        # Draw the filled part of the progress bar
        ax.add_patch(patches.Rectangle((bar_x, bar_y), fill_width, bar_height, color=(76/255, 175/255, 80/255)))

        # Draw the current level text
        plt.text(bar_x - 10 + shadow_offset, (bar_y + bar_height / 2) - 12.5 - shadow_offset, f"{level}", fontdict=font_properties1, color='black', ha='right', va='center')
        plt.text(bar_x - 10, (bar_y + bar_height / 2) - 12.5, f"{level}", fontdict=font_properties1, color='white', ha='right', va='center')

        plt.text((bar_x + (bar_width / 2))  + shadow_offset, (bar_y + (bar_height / 2)) - shadow_offset, f"{progress:.2f}%", fontdict=font_properties3, color='black', ha='center', va='center')
        plt.text((bar_x + (bar_width / 2)), (bar_y + (bar_height / 2)), f"{progress:.2f}%", fontdict=font_properties3, color='white', ha='center', va='center')

        # Draw the next level text
        plt.text(bar_x + bar_width + 10 + shadow_offset, (bar_y + bar_height / 2) - 12.5 - shadow_offset, f"{next_level}", fontdict=font_properties1, color='black', ha='left', va='center')
        plt.text(bar_x + bar_width + 10, (bar_y + bar_height / 2) - 12.5, f"{next_level}", fontdict=font_properties1, color='white', ha='left', va='center')

        # Save the figure to a BytesIO object
        image_buffer = BytesIO()
        plt.savefig(image_buffer, format='png', bbox_inches='tight', pad_inches=0, dpi=100)
        plt.close()
        image_buffer.seek(0)  # Move the cursor to the start of the BytesIO object

        return image_buffer

    except Exception as e:
        print(f"Error in generate_level_image: {e}")
        return None

def generate_statistics_visualization(stats):
    labels = ['Messages Sent', 'Minutes in Voice', 'Minutes Online']  # Labels for the bars
    user_values = [stats.get('messages_sent', 0), stats.get('minutes_in_voice', 0), stats.get('minutes_online', 0)]  # User's stats
    server_averages = [100, 50, 300]  # Server average stats (dummy values, should be replaced with real data)

    x = np.arange(len(labels))  # X-axis positions for the bars

    fig, ax = plt.subplots()  # Create a new figure and axis
    ax.bar(x - 0.2, user_values, width=0.4, label='User')  # Draw user bars
    ax.bar(x + 0.2, server_averages, width=0.4, label='Server Average')  # Draw server average bars

    ax.set_xlabel('Activity')  # Set x-axis label
    ax.set_ylabel('Count')  # Set y-axis label
    ax.set_title('User Activity vs Server Average')  # Set title
    ax.set_xticks(x)  # Set x-axis ticks
    ax.set_xticklabels(labels)  # Set x-axis labels
    ax.legend()  # Add legend

    plt.tight_layout()  # Adjust layout to fit everything
    image_path = 'utils/images/statistics_visualization.png'  # Define the file path to save the image
    plt.savefig(image_path)  # Save the figure to a file
    plt.close()  # Close the figure to free up memory

    return image_path  # Return the path to the generated image


.\utils\__init__.py


