./
    main.py
    resetdata.py
    summary.py
    test.py
    bot/
        activity_tracker.py
        commands.py
        level_widget.py
        shop.py
        __init__.py
        games/
            blackjack.py
            duel.py
            game_manager.py
            lottery.py
            poker.py
        status/
            offline.py
            online.py
            setup.py
            __pycache__/
        __pycache__/
    data/
        games/
            lottery/
    settings/
        .env
        settings.py
        json/
        __pycache__/
    utils/
        graphics.py
        __init__.py
        images/
            blackjackdump/
            deckofcards/
                10/
                2/
                3/
                4/
                5/
                6/
                7/
                8/
                9/
                A/
                J/
                K/
                Q/
            levelimages/
            pokerdump/
        sounds/
            musicdump/
        __pycache__/


.\main.py
import discord
from discord.ext import commands
import os
import subprocess
import sys
import signal
from settings.settings import load_settings
from dotenv import load_dotenv

load_dotenv(dotenv_path='settings/.env')
TOKEN = os.getenv('TOKEN')

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

def update_status_offline():
    script_path = os.path.join('bot', 'status', 'offline.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to OFFLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

def signal_handler(signal, frame):
    print("Signal received, updating status to OFFLINE...")
    update_status_offline()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    await bot.load_extension('bot.activity_tracker')
    await bot.load_extension('bot.commands')
    await bot.load_extension('bot.games.game_manager')
    await bot.load_extension('bot.shop')
    print("Extensions loaded")

    # Update the bot status to ONLINE
    script_path = os.path.join('bot', 'status', 'online.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to ONLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

bot.run(TOKEN)


.\resetdata.py
import json

def wipe_activity_data():
    with open('data/player_data.json', 'w') as f:
        json.dump({}, f, indent=4)


wipe_activity_data()

.\summary.py
import os

def generate_directory_tree(directory, exceptions):
    tree = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list or is a .git directory
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions) or '.git' in relative_root:
            continue
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        tree.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list or is a git-related file
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions) and '.git' not in file_relative_path:
                if any(file.endswith(ext) for ext in ['.py', '.env']):
                    tree.append(f"{subindent}{file}")
    return tree

def generate_summary(directory, exceptions, include_extensions):
    summary = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list or is a .git directory
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions) or '.git' in relative_root:
            continue
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list, has an allowed extension, or is a git-related file
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions) and '.git' not in file_relative_path:
                if any(file.endswith(ext) for ext in include_extensions):
                    file_path = os.path.join(root, file)
                    summary.append(file_path)
    return summary

def read_and_prepend_file(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        content = file.read()
    return f"{file_path}\n{content}"

if __name__ == "__main__":
    exceptions = [
        os.path.normpath('extensions/gulp'),
        os.path.normpath('assets/instance/database.db'),
        os.path.normpath('assets/migrations')
    ]  # Add more directories to this list if needed
    include_extensions = [
        '.py'
    ]  # Only include .py files for content
    with open('project_summary.txt', 'w', encoding='utf-8') as f:
        # Write directory tree
        directory_tree = generate_directory_tree('.', exceptions)
        for line in directory_tree:
            f.write(line + '\n')

        f.write('\n\n')  # Separate the directory tree from the file contents

        # Write file contents
        summary = generate_summary('.', exceptions, include_extensions)
        for file_path in summary:
            file_content = read_and_prepend_file(file_path)
            f.write(file_content + '\n\n')


.\test.py
INITIAL_LEVEL_POINTS_NEEDED = 1000  # Starting with a higher initial value
INITIAL_LEVEL = 1

def calculate_level_points(POINTS_NEEDED, CURRENT_LEVEL, growth_factor):
    if CURRENT_LEVEL == 1:
        return INITIAL_LEVEL_POINTS_NEEDED
    else:
        return round(POINTS_NEEDED * growth_factor)

# Calculate total points needed to reach a certain level
def total_points_to_reach_level(target_level, growth_factor):
    total_points = 0
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(2, target_level + 1):
        points_needed = calculate_level_points(points_needed, level, growth_factor)
        total_points += points_needed
    return total_points

# Adjust growth factor to fit the goal
def find_optimal_growth_factor(target_levels, target_points):
    growth_factor = 1.01
    while True:
        match = True
        for target_level, target_point in zip(target_levels, target_points):
            total_points = total_points_to_reach_level(target_level, growth_factor)
            if abs(total_points - target_point) > target_point * 0.01:  # Allow 1% tolerance
                match = False
                break
        if match:
            break
        growth_factor += 0.001
    return growth_factor - 0.001  # Step back to the last valid growth factor

# Target levels and their corresponding total points
target_levels = [10, 100, 300]
target_points = [12000, 97000, 600000]

# Calculate the optimal growth factor
optimal_growth_factor = find_optimal_growth_factor(target_levels, target_points)

# Print the optimal growth factor
print(f"Optimal growth factor: {optimal_growth_factor:.4f}")

# Calculate points needed for each level incrementally
def points_needed_per_level(target_level, growth_factor):
    points_per_level = []
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(1, target_level):
        next_level_points = calculate_level_points(points_needed, level, growth_factor)
        points_per_level.append((level, next_level_points))
        points_needed = next_level_points
    return points_per_level

# Print points needed for each level from 1 to target level
target_level = 500
points_per_level = points_needed_per_level(target_level, optimal_growth_factor)
for level, points in points_per_level:
    print(f"Points needed from level {level} to {level + 1}: {points} points")


.\bot\activity_tracker.py
# activity_tracker.py
import discord
from discord.ext import commands, tasks
import json
import os
from datetime import datetime, timezone

# Variables for point increments and bot testing mode
MESSAGE_POINTS = 10
VOICE_POINTS = 5
ONLINE_POINTS = 2
CHARACTERS_TYPED_POINTS = 0.1
DUEL_WIN_POINTS = 100
DUEL_WIN_COINS = 500
BOT_TESTING_MODE = True  # Set to False to disable bot auto-playing duels

class ActivityTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.activity_data = self.load_activity_data()
        self.reset_daily_stats.start()
        self.track_activity.start()

    def load_activity_data(self):
        if os.path.exists('data/player_data.json'):
            with open('data/player_data.json', 'r') as f:
                return json.load(f)
        return {}

    def save_activity_data(self):
        with open('data/player_data.json', 'w') as f:
            json.dump(self.activity_data, f, indent=4)

    @tasks.loop(hours=24)
    async def reset_daily_stats(self):
        now = datetime.now(timezone.utc)
        if now.hour == 5:  # 5 AM UTC, midnight EST
            for user_id in self.activity_data:
                self.activity_data[user_id]['points_today'] = 0
            self.save_activity_data()

    @reset_daily_stats.before_loop
    async def before_reset_daily_stats(self):
        await self.bot.wait_until_ready()

    @tasks.loop(minutes=5)
    async def track_activity(self):
        for guild in self.bot.guilds:
            for member in guild.members:
                if member.status != discord.Status.offline and not member.bot:
                    user_id = str(member.id)
                    if user_id not in self.activity_data:
                        self.activity_data[user_id] = {
                            "username": member.name,
                            "points": 0,
                            "points_today": 0,
                            "level": 1,
                            "messages_sent": 0,
                            "characters_typed": 0,
                            "minutes_in_voice": 0,
                            "minutes_online": 0,
                            "voice_activations": 0,
                            "total_talking_time": 0,
                            "coins": 0  # Add coins attribute
                        }
                    self.activity_data[user_id]['minutes_online'] += ONLINE_POINTS  # Increment by ONLINE_POINTS
                    self.save_activity_data()

    def update_user_activity(self, user, points=0, coins=0):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "points": 0,
                "points_today": 0,
                "level": 1,
                "messages_sent": 0,
                "characters_typed": 0,
                "minutes_in_voice": 0,
                "minutes_online": 0,
                "voice_activations": 0,
                "total_talking_time": 0,
                "coins": 0  # Add coins attribute
            }
        self.activity_data[user_id]['points'] += points
        self.activity_data[user_id]['points_today'] += points
        self.activity_data[user_id]['coins'] += coins
        self.save_activity_data()

    def update_user_coins(self, user, coins):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "coins": 0,
                # Add other fields as necessary
            }
        self.activity_data[user_id]['coins'] += coins
        self.save_activity_data()

    def transfer_coins(self, from_user, to_user, amount):
        from_user_id = str(from_user.id)
        to_user_id = str(to_user.id)

        if from_user_id not in self.activity_data or to_user_id not in self.activity_data:
            return False, "User data not found."

        if self.activity_data[from_user_id]['coins'] < amount:
            return False, "Insufficient balance."

        self.activity_data[from_user_id]['coins'] -= amount
        self.activity_data[to_user_id]['coins'] += amount
        self.save_activity_data()

        return True, f"Transferred {amount} coins from {from_user.name} to {to_user.name}."

    @commands.Cog.listener()
    async def on_message(self, message):
        if not message.author.bot:
            self.update_user_activity(message.author, points=MESSAGE_POINTS)
            self.activity_data[str(message.author.id)]['messages_sent'] += 1
            self.activity_data[str(message.author.id)]['characters_typed'] += len(message.content)
            self.save_activity_data()

    def get_statistics(self, user_id):
        return self.activity_data.get(user_id, {})
    
    def get_User_balance(self, user):
        user_id = str(user.id)
        if user_id in self.activity_data:
            return self.activity_data[user_id].get('coins', 0)
        return 0
    
def points_for_level_transition(level):
    return 10000 if level == 1 else (level + 1) * 5000

def points_for_next_level(current_level):
    total_points = 0
    for level in range(1, current_level + 1):
        total_points += points_for_level_transition(level)
    return total_points

def get_current_level(points):
    level = 1
    while points >= points_for_next_level(level):
        level += 1
    return level, points_for_next_level(level) - points_for_next_level(level - 1)


async def setup(bot):
    await bot.add_cog(ActivityTracker(bot))


.\bot\commands.py
# commands.py
from discord.ext import commands
import discord
from utils.graphics import generate_level_image, generate_statistics_visualization
import pandas as pd
from datetime import datetime, timedelta
import random
import pytz
from settings.settings import load_settings
import subprocess
import sys
import os
import asyncio
from discord.ui import View
from bot.activity_tracker import get_current_level, points_for_next_level
import yt_dlp as youtube_dl
from pydub import AudioSegment
from dotenv import load_dotenv
from tabulate import tabulate
import matplotlib.pyplot as plt

# Load the .env file
load_dotenv()

# Set the path to ffmpeg from .env file
ffmpeg_path = os.getenv('FFMPEG_PATH')
os.environ["PATH"] += os.pathsep + ffmpeg_path
AudioSegment.converter = os.path.join(ffmpeg_path, 'ffmpeg.exe')
AudioSegment.ffmpeg = os.path.join(ffmpeg_path, 'ffmpeg.exe')
AudioSegment.ffprobe = os.path.join(ffmpeg_path, 'ffprobe.exe')

TESTING = False
settings = load_settings()
coin_icon = settings['coin_icon']

class GeneralCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    
    @commands.command(name='gift')
    async def gift(self, ctx, recipient: discord.Member, amount: int, *, reason: str):
        if amount <= 0:
            await ctx.send("Gift amount must be positive.")
            return

        if ctx.author == recipient:
            await ctx.send(f"You cannot gift {coin_icon} to yourself.")
            return

        activity_tracker = self.bot.get_cog('ActivityTracker')
        success, message = activity_tracker.transfer_coins(ctx.author, recipient, amount)
        
        if success:
            await ctx.send(f"{ctx.author.mention} gifted {amount} {coin_icon} to {recipient.mention} for: {reason}")
        else:
            await ctx.send(f"Failed to gift {coin_icon}: {message}")

    @commands.command(name='forbeslist')
    async def forbeslist(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        all_data = activity_tracker.activity_data

        # Convert data to a list of tuples and sort by coins
        coin_list = [(user_id, data['coins']) for user_id, data in all_data.items() if 'coins' in data]
        sorted_coin_list = sorted(coin_list, key=lambda x: x[1], reverse=True)[:10]

        # Create DataFrame
        data = {
            "Rank": list(range(1, len(sorted_coin_list) + 1)),
            "Player Name": [self.bot.get_user(int(user_id)).display_name if self.bot.get_user(int(user_id)) else "Unknown User" for user_id, _ in sorted_coin_list],
            f"Coins": [coins for _, coins in sorted_coin_list]
        }
        df = pd.DataFrame(data)

        # Plot the table with a cleaner style
        fig, ax = plt.subplots(figsize=(5, 2))  # Adjusted figsize for better appearance
        ax.axis('tight')
        ax.axis('off')

        # Create table
        table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center', edges='horizontal')
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 1.2)  # Scale up the table for better readability

        # Customize header row
        for key, cell in table.get_celld().items():
            cell.set_edgecolor('black')
            cell.set_linewidth(1)
            if key[0] == 0:
                cell.set_text_props(weight='bold', color='black') # This should work for the background color

        # Save the table as an image
        image_path = 'utils/images/forbes_list.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)

        # Send the image in Discord
        file = discord.File(image_path, filename='forbes_list.png')
        embed = discord.Embed(title="Forbes List")
        embed.set_image(url="attachment://forbes_list.png")
        await ctx.send(embed=embed, file=file)

        # Clean up the saved image file
        os.remove(image_path)

    @commands.command(name='update_notes')
    async def update_notes(self, ctx, *, notes):
        try:
            # Determine if the bot is online or offline
            online_status = True  # Replace with your logic to determine the status

            script_path = os.path.join('bot', 'status', 'online.py' if online_status else 'offline.py')

            # Run the update_additional_notes method in the respective script
            process = subprocess.run([sys.executable, script_path, notes], capture_output=True, text=True)

            if process.returncode == 0:
                print("Successful Notes Change")
            else:
                await ctx.send(f"Failed to update additional notes. Error: {process.stderr}")
        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    @commands.command(name='daily')
    async def daily(self, ctx):
        user_id = str(ctx.author.id)
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})

        if ctx.message.content.strip() != '!daily':
            return

        if TESTING:
            last_daily = None
        else:
            last_daily = user_data.get('last_daily', None)

        now = datetime.utcnow()

        if last_daily:
            last_daily_time = datetime.strptime(last_daily, "%Y-%m-%d %H:%M:%S")
            if now < last_daily_time + timedelta(hours = 24):
                next_claim_time = last_daily_time + timedelta(hours = 24)
                est = pytz.timezone('US/Eastern')
                next_claim_time_est = next_claim_time.replace(tzinfo=pytz.utc).astimezone(est)
                next_claim_time_str = next_claim_time_est.strftime('%Y-%m-%d %I:%M:%S %p')
                await ctx.send(f"You have already claimed your daily {coin_icon}.  NEXT CLAIM TIME: {next_claim_time_str} EST.")
                return
            
        daily_coins = random.randint(0, 10000)
        digits = str(daily_coins)

        await ctx.send(f"{ctx.author.mention}, generating your daily coins...")
        
        accumulated_digits = ""
        for digit in digits:
            accumulated_digits += digit
            await ctx.send(f"{accumulated_digits}")
            await asyncio.sleep(0.5)

        activity_tracker.update_user_coins(ctx.author, daily_coins)
        activity_tracker.activity_data[user_id]['last_daily'] = now.strftime('%Y-%m-%d %H:%M:%S')
        activity_tracker.save_activity_data()

        await ctx.send(f"You have been rewarded {daily_coins} {coin_icon} for the day!  Your balance is now {activity_tracker.activity_data[user_id]['coins']} {coin_icon}.")

    @commands.command(name='coinbalance')
    async def coinbalance(self, ctx, mentioned_user: discord.Member = None):
        if mentioned_user:
            user_id = str(mentioned_user.id)
            user_name = mentioned_user.display_name
        else:
            mentioned_user = ctx.author
            user_id = str(ctx.author.id)
            user_name = ctx.author.display_name

        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})
        coins = user_data.get('coins', 0)
        coin_icon = load_settings()['coin_icon']

        if mentioned_user == ctx.author:
            await ctx.send(f"{ctx.author.mention}, you have {coins} {coin_icon} in your account.")
        else:
            await ctx.send(f"{ctx.author.mention}, {user_name} has {coins} {coin_icon} in their account.")

class LevelUIView(View):
    def __init__(self, username, avatar_url, points, current_level, next_level, progress_percentage, remaining_points):
        super().__init__(timeout=60)
        self.username = username
        self.avatar_url = avatar_url
        self.points = points
        self.current_level = current_level
        self.next_level = next_level
        self.progress_percentage = progress_percentage
        self.remaining_points = remaining_points

class LevelUI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='level')
    async def level(self, ctx, member: discord.Member = None):
        if member is None:
            member = ctx.author

        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_stats = activity_tracker.get_statistics(str(member.id))
        if not user_stats:
            await ctx.send("No statistics available for this user.")
            return

        username = member.display_name
        avatar_url = member.avatar.url
        points = user_stats.get("points", 0)
        current_level, remaining_points = get_current_level(points)
        next_level = current_level + 1
        progress_percentage = (points - points_for_next_level(current_level - 1)) / remaining_points * 100

        image_buffer = generate_level_image(username, current_level, progress_percentage, points, next_level, avatar_url)
    
        if image_buffer:
            file = discord.File(image_buffer, filename="level_image.png")
            embed = discord.Embed(title="Level Information", color=discord.Color.orange())
            embed.set_image(url="attachment://level_image.png")

            await ctx.send(embed=embed, file=file)
        else:
            await ctx.send("An error occurred while generating the level image.")

    @commands.command(name='leaderboard')
    async def leaderboard(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = {user_id: data for user_id, data in activity_tracker.activity_data.items()}
        sorted_stats = sorted(stats.items(), key=lambda x: x[1]['points'], reverse=True)[:20]
        
        df = pd.DataFrame(columns=["Rank", "Username", "Level", "Points"])
        for idx, (user_id, data) in enumerate(sorted_stats, start=1):
            member = ctx.guild.get_member(int(user_id))
            if member:
                df = pd.concat([df, pd.DataFrame({"Rank": [idx], "Username": [member.display_name], "Level": [data['level']], "Points": [data['points']]})], ignore_index=True)
        
        table_str = df.to_markdown(index=False)
        embed = discord.Embed(title="Leaderboard", color=discord.Color.green())
        embed.add_field(name="Top 20 Users", value=f"```\n{table_str}\n```", inline=False)

        await ctx.send(embed=embed)

    @commands.command(name='leaderboard_today')
    async def leaderboard_today(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = {user_id: data for user_id, data in activity_tracker.activity_data.items()}
        sorted_stats = sorted(stats.items(), key=lambda x: x[1].get('points_today', 0), reverse=True)[:20]

        df = pd.DataFrame(columns=["Rank", "Username", "Points Today"])
        for idx, (user_id, data) in enumerate(sorted_stats, start=1):
            member = ctx.guild.get_member(int(user_id))
            if member:
                df = pd.concat([df, pd.DataFrame({"Rank": [idx], "Username": [member.display_name], "Points Today": [data.get('points_today', 0)]})], ignore_index=True)

        table_str = df.to_markdown(index=False)
        embed = discord.Embed(title="Today's Leaderboard", color=discord.Color.green())
        embed.add_field(name="Top 20 Users", value=f"```\n{table_str}\n```", inline=False)

        await ctx.send(embed=embed)

    @commands.command(name='statistics')
    async def statistics(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            embed = discord.Embed(title="Statistics", color=discord.Color.purple())
            embed.add_field(name="Username", value=member.display_name, inline=True)
            embed.add_field(name="Total Points", value=stats.get('points', 0), inline=True)
            embed.add_field(name="Level", value=stats.get('level', 1), inline=True)
            embed.add_field(name="XP to Next Level", value=stats.get('xp_to_next_level', 0), inline=True)
            embed.add_field(name="Minutes in Voice", value=stats.get('minutes_in_voice', 0), inline=True)
            embed.add_field(name="Minutes Online", value=stats.get('minutes_online', 0), inline=True)
            embed.add_field(name="Messages Sent", value=stats.get('messages_sent', 0), inline=True)
            embed.add_field(name="Characters Typed", value=stats.get('characters_typed', 0), inline=True)
            embed.add_field(name="Points Today", value=stats.get('points_today', 0), inline=True)

            # Add coin information
            coins = stats.get('coins', 0)
            coin_icon_url = "https://cdn4.iconfinder.com/data/icons/coins-virtual-currency/104/Guarani-256.png"
            embed.add_field(name=f"\u200b", value=f"[![coins]({coin_icon_url})]({coin_icon_url}) **{coins}**", inline=False)

            await ctx.send(embed=embed)
        else:
            await ctx.send("No statistics available for this user.")

    @commands.command(name='statistics_visualization')
    async def statistics_visualization(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            # Generate the visualization
            visualization_path = generate_statistics_visualization(stats)
            embed = discord.Embed(title="Statistics Visualization", color=discord.Color.purple())
            file = discord.File(visualization_path, filename="statistics_visualization.png")
            embed.set_image(url=f"attachment://statistics_visualization.png")
            await member.send(embed=embed, file=file)
        else:
            await ctx.send("No statistics available for this user.")

    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        if isinstance(error, commands.CommandNotFound):
            botlog_channel = discord.utils.get(ctx.guild.channels, name='botlog')
            if botlog_channel:
                await botlog_channel.send("Invalid Command Called.")
        else:
            raise error
        
class Music(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.current_player = None
        self.voice_channel = None
        self.votes_to_skip = set()
        self.song_queue = asyncio.Queue()
        self.playing_song = None
        self.current_volume = 0.2

    @commands.command(name='play')
    async def play(self, ctx, url):
        user = ctx.author
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.get_statistics(str(user.id))
        user_coins = user_data.get('coins', 0)
        settings = load_settings()
        coin_icon = settings['coin_icon']

        try:
            video_info = await self.get_video_info(url)
            video_length = video_info['duration']  # Duration in seconds
            video_title = video_info['title']
            cost = video_length * 4

            if user_coins < cost:
                await ctx.send(f"{user.mention}, the cost is {cost} {coin_icon}, but you do not have enough {coin_icon}.")
                return

            await ctx.send(f"{user.mention}, the cost to play '{video_title}' is {cost} {coin_icon}. Type `!accept` to proceed.")
            
            def check(m):
                return m.author == user and m.content.lower() == '!accept'
            
            try:
                await self.bot.wait_for('message', check=check, timeout=30.0)
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond!")
                return

            activity_tracker.update_user_activity(user, coins=-cost)
            await ctx.send(f"{user.mention} has paid {cost} {coin_icon} to play '{video_title}'.")

            self.voice_channel = ctx.author.voice.channel
            if not self.voice_channel:
                await ctx.send("You are not connected to a voice channel.")
                return

            audio_file = await self.download_audio(url, video_title)
            await self.song_queue.put((ctx, audio_file, video_title, user))
            if not self.current_player:
                await self.play_next_song()

        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    async def play_next_song(self):
        if not self.song_queue.empty():
            ctx, audio_file, video_title, user = await self.song_queue.get()
            self.voice_channel = ctx.author.voice.channel
            voice = await self.voice_channel.connect()

            source = discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(audio_file), volume=self.current_volume)
            self.current_player = voice.play(source, after=lambda e: self.bot.loop.create_task(self.play_next_song()))

            self.playing_song = (ctx, video_title, user)
            await ctx.send(f"Now playing: '{video_title}'")

            while voice.is_playing():
                await asyncio.sleep(1)
            await voice.disconnect()
            os.remove(audio_file)
            await ctx.send(f"Finished playing: '{video_title}' and removed the file from the system.")
            self.playing_song = None
            self.current_player = None

    @commands.command(name='skip')
    async def skip(self, ctx):
        if not self.current_player:
            await ctx.send("No audio is currently playing.")
            return

        user = ctx.author
        if user == self.playing_song[2]:  # The user who requested the song
            self.current_player.source.cleanup()
            self.current_player.stop()
            await ctx.send(f"{user.mention} has skipped their own song.")
            self.votes_to_skip.clear()
        else:
            if user not in self.voice_channel.members:
                await ctx.send("You must be in the voice channel to vote to skip.")
                return

            self.votes_to_skip.add(user)
            total_members = len(self.voice_channel.members)
            if len(self.votes_to_skip) / total_members >= 0.5:
                self.current_player.source.cleanup()
                self.current_player.stop()
                await ctx.send("Vote passed! Skipping the current song.")
                self.votes_to_skip.clear()
            else:
                await ctx.send(f"{user.mention} has voted to skip. {len(self.votes_to_skip)}/{total_members} votes.")

    @commands.command(name='volume')
    async def volume(self, ctx, volume: float):
        user = ctx.author
        if user != self.playing_song[2]:
            await ctx.send(f"{user.mention}, only the song requester can change the volume.")
            return

        if volume < 0 or volume > 5:
            await ctx.send(f"{user.mention}, volume must be between 0 and 5.")
            return

        self.current_volume = volume * 0.1
        if self.current_player and self.current_player.source:
            self.current_player.source.volume = self.current_volume
        await ctx.send(f"{user.mention}, the volume has been set to {volume}.")

    async def get_video_info(self, url):
        ydl_opts = {
            'format': 'bestaudio/best',
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
            }
        }
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
        return {
            'duration': info['duration'],
            'title': info['title']
        }

    async def download_audio(self, url, title):
        ydl_opts = {
            'format': 'bestaudio/best',
            'outtmpl': f'utils/sounds/musicdump/{title}.%(ext)s',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }],
            'ffmpeg_location': os.getenv('FFMPEG_PATH'),
            'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
            }
        }
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url)
            filename = ydl.prepare_filename(info)
            mp3_filename = filename.replace('.webm', '.mp3')
        
        return mp3_filename

async def setup(bot):
    await bot.add_cog(GeneralCommands(bot))
    await bot.add_cog(LevelUI(bot))
    await bot.add_cog(Music(bot))



.\bot\level_widget.py
import discord
from discord.ext import commands

class LevelWidget(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        print("LevelWidget initialized")

async def setup(bot):
    print("Setting up LevelWidget")
    await bot.add_cog(LevelWidget(bot))
    print("LevelWidget added to bot")


.\bot\shop.py
# bot/shop.py
import discord
from discord.ext import commands
from discord.ui import View, Button
import os

class PaginatedShopView(View):
    def __init__(self, items, per_page=5):
        super().__init__(timeout=60)
        self.items = items
        self.per_page = per_page
        self.current_page = 0
        self.add_item(Button(label="Previous", style=discord.ButtonStyle.secondary, custom_id="previous_page"))
        self.add_item(Button(label="Next", style=discord.ButtonStyle.secondary, custom_id="next_page"))

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user == self.message.author

    @discord.ui.button(label='Previous', style=discord.ButtonStyle.secondary)
    async def previous_page(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.current_page -= 1
        await self.update_embed(interaction)

    @discord.ui.button(label='Next', style=discord.ButtonStyle.secondary)
    async def next_page(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.current_page += 1
        await self.update_embed(interaction)

    async def update_embed(self, interaction: discord.Interaction):
        start = self.current_page * self.per_page
        end = start + self.per_page
        items = self.items[start:end]
        
        embed = discord.Embed(
            title="Casino Shop",
            description="Welcome to the Casino Shop! Here are some items you can purchase:",
            color=discord.Color.blue()
        )
        
        for item in items:
            embed.add_field(name=item['name'], value=f"{item['description']} - {item['price']} {item['icon']}", inline=False)
        
        await interaction.response.edit_message(embed=embed, view=self)

class Shop(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='shop')
    async def shop(self, ctx):
        items = [
            {'name': 'Virtual Pet', 'description': 'A cute virtual pet.', 'price': 100, 'icon': "<:coin:>"},
            {'name': 'Badge', 'description': 'A collectible badge.', 'price': 50, 'icon': "<:coin:>"},
            {'name': 'Game Tokens', 'description': 'Tokens for playing games.', 'price': 20, 'icon': "<:coin:>"}
        ]
        view = PaginatedShopView(items)
        await ctx.send(embed=view.create_embed(), view=view)


async def setup(bot):
    await bot.add_cog(Shop(bot))


.\bot\__init__.py


.\bot\games\blackjack.py
import random, os, discord, asyncio, json
from PIL import Image
from discord.ext import commands
from settings.settings import load_settings

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

CARD_VALUES = game_settings['blackjack']['card_values']  # Dictionary of card values
SUITS = game_settings['blackjack']['suits']  # List of suits
DECK = [f'{value}_of_{suit}' for suit in SUITS for value in CARD_VALUES.keys()]  # List of all cards in the deck
DECK_IMAGES_FOLDER = 'utils/images/deckofcards'
DUMP_IMAGES_FOLDER = 'utils/images/blackjackdump'

BLACKJACK_WIN_POINTS = 100
BLACKJACK_LOSS_POINTS = 20
BLACKJACK_PUSH_POINTS = 45

class BlackjackGame:
    def __init__(self, player, bot):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        self.player = player
        self.bot = bot
        self.player_hand = []
        self.dealer_hand = []
        self.player_points = 0
        self.dealer_points = 0
        self.bet = 0

    async def deal_initial_cards(self):
        self.player_hand = [self.deck.pop(), self.deck.pop()]
        self.dealer_hand = [self.deck.pop(), self.deck.pop()]
        self.player_points = self.calculate_hand_value(self.player_hand)
        self.dealer_points = self.calculate_hand_value(self.dealer_hand)

    def calculate_hand_value(self, hand):
        value = 0
        aces = 0
        for card in hand:
            card_value = card[:-1]  # Get the card value without the suit
            if card_value.isdigit():
                value += int(card_value)
            elif card_value in ['J', 'Q', 'K']:
                value += 10
            else:
                value += 11
                aces += 1
        while value > 21 and aces:
            value -= 10
            aces -= 1
        return value

    async def start_game(self, bet):
        self.bet = bet
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        await self.deal_initial_cards()

    async def player_hit(self):
        card = self.deck.pop()
        self.player_hand.append(card)
        self.player_points = self.calculate_hand_value(self.player_hand)
        return card

    async def dealer_play(self):
        while self.dealer_points < 17:
            card = self.deck.pop()
            self.dealer_hand.append(card)
            self.dealer_points = self.calculate_hand_value(self.dealer_hand)
        return self.dealer_hand

    def get_game_result(self):
        if self.player_points > 21:
            return "bust"
        elif self.dealer_points > 21 or self.player_points > self.dealer_points:
            return "win"
        elif self.player_points == self.dealer_points:
            return "push"
        else:
            return "lose"

    async def create_hand_image(self, hand, reveal_dealer=False):
        card_images = []
        for card in hand:
            if isinstance(card, dict) and card.get('value') == 'back':
                card_image_path = os.path.join(DECK_IMAGES_FOLDER, 'back.png')
            else:
                card_value = card[:-1]  # Extract the value part of the card string
                card_suit = card[-1].upper()  # Extract the suit part of the card string
                if card_value == '10':  # Check for '10' separately
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, '10', f'10{card_suit}.png')
                else:
                    card_value = card_value[0].upper()
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, card_value, f'{card_value}{card_suit}.png')
            card_images.append(card_image_path)
        return card_images

    async def concatenate_images(self, image_paths, filename):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        total_width = sum(widths)
        max_height = max(heights)
        new_image = Image.new('RGB', (total_width, max_height))

        x_offset = 0
        for img in images:
            new_image.paste(img, (x_offset, 0))
            x_offset += img.size[0]

        output_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path

    async def hit(self, ctx):
        card = await self.player_hit()
        await self.send_hand(ctx)

        if self.player_points > 21:
            await self.end_game(ctx, "bust")

    async def stand(self, ctx):
        dealer_hand = await self.dealer_play()
        await self.send_hand(ctx, reveal_dealer=True)

        result = self.get_game_result()
        await self.end_game(ctx, result)

    async def end_game(self, ctx, result):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if result == "win":
            payout = self.bet * 2
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_WIN_POINTS, coins=self.bet)
            await ctx.send(f"Congratulations {ctx.author.mention}, you win! You have been awarded {BLACKJACK_WIN_POINTS} points and {payout} {coin_icon}.")
        elif result == "bust":
            payout = -(self.bet)
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_LOSS_POINTS, coins=payout)
            await ctx.send(f"Sorry {ctx.author.mention}, you busted! You lost {self.bet} {coin_icon}.")
        elif result == "lose":
            payout = -(self.bet)
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_LOSS_POINTS, coins=payout)
            await ctx.send(f"Sorry {ctx.author.mention}, you lose! You lost {self.bet} {coin_icon}.")
        elif result == "push":
            activity_tracker.update_user_activity(ctx.author, points=BLACKJACK_PUSH_POINTS, coins=0)
            await ctx.send(f"It's a push, {ctx.author.mention}. Your bet of {self.bet} {coin_icon} has been returned.")

        await self.cleanup_images()
        del self.bot.get_cog('CommandHandler').blackjack_games[ctx.author.id]

    async def send_hand(self, ctx, reveal_dealer=False):
        player_images = await self.create_hand_image(self.player_hand)
        dealer_hand = self.dealer_hand if reveal_dealer else self.dealer_hand[:1] + [{'value': 'back', 'suit': ''}]
        dealer_images = await self.create_hand_image(dealer_hand)

        concatenated_player_image = await self.concatenate_images(player_images, f'blackjack_{ctx.author.id}_player_hand.png')
        concatenated_dealer_image = await self.concatenate_images(dealer_images, f'blackjack_{ctx.author.id}_dealer_hand.png')

        player_hand_embed = discord.File(concatenated_player_image, filename="player_hand.png")
        dealer_hand_embed = discord.File(concatenated_dealer_image, filename="dealer_hand.png")

        embed = discord.Embed(title="Blackjack")
        embed.add_field(name="Your Hand", value=f"Points: {self.player_points}", inline=True)
        embed.add_field(name="Dealer's Hand", value=f"Points: {self.dealer_points if reveal_dealer else '?'}", inline=True)
        embed.set_image(url=f"attachment://player_hand.png")
        embed.set_thumbnail(url=f"attachment://dealer_hand.png")

        await ctx.send(embed=embed, files=[player_hand_embed, dealer_hand_embed])

    async def cleanup_images(self):
        for filename in os.listdir(DUMP_IMAGES_FOLDER):
            file_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
            if os.path.isfile(file_path):
                os.unlink(file_path)

.\bot\games\duel.py
import random, aiohttp, discord, json
from settings.settings import load_settings


# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

DUEL_WIN_POINTS = game_settings['duel']['win_points']  # Points awarded for winning a duel
DUEL_WIN_COINS = game_settings['duel']['win_coins']  # Coins awarded for winning a duel

settings = load_settings()
coin_icon = settings['coin_icon']

class Duel:
    def __init__(self, player1, player2):
        self.player1 = player1  # ID of player 1
        self.player2 = player2  # ID of player 2
        self.health = {player1: 100, player2: 100}  # Initial health for both players
        self.letter = None  # The current letter for the duel
        self.used_words = set()  # Set of words that have already been used

    def generate_letter(self):
        self.letter = random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')  # Generate a random letter

    async def is_valid_word(self, word):
        url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word.lower()}"  # URL to check if the word is valid
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                return resp.status == 200  # Return True if the word is valid

    def calculate_damage(self, words):
        valid_words = [word for word in words if word.lower().startswith(self.letter.lower()) and word.lower() not in self.used_words]
        self.used_words.update(word.lower() for word in valid_words)  # Add valid words to the set of used words
        return sum(len(word) for word in valid_words)  # Calculate damage as the sum of the lengths of valid words

    def get_winner(self):
        if self.health[self.player1] <= 0:
            return self.player2  # Player 2 wins if player 1's health is 0 or less
        elif self.health[self.player2] <= 0:
            return self.player1  # Player 1 wins if player 2's health is 0 or less
        return None  # No winner if both players have health above 0

    def adjust_health(self, player_id, damage):
        self.health[player_id] = max(self.health[player_id] - damage, 0)  # Reduce health by the damage amount, but not below 0

    async def handle_duel(self, ctx, duel):
        def check(m):
            return m.channel == ctx.channel and m.author.id in [duel.player1, duel.player2]

        while True:
            msg = await self.bot.wait_for('message', check=check)
            damage = await self.process_message(msg, duel)
            opponent_id = duel.player1 if msg.author.id == duel.player2 else duel.player2
            duel.adjust_health(opponent_id, damage)

            embed = discord.Embed(
                title="Duel Status",
                description=f"{self.bot.get_user(duel.player1).mention} vs {self.bot.get_user(duel.player2).mention}",
                color=discord.Color.red()
            )
            embed.add_field(name=f"{self.bot.get_user(duel.player1).display_name} HP", value=duel.health[duel.player1])
            embed.add_field(name=f"{self.bot.get_user(duel.player2).display_name} HP", value=duel.health[duel.player2])
            await ctx.send(embed=embed)

            winner_id = duel.get_winner()
            if winner_id:
                winner = self.bot.get_user(winner_id)
                await ctx.send(f"{winner.mention} wins the duel!")
                activity_tracker = self.bot.get_cog('ActivityTracker')
                activity_tracker.update_user_activity(winner, points=DUEL_WIN_POINTS, coins=DUEL_WIN_COINS)
                await ctx.send(f"{winner.mention} has been awarded {DUEL_WIN_POINTS} points and {DUEL_WIN_COINS} {coin_icon}! Total {coin_icon}: {activity_tracker.activity_data[str(winner.id)]['coins']}")
                
                del self.duels[duel.player1]
                del self.duels[duel.player2]
                return

    async def process_message(self, msg, duel):
        words = msg.content.split()
        valid_words = []
        for word in words:
            if await duel.is_valid_word(word):
                if word.lower() not in duel.used_words:
                    valid_words.append(word)
                else:
                    await msg.channel.send(f"The word '{word}' has already been used.")
            else:
                await msg.channel.send(f"The word '{word}' is not a valid word.")
        return duel.calculate_damage(valid_words)


.\bot\games\game_manager.py
import discord, asyncio, json, logging
from discord.ext import commands
from duel import Duel
from blackjack import BlackjackGame
from lottery import Lottery
from poker import PokerGame
from settings.settings import load_settings

logging.basicConfig(level=logging.INFO)

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

BOT_TESTING_MODE = game_settings['game']['bot_testing_mode']  # Whether bot testing mode is enabled
if BOT_TESTING_MODE:
    POKER_MIN_PLAYERS = 1
    POKER_MAX_PLAYERS = 1

settings = load_settings()
coin_icon = settings['coin_icon']

TICKET_COST = 100

class CommandHandler(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.duels = {}
        self.blackjack_games = {}
        self.poker_games = {}
        self.lottery = Lottery(bot)

    @commands.command(name='challenge')
    async def challenge(self, ctx, opponent_name: str):
        opponent = self.find_member(ctx.guild, opponent_name)
        if opponent is None:
            await ctx.send(f"Could not find a unique member with the name '{opponent_name}'. Please specify a more exact name or use mention.")
            return

        if ctx.author.id in self.duels or opponent.id in self.duels:
            await ctx.send("One of the players is already in a duel!")
            return

        self.duels[ctx.author.id] = Duel(ctx.author.id, opponent.id)
        self.duels[opponent.id] = self.duels[ctx.author.id]

        if opponent == self.bot.user and BOT_TESTING_MODE:
            await self.accept_duel(ctx)
        else:
            await ctx.send(f"{ctx.author.mention} has challenged {opponent.mention} to a duel! Use `!accept` to accept the challenge.")

    @commands.command(name='accept')
    async def accept_duel(self, ctx):
        if ctx.author.id not in self.duels:
            return

        duel = self.duels[ctx.author.id]
        duel.generate_letter()
        await ctx.send(f"The duel between {self.bot.get_user(duel.player1).mention} and {self.bot.get_user(duel.player2).mention} has begun! The challenge is to type as many words as you can that start with '{duel.letter}'. The duel will continue until one player's health reaches zero. Type your words separated by spaces.")

        await self.handle_duel(ctx, duel)

    @commands.command(name='blackjack')
    async def blackjack(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(ctx.author.id))
        current_coins = stats.get('coins', 0)

        await ctx.send(f"You have {current_coins} {coin_icon}. How many {coin_icon} would you like to bet?")

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content.isdigit()

        while True:
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=30.0)
                bet = int(msg.content)
                if bet > 0 and bet <= current_coins:
                    break
                else:
                    await ctx.send(f"Invalid response. Bet must be a positive number and less than or equal to your balance ({current_coins} {coin_icon}). You have 30 seconds to respond accurately.")
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond! Please use !blackjack again.")
                return

        game = BlackjackGame(ctx.author, self.bot)
        await game.start_game(bet)
        self.blackjack_games[ctx.author.id] = game

        await game.send_hand(ctx)

    @commands.command(name='hit')
    async def hit(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.hit(ctx)

    @commands.command(name='stand')
    async def stand(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.stand(ctx)

    @commands.command(name='peek')
    async def peek(self, ctx):
        # Ensure the author is part of an active poker game
        for game in self.poker_games.values():
            if ctx.author in game.players:
                await game.peek(ctx)
                return
        await ctx.send(f"{ctx.author.mention}, you are not part of an active poker game!")

    def find_member(self, guild, name):
        members = [member for member in guild.members if member.display_name.lower() == name.lower()]
        if len(members) == 1:
            return members[0]
        return None
    
    @commands.command(name='poker')
    async def start_poker(self, ctx):
        if ctx.author.id in self.poker_games:
            await ctx.send("You are already in a game!")
            return

        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(ctx.author.id))
        current_coins = stats.get('coins', 0)

        await ctx.send(f"You have {current_coins} {coin_icon}. How many {coin_icon} would you like to set as the buy-in amount for the game?")

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content.isdigit()

        while True:
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=30.0)
                buy_in = int(msg.content)
                if buy_in > 0 and buy_in <= current_coins:
                    break
                else:
                    await ctx.send(f"Invalid response. Buy-in must be a positive number and less than or equal to your balance ({current_coins} {coin_icon}). You have 30 seconds to respond accurately.")
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond! Please use !poker again.")
                return

        game = PokerGame(ctx, self.bot, buy_in)
        self.poker_games[ctx.author.id] = game
        try:
            await game.start_game()
        finally:
            del self.poker_games[ctx.author.id]

        @commands.command(name='join poker')
        async def join_poker(self, ctx):
            if ctx.author.id not in self.poker_games:
                await ctx.send("You need to start a game first using !poker.")
                return
            game = self.poker_games[ctx.author.id]
            await game.collect_players()

    @commands.command(name='peek')
    async def peek(self, ctx):
        # Ensure the author is part of an active poker game
        for game in self.poker_games.values():
            if ctx.author in game.players:
                await game.peek(ctx)
                return
        await ctx.send(f"{ctx.author.mention}, you are not part of an active poker game!")

    @commands.command(name='forcestart')
    async def forcestart(self, ctx):
        # Ensure the author is part of an active poker game
        game = self.poker_games.get(ctx.author.id)
        if not game:
            await ctx.send(f"{ctx.author.mention}, you are not hosting any poker game!")
            return

        if len(game.players) >= game.POKER_MIN_PLAYERS:
            await ctx.send("Minimum player requirements met. Starting the game now!")
            await game.start_game()
        else:
            await ctx.send(f"Not enough players to start the game. Minimum required is {game.POKER_MIN_PLAYERS}.")

    # Command to enter the lottery
    @commands.command(name='enterlottery')
    async def enter_lottery(self, ctx):
        user_id = str(ctx.author.id)

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        current_lottery_pot = self.lottery.get_current_lottery_pot()
        await ctx.send(f"Each ticket is worth {TICKET_COST} {coin_icon}. How many tickets would you like to buy? Current Lottery Pot: {current_lottery_pot} {coin_icon}")

        try:
            msg = await self.bot.wait_for('message', check=check, timeout=50.0)
            num_tickets = int(msg.content)
            cost = num_tickets * TICKET_COST

            await ctx.send(f"Are you sure you want to purchase {num_tickets} tickets for {cost} {coin_icon}? Say `!accept` if you wish to proceed.")

            msg = await self.bot.wait_for('message', check=check, timeout=50.0)
            if msg.content.lower() == '!accept':
                activity_tracker = self.bot.get_cog('ActivityTracker')
                user_data = activity_tracker.get_statistics(user_id)
                user_balance = user_data.get('coins', 0)

                if user_balance < cost:
                    await ctx.send(f"{ctx.author.mention}, you do not have enough {coin_icon} to buy {num_tickets} tickets. Your current balance is {user_balance} {coin_icon}.")
                    return

                activity_tracker.update_user_activity(ctx.author, coins=-cost)
                self.lottery.add_tickets(user_id, num_tickets)
                total_tickets = self.lottery.load_lottery_data()['participants'][user_id]

                current_lottery_pot = self.lottery.get_current_lottery_pot()
                await ctx.send(f"Purchase Successful. Check back at 11 PM EST for the lottery results. You now have a total of {total_tickets} tickets in the lottery. \nYour {coin_icon} Balance: {user_balance - cost} {coin_icon}, Current Lottery Pot: {current_lottery_pot} {coin_icon}")
            else:
                await ctx.send("Purchase canceled.")
        except ValueError:
            await ctx.send("Invalid number of tickets.")
        except asyncio.TimeoutError:
            await ctx.send("You took too long to respond.")

    @commands.command(name='lotterystatus')
    async def lottery_status(self, ctx):
        data = self.lottery.load_lottery_data()
        total_tickets = data['total_tickets']
        participants = len(data['participants'])
        current_lottery_pot = self.lottery.get_current_lottery_pot()
        await ctx.send(f"__**Current Lottery Status:**__\nTotal Tickets Sold: {total_tickets}\nNumber of Participants: {participants}\nCurrent Lottery Pot: {current_lottery_pot} {coin_icon}")


async def setup(bot):
    await bot.add_cog(CommandHandler(bot))


.\bot\games\lottery.py
import os, random, json, math, asyncio, logging
from datetime import datetime, timedelta, timezone
from discord.ext import commands, tasks
from settings.settings import load_settings

logging.basicConfig(level=logging.INFO)

TICKET_COST = 100

settings = load_settings()
coin_icon = settings['coin_icon']

class Lottery:
    def __init__(self, bot):
        self.bot = bot  # Set the bot for the lottery.
        self.check_lottery_draw.start()  # Starting the task that checks the lottery draw time.
        self.initial_pot = 5000  # Initial pot amount
        self.LOTTERY_FILE = 'data/games/lottery/lottery.json'

    def load_lottery_data(self):
        if not os.path.exists(self.LOTTERY_FILE):
            data = {'total_tickets': 0, 'participants': {}, 'current_pot': self.initial_pot}
            self.save_lottery_data(data)
        else:
            with open(self.LOTTERY_FILE, 'r') as file:
                data = json.load(file)
                if 'total_tickets' not in data:
                    data['total_tickets'] = 0
                if 'participants' not in data:
                    data['participants'] = {}
                if 'current_pot' not in data:
                    data['current_pot'] = self.initial_pot
        return data

    def save_lottery_data(self, data):
        with open(self.LOTTERY_FILE, 'w') as file:
            json.dump(data, file, indent=4)

    def get_current_lottery_pot(self):
        data = self.load_lottery_data()
        return data.get('current_pot', self.initial_pot)

    def add_tickets(self, user_id, ticket_count):
        data = self.load_lottery_data()
        if user_id not in data['participants']:
            data['participants'][user_id] = 0
        data['participants'][user_id] += ticket_count
        data['total_tickets'] += ticket_count
        data['current_pot'] += ticket_count * TICKET_COST
        self.save_lottery_data(data)

    def draw_winner(self):
        data = self.load_lottery_data()
        if data['total_tickets'] > 0:
            tickets = [user_id for user_id, count in data['participants'].items() for _ in range(count)]
            winner = random.choice(tickets)
            current_pot = data['current_pot']
            data['participants'] = {}
            data['total_tickets'] = 0
            data['current_pot'] = self.initial_pot
            self.save_lottery_data(data)
            return winner, current_pot
        return None, 0

    @tasks.loop(minutes=1)
    async def check_lottery_draw(self):
        channel = self.bot.get_channel(1252055670778368013)
        now = datetime.now(timezone.utc)
        logging.info(f"Current UTC time: {now}")
        if now.hour == 3 and now.minute == 0:
            logging.info("It's time to announce the winner!")
            await self.announce_winner()
        elif (now.hour == 19 and now.minute == 0) or (now.hour == 1 and now.minute == 0): 
            await channel.send(f"Remember that 11 PM, the lottery will be drawn!  Type `!enterlottery` to buy tickets.")
            await channel.send(f"Current Pot: {self.initial_plot} {coin_icon}")

    async def announce_winner(self):
        data = self.load_lottery_data()
        if not data['participants']:
            logging.info("No participants in the lottery.")
            return

        channel = self.bot.get_channel(1252055670778368013)

        message = await channel.send("Today's Lottery Winner: ...")

        start_time = datetime.now(timezone.utc)
        duration = 60
        end_time = start_time + timedelta(seconds=duration)

        initial_sleep_time = 1
        final_sleep_time = 3
        total_steps = 1000

        current_step = 0
        while datetime.now(timezone.utc) < end_time:
            participant = random.choice(list(data['participants'].items()))
            user_id, tickets = participant
            ticket_number = random.choice(list(range(tickets)))
            member = await self.bot.fetch_user(user_id)
            await message.edit(content=f"Picking Lottery Winner... {member.display_name} (Ticket #{ticket_number})")

            sleep_time = initial_sleep_time + (final_sleep_time - initial_sleep_time) * (1 - math.exp(-current_step / total_steps))
            await asyncio.sleep(sleep_time)

            current_step += 1

        winner_id, current_pot = self.draw_winner()
        winner = await self.bot.fetch_user(winner_id)
        await message.edit(content=f"Today's Lottery Winner: {winner.display_name} (Ticket #{ticket_number})")
        await channel.send(content=f"{winner.display_name} has won {current_pot} {coin_icon}!")

        # Update the winner's activity
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if winner:
            activity_tracker.update_user_activity(winner, coins=current_pot)
            await channel.send(content=f"Congratulations {winner.display_name}! Your new balance is {activity_tracker.get_statistics(str(winner.id)).get('coins', 0)} {coin_icon}.")

.\bot\games\poker.py
import discord, random, os, asyncio, itertools, json
from discord.ext import commands
from PIL import Image
from settings.settings import load_settings
from datetime import timedelta

with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

settings = load_settings()
coin_icon = settings['coin_icon']

# Poker settings
POKER_WIN_POINTS = game_settings['poker']['win_points']
POKER_PREFLOP_MAX_BET = game_settings['poker']['preflop_max_bet']
POKER_MIN_PLAYERS = game_settings['poker']['min_players']
POKER_MAX_PLAYERS = game_settings['poker']['max_players']
DUMP_IMAGES_FOLDER_POKER = 'utils/images/pokerdump'

# Game Settings
BOT_TESTING_MODE = game_settings['game']['bot_testing_mode']  # Whether bot testing mode is enabled
if BOT_TESTING_MODE:
    POKER_MIN_PLAYERS = 1
    POKER_MAX_PLAYERS = 1

class PokerGame:
    def __init__(self, ctx, bot, buy_in):
        self.bot = bot  # The bot instance
        self.ctx = ctx  # The context from Discord
        self.buy_in = buy_in  # The buy-in amount for the game
        self.players = []  # List to store players
        self.betting_order = []  # Order in which players will bet
        self.current_bet = 0  # Current bet amount
        self.pot = 0  # Total pot amount
        self.current_player_index = 0  # Index to track the current player
        self.community_cards = []  # List to store community cards
        self.player_hands = {}  # Dictionary to store each player's hand
        self.player_balances = {}  # Dictionary to store each player's balance
        self.all_in_players = set()  # Set to track players who are all-in
        self.DECK_OF_CARDS_FOLDER = 'utils/images/deckofcards'  # Folder for card images
        self.DUMP_IMAGES_FOLDER = 'utils/images/pokerdump'  # Folder for dumping images
        self.game_cancelled = False  # Flag to check if the game is cancelled

    async def start_game(self):
        await self.collect_players()  # Collect players for the game
        if len(self.players) < POKER_MIN_PLAYERS:  # Check if there are enough players
            await self.ctx.send("Not enough players to start the game. Refunding buy-ins.")
            await self.refund_buy_ins()  # Refund the buy-ins if not enough players
            return

        self.betting_order = self.players[:]  # Set the betting order to the list of players
        random.shuffle(self.betting_order)  # Shuffle the betting order
        await self.deal_cards()  # Deal the initial cards to the players
        await self.betting_round(pre_flop=True)  # Run the first betting round (pre-flop)
        await self.reveal_community_cards(3)  # Reveal the flop (3 community cards)
        await self.betting_round()  # Run the second betting round
        await self.reveal_community_cards(1)  # Reveal the turn (1 community card)
        await self.betting_round()  # Run the third betting round
        await self.reveal_community_cards(1)  # Reveal the river (1 community card)
        await self.betting_round()  # Run the final betting round
        await self.showdown()  # Determine the winner and show the final hands

    async def collect_players(self):
        await self.ctx.send(f"A new poker game is starting with a buy-in of {self.buy_in} coins! Type `!join poker` to join. You have 2 minutes to join. The host can type `!cancel poker` to cancel the game or `!forcestart` to start the game if the minimum player requirements are met.")

        activity_tracker = self.bot.get_cog('ActivityTracker')
        player_coins = activity_tracker.get_statistics(str(self.ctx.author.id)).get('coins', 0)
        if player_coins < self.buy_in:
            await self.ctx.send(f"{self.ctx.author.mention}, you do not have enough coins to start the game.")
            return

        self.players.append(self.ctx.author)
        self.player_balances[self.ctx.author] = self.buy_in
        activity_tracker.update_user_activity(self.ctx.author, coins=-(self.buy_in))
        await self.display_player_list()

        def join_check(m):
            return m.content.lower() == "!join poker" and m.channel == self.ctx.channel

        def cancel_check(m):
            return m.content.lower() == "!cancel poker" and m.channel == self.ctx.channel and m.author == self.ctx.author

        def forcestart_check(m):
            return m.content.lower() == "!forcestart" and m.channel == self.ctx.channel and m.author == self.ctx.author

        end_time = discord.utils.utcnow() + timedelta(minutes=2)
        warning_times = [60, 30, 10]  # Times to send warnings in seconds
        sent_warnings = set()

        while True:
            remaining_time = (end_time - discord.utils.utcnow()).total_seconds()

            # Send warning messages
            for warning in warning_times:
                if remaining_time <= warning and warning not in sent_warnings:
                    await self.ctx.send(f"{int(warning)} seconds remaining to join the game!")
                    sent_warnings.add(warning)

            if remaining_time <= 0:
                break

            try:
                done, pending = await asyncio.wait(
                    [asyncio.create_task(self.bot.wait_for('message', check=join_check)), 
                    asyncio.create_task(self.bot.wait_for('message', check=cancel_check)),
                    asyncio.create_task(self.bot.wait_for('message', check=forcestart_check))],
                    timeout=1,
                    return_when=asyncio.FIRST_COMPLETED
                )

                if not done:
                    continue

                msg = done.pop().result()

                if msg.content.lower() == "!cancel poker":
                    await self.cancel_game()
                    return

                if msg.content.lower() == "!forcestart":
                    if len(self.players) >= 2:
                        await self.ctx.send("Minimum player requirements met. Starting the game now!")
                        break
                    else:
                        await self.ctx.send(f"Not enough players to start the game. Minimum required is 2.")
                        continue

                if msg.author in self.players:
                    await self.ctx.send(f"{msg.author.mention}, you are already in the game!")
                    continue

                player_coins = activity_tracker.get_statistics(str(msg.author.id)).get('coins', 0)
                if player_coins < self.buy_in:
                    await self.ctx.send(f"{msg.author.mention}, you do not have enough coins to join the game.")
                    continue

                self.players.append(msg.author)
                self.player_balances[msg.author] = self.buy_in
                activity_tracker.update_user_activity(msg.author, coins=-self.buy_in)
                await self.ctx.send(f"{msg.author.mention} has joined the Poker session!")
                await self.display_player_list()

                if len(self.players) > 8:
                    await self.ctx.send(f"MAX PLAYER EXCEEDED ERROR! The game has been cancelled.")
                    await self.cancel_game()
                    return

                if len(self.players) == 8:
                    await self.ctx.send("Maximum number of players reached. Starting the game now!")
                    break
            except asyncio.TimeoutError:
                continue

        if len(self.players) < 2:
            await self.ctx.send("Not enough players to start the game. Refunding buy-ins.")
            for player in self.players:
                activity_tracker.update_user_activity(player, coins=self.buy_in)
                await self.ctx.send(f"{player.mention}, you have been refunded {self.buy_in} coins.")
            return

        await self.deal_cards()

    async def cancel_game(self):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        for player in self.players:
            activity_tracker.update_user_activity(player, coins=self.buy_in)
            await self.ctx.send(f"{player.mention}, you have been refunded {self.buy_in} coins.")
        await self.ctx.send("The poker game has been cancelled by the host.")

    async def deal_cards(self):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        for player in self.players:
            self.player_hands[player] = [self.deck.pop(), self.deck.pop()]
            await self.send_hand(self.ctx, player)
    
    async def send_hand(self, ctx, player, reveal=False):
        hand = self.player_hands[player]
        card_images = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(card_images, f'poker_{player.id}_hand.png')
        file = discord.File(concatenated_image_path, filename="hand.png")

        if reveal:
            embed = discord.Embed(title=f"{player.display_name}'s Hand")
        else:
            embed = discord.Embed(title="Your Hand")
        
        embed.set_image(url="attachment://hand.png")
        await ctx.send(file=file, embed=embed, ephemeral=True)

    async def get_card_image(self, card):
            card_value = card[:-1]
            card_suit = card[-1].upper()
            if card_value == '10':
                card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, '10', f'10{card_suit}.png')
            else:
                card_value = card_value[0].upper()
                card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, card_value, f'{card_value}{card_suit}.png')
            return card_image_path
    
    async def concatenate_images(self, image_paths, filename):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        total_width = sum(widths)
        max_height = max(heights)
        new_image = Image.new('RGB', (total_width, max_height))

        x_offset = 0
        for img in images:
            new_image.paste(img, (x_offset, 0))
            x_offset += img.size[0]

        output_path = os.path.join(self.DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path

    async def betting_round(self, pre_flop=False):
        self.current_bet = 0 if pre_flop else self.current_bet
        for player in self.betting_order:
            if player in self.all_in_players:
                continue
            await self.prompt_player_action(player)

    async def prompt_player_action(self, player):
        if self.current_bet == 0:
            await self.ctx.send(f"{player.mention}, it's your turn. You can `!check`, `check`, `!fold`, `fold`, `!raise`, `raise`, or `!allin`, `allin`. Your balance: {self.player_balances[player]} {coin_icon}. Pot: {self.pot} {coin_icon}.")
            valid_actions = ['!check', 'check', '!fold', 'fold', '!raise', 'raise', '!allin', 'allin']
        else:
            await self.ctx.send(f"{player.mention}, it's your turn. You can `!call`, `call`, `!fold`, `fold`, `!raise`, `raise`, or `!allin`, `allin`. Your balance: {self.player_balances[player]} {coin_icon}. Pot: {self.pot} {coin_icon}.")
            valid_actions = ['!call', 'call', '!fold', 'fold', '!raise', 'raise', '!allin', 'allin']

        def check(m):
            return m.author == player and m.channel == self.ctx.channel and m.content.lower() in valid_actions

        try:
            msg = await self.bot.wait_for('message', check=check, timeout=120)
            action = msg.content.lower().lstrip('!')
            if action == 'check':
                await self.check(player)
            elif action == 'call':
                await self.call(player)
            elif action == 'fold':
                await self.fold(player)
            elif action == 'raise':
                await self.raise_bet(player)
            elif action == 'allin':
                await self.allin(player)
        except asyncio.TimeoutError:
            await self.fold(player)

    async def check(self, player):
        await self.ctx.send(f"{player.mention} checks.")

    async def call(self, player):
        call_amount = self.current_bet - self.player_balances[player]
        if self.player_balances[player] < call_amount:
            await self.allin(player)
        else:
            self.player_balances[player] -= call_amount
            self.pot += call_amount
            await self.ctx.send(f"{player.mention} calls {call_amount} coins. Pot is now {self.pot} {coin_icon}.")

    async def fold(self, player):
        self.betting_order.remove(player)
        await self.ctx.send(f"{player.mention} folds.")

    async def raise_bet(self, player):
        await self.ctx.send(f"{player.mention}, how much would you like to raise? Type an amount or `!allin` or `allin`.")
        def check(m):
            return m.author == player and m.channel == self.ctx.channel
        try:
            msg = await self.bot.wait_for('message', check=check, timeout=120)
            if msg.content.lower().lstrip('!') == 'allin':
                await self.allin(player)
            else:
                try:
                    raise_amount = int(msg.content)
                    if raise_amount > self.player_balances[player]:
                        await self.ctx.send(f"You don't have enough {coin_icon} to raise that amount.")
                        await self.raise_bet(player)
                    else:
                        self.current_bet += raise_amount
                        self.player_balances[player] -= raise_amount
                        self.pot += raise_amount
                        await self.ctx.send(f"{player.mention} raises by {raise_amount} {coin_icon}. Current bet is now {self.current_bet} {coin_icon}. Pot is now {self.pot} {coin_icon}.")
                except ValueError:
                    await self.ctx.send(f"{msg.content} is not a valid amount. Please enter a valid number or type `!allin` or `allin`.")
                    await self.raise_bet(player)
        except asyncio.TimeoutError:
            await self.fold(player)
            await self.fold(player)

    async def allin(self, player):
        allin_amount = self.player_balances[player]
        self.all_in_players.add(player)
        self.player_balances[player] = 0
        self.pot += allin_amount
        await self.ctx.send(f"{player.mention} goes all-in with {allin_amount} {coin_icon}. Pot is now {self.pot} {coin_icon}.")

    async def reveal_community_cards(self, num):
        for _ in range(num):
            self.deck.pop()  # Burn card
            self.community_cards.append(self.deck.pop())
        cards = [await self.get_card_image(card) for card in self.community_cards]
        concatenated_image_path = await self.concatenate_images(cards, 'community_cards.png')
        file = discord.File(concatenated_image_path, filename="community_cards.png")

        embed = discord.Embed(title="Community Cards")
        embed.set_image(url="attachment://community_cards.png")
        await self.ctx.send(file=file, embed=embed)

    async def showdown(self):
        await self.ctx.send("Showdown! Revealing hands...")
        hands = []
        for player in self.betting_order:
            hand = self.player_hands[player] + self.community_cards
            best_hand = self.get_best_hand(hand)
            hands.append((player, best_hand))
            await self.reveal_hand(player, best_hand)

        if not hands:
            await self.ctx.send("No hands to compare, ending showdown.")
            return

        winner = max(hands, key=lambda h: self.hand_rank(h[1]))[0]
        await self.ctx.send(f"{winner.mention} wins the pot of {self.pot} {coin_icon}!")

    async def display_player_list(self):
        if self.players:
            player_list = "\n".join([player.mention for player in self.players])
            embed = discord.Embed(title="Current Player List", description=player_list, color=discord.Color.blue())
            await self.ctx.send(embed=embed)
        else:
            await self.ctx.send("No players have joined yet.")

    def hand_rank(self, hand):
        """
        Determine the rank of a given poker hand.

        :param hand: List of 5 card strings (e.g., ['2H', '3D', '5S', '9C', 'KD'])
        :return: Tuple representing the hand rank and its components for comparison
        """

        # Define card ranks and their corresponding values
        ranks = '2345678910JQKA'
        values = {r: i for i, r in enumerate(ranks.split(), start=2)}

        # Get the numeric value of each card in the hand
        hand_ranks = sorted(
            [values['10'] if card[:-1] == '10' else values[card[0]] for card in hand],
            reverse=True
        )

        # Check for flush (all cards have the same suit)
        is_flush = len(set(card[-1] for card in hand)) == 1

        # Check for straight (consecutive card values)
        is_straight = len(set(hand_ranks)) == 5 and (hand_ranks[0] - hand_ranks[-1] == 4)

        # Special case: A-5 straight
        if hand_ranks == [14, 5, 4, 3, 2]:
            hand_ranks = [5, 4, 3, 2, 1]
            is_straight = True

        # Count the occurrences of each rank in the hand
        rank_counter = {r: hand_ranks.count(r) for r in hand_ranks}
        rank_values = sorted(((count, rank) for rank, count in rank_counter.items()), reverse=True)

        # Determine the rank of the hand
        if is_straight and is_flush:
            return (8, hand_ranks[0])  # Straight flush
        elif rank_values[0][0] == 4:
            return (7, rank_values[0][1], rank_values[1][1])  # Four of a kind
        elif rank_values[0][0] == 3 and rank_values[1][0] == 2:
            return (6, rank_values[0][1], rank_values[1][1])  # Full house
        elif is_flush:
            return (5, hand_ranks)  # Flush
        elif is_straight:
            return (4, hand_ranks[0])  # Straight
        elif rank_values[0][0] == 3:
            return (3, rank_values[0][1], hand_ranks)  # Three of a kind
        elif rank_values[0][0] == 2 and rank_values[1][0] == 2:
            return (2, rank_values[0][1], rank_values[1][1], hand_ranks)  # Two pair
        elif rank_values[0][0] == 2:
            return (1, rank_values[0][1], hand_ranks)  # One pair
        else:
            return (0, hand_ranks)  # High card
        
    def get_best_hand(self, hand):
        """
        From the 7 cards, choose the best 5-card hand.
        """
        all_combinations = itertools.combinations(hand, 5)
        best_hand = max(all_combinations, key=self.hand_rank)
        return best_hand

    async def reveal_hand(self, player, hand):
        cards = [await self.get_card_image(card) for card in hand]
        embed = discord.Embed(title=f"{player.display_name}'s Hand")
        for card in cards:
            embed.set_image(url=card)
        await self.ctx.send(embed=embed)

.\bot\status\offline.py
import aiohttp
import asyncio
import pytz
from datetime import datetime, timedelta
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    def get_estimated_time_back_up(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        estimated_time = now + timedelta(hours=16)
        hour = estimated_time.hour if estimated_time.hour <= 12 else estimated_time.hour - 12
        period = "AM" if estimated_time.hour < 12 else "PM"
        formatted_time = f"{hour}:{estimated_time.strftime('%M')} {period} EST"
        return estimated_time.strftime("%m/%d/%Y"), formatted_time

    def get_most_recent_script(self):
        scripts_directory = 'bot'
        scripts = [os.path.join(root, file) for root, _, files in os.walk(scripts_directory) for file in files if file.endswith('.py')]
        if not scripts:
            return "Unknown Script", "No recent updates detected"

        most_recent_script = max(scripts, key=lambda x: os.path.getmtime(x))
        script_name = os.path.basename(most_recent_script).replace('.py', '').capitalize()
        return script_name, f"Developing/Fixing the {script_name} feature"

    async def update_status_offline(self):
        current_date, current_time = self.get_current_time()
        estimated_date, estimated_time_back_up = self.get_estimated_time_back_up()
        script_name, reasoning = self.get_most_recent_script()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** OFFLINE

**Reasoning:** {reasoning}
**Estimated Date Back Up:** {estimated_date}
**Estimated Time Back Up:** {estimated_time_back_up}
**Impact on Users:** Inability to use bot
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to OFFLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_offline()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_offline()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\online.py
import aiohttp
import asyncio
import pytz
from datetime import datetime
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    async def update_status_online(self):
        current_date, current_time = self.get_current_time()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** ONLINE

**Reasoning:** Bot started successfully
**Estimated Date Back Up:** N/A
**Estimated Time Back Up:** N/A
**Impact on Users:** Fully operational
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to ONLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_online()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_online()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\setup.py
from . import offline, online

async def setup(bot):
    pass  # No need to add any cogs or extensions here as the status scripts are executed separately


.\settings\settings.py
import json 
import os

def load_settings():
    # Get the current directory of the settings.py file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    # Construct the path to the settings.json file
    settings_path = os.path.join(current_dir, 'json', 'settings.json')
    # Open and load the settings.json file
    with open(settings_path, 'r', encoding='utf-8') as f:
        settings = json.load(f)
    return settings

.\utils\graphics.py
import matplotlib.pyplot as plt  # Import Matplotlib for creating visualizations
import matplotlib.patches as patches  # Import patches to draw shapes
import requests  # Import requests to download images from the web
from PIL import Image, ImageDraw, ImageOps  # Import Pillow to handle image processing
from io import BytesIO  # Import BytesIO to handle image data in memory
import numpy as np  # Import NumPy for numerical operations
import os  # Import os to handle file paths

# Function to generate an image showing the user's level information.
def generate_level_image(username, level, progress, points, next_level, avatar_url):
    try:
        # Download the avatar image from the provided URL
        response = requests.get(avatar_url)
        avatar = Image.open(BytesIO(response.content)).resize((250, 225))  # Resize avatar to 225x225 pixels

        shadow_offset = 2  # Offset for the shadow
        font_name = 'Verdana'

        # Create a new figure (canvas)
        fig, ax = plt.subplots(figsize=(7, 2))  # Set figure size
        fig.patch.set_facecolor((255/255, 127/255, 80/255))  # Set figure background color (light pink)
        ax.set_facecolor((173/255, 216/255, 230/255))  # Set axis background color (light blue)

        ax.set_xlim(0, 1000)  # Set x-axis limit
        ax.set_ylim(0, 250)  # Set y-axis limit
        ax.axis('off')  # Hide axes

        # Draw the avatar image on the canvas
        plt.imshow(avatar, aspect='auto', extent=(10, 10 + avatar.size[0], 12.5, 12.5 + avatar.size[1]))

        font_properties1 = {'family': font_name, 'weight': 'extra bold', 'size': 25}  # Font properties for username
        font_properties2 = {'family': font_name, 'weight': 'bold', 'size': 15}  # Font properties for points text
        font_properties3 = {'family': font_name, 'weight': 'extra bold', 'size': 20}

        # Draw the username text next to the avatar
        plt.text(275 + shadow_offset, 200 - shadow_offset, username, fontdict=font_properties1, color='black', ha='left', va='center')
        plt.text(275, 200, username, fontdict=font_properties1, color='white', ha='left', va='center')
        # Draw the points text
        plt.text(275 + shadow_offset, 150 - shadow_offset, f"Points: {points}", fontdict=font_properties2, color='black', ha='left', va='center')
        plt.text(275, 150, f"Points: {points}", fontdict=font_properties2, color='white', ha='left', va='center')

        # Define the position and size of the progress bar
        canvas_width = 1000  # Width of the canvas
        bar_width = 450  # Width of the progress bar
        bar_height = 70  # Height of the progress bar
        bar_x = ((canvas_width - bar_width + 225) / 2) + 10  # X-coordinate of the progress bar (centered horizontally)
        bar_y = 20  # Y-coordinate of the progress bar

        # Draw the background of the progress bar
        ax.add_patch(patches.Rectangle((bar_x, bar_y), bar_width, bar_height, color=(255/255, 255/255, 255/255), alpha=0.3))

        # Calculate the width of the filled part of the progress bar
        fill_width = (progress / 100) * bar_width
        # Draw the filled part of the progress bar
        ax.add_patch(patches.Rectangle((bar_x, bar_y), fill_width, bar_height, color=(76/255, 175/255, 80/255)))

        # Draw the current level text
        plt.text(bar_x - 10 + shadow_offset, (bar_y + bar_height / 2) - 12.5 - shadow_offset, f"{level}", fontdict=font_properties1, color='black', ha='right', va='center')
        plt.text(bar_x - 10, (bar_y + bar_height / 2) - 12.5, f"{level}", fontdict=font_properties1, color='white', ha='right', va='center')

        plt.text((bar_x + (bar_width / 2))  + shadow_offset, (bar_y + (bar_height / 2)) - shadow_offset, f"{progress:.2f}%", fontdict=font_properties3, color='black', ha='center', va='center')
        plt.text((bar_x + (bar_width / 2)), (bar_y + (bar_height / 2)), f"{progress:.2f}%", fontdict=font_properties3, color='white', ha='center', va='center')

        # Draw the next level text
        plt.text(bar_x + bar_width + 10 + shadow_offset, (bar_y + bar_height / 2) - 12.5 - shadow_offset, f"{next_level}", fontdict=font_properties1, color='black', ha='left', va='center')
        plt.text(bar_x + bar_width + 10, (bar_y + bar_height / 2) - 12.5, f"{next_level}", fontdict=font_properties1, color='white', ha='left', va='center')

        # Save the figure to a BytesIO object
        image_buffer = BytesIO()
        plt.savefig(image_buffer, format='png', bbox_inches='tight', pad_inches=0, dpi=100)
        plt.close()
        image_buffer.seek(0)  # Move the cursor to the start of the BytesIO object

        return image_buffer

    except Exception as e:
        print(f"Error in generate_level_image: {e}")
        return None

def generate_statistics_visualization(stats):
    labels = ['Messages Sent', 'Minutes in Voice', 'Minutes Online']  # Labels for the bars
    user_values = [stats.get('messages_sent', 0), stats.get('minutes_in_voice', 0), stats.get('minutes_online', 0)]  # User's stats
    server_averages = [100, 50, 300]  # Server average stats (dummy values, should be replaced with real data)

    x = np.arange(len(labels))  # X-axis positions for the bars

    fig, ax = plt.subplots()  # Create a new figure and axis
    ax.bar(x - 0.2, user_values, width=0.4, label='User')  # Draw user bars
    ax.bar(x + 0.2, server_averages, width=0.4, label='Server Average')  # Draw server average bars

    ax.set_xlabel('Activity')  # Set x-axis label
    ax.set_ylabel('Count')  # Set y-axis label
    ax.set_title('User Activity vs Server Average')  # Set title
    ax.set_xticks(x)  # Set x-axis ticks
    ax.set_xticklabels(labels)  # Set x-axis labels
    ax.legend()  # Add legend

    plt.tight_layout()  # Adjust layout to fit everything
    image_path = 'utils/images/statistics_visualization.png'  # Define the file path to save the image
    plt.savefig(image_path)  # Save the figure to a file
    plt.close()  # Close the figure to free up memory

    return image_path  # Return the path to the generated image


.\utils\__init__.py


