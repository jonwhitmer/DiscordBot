./
    main.py
    project_summary.txt
    requirements.txt
    resetdata.py
    summary.py
    test.py
    .git/
        COMMIT_EDITMSG
        config
        description
        FETCH_HEAD
        HEAD
        index
        ORIG_HEAD
        packed-refs
        hooks/
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-applypatch.sample
            pre-commit.sample
            pre-merge-commit.sample
            pre-push.sample
            pre-rebase.sample
            pre-receive.sample
            prepare-commit-msg.sample
            push-to-checkout.sample
            sendemail-validate.sample
            update.sample
        info/
            exclude
        logs/
            HEAD
            refs/
                heads/
                    dev
                    main
                    testing
                    wip
                remotes/
                    origin/
                        dev
                        features
                        main
                        Source-Code-Implementation
                        testing
                        wip
        objects/
            00/
                4de6c8f192f0ddc15b3acc4a7fa25b6b6fa488
                9355b168b69030b3502769523fa85741b3f26c
                f109da7e9a586aea31ad808949b0d190c21cd6
            01/
                2f0c5d49647e67d74331189a6fa7f816cb07c0
                e2314bc19a410bf73c2247c77b443f6fc42aa2
            04/
                5ef1c35d3a664f0fad826f985bcf38d7204a76
            05/
                f497cf944da16db531e09a29aa0016b0dd3d72
            06/
                80a8c755d2ff3a9548617ddd4ae114bd792316
                d3fc6d20426aa058f1065fb56329fe1874e722
            07/
                786fefc5f4c2f048c2a93c1afd608b40b6035a
                bca2acaeee93d1a9fe435c77f626a928cf530f
            0b/
                b0493e15fd4499c8c11a4951c342333b1d9fe4
            0d/
                f50f1fc2836db88454109c3962b5a4a249f5a8
            0e/
                596347052abd34c50a6d7ef92be4a23d9bccb8
                638cdf6588bd8af5664efdc11363104c3c5b3d
            0f/
                094f627622511f772310d5043d85ccac4550f2
            10/
                779b8aa8cb957354d4bdf7570db43973152f60
                a805bf4381c6268bed15ab939eb1845ba0cc92
            11/
                8c33fc6979dd8b56201dd72be4c994e695597a
                fac4b565f33ba735764383f2045ab77bc5756b
            13/
                f8eed83dcf6b60f03bac4b44e94374ac7a195e
            17/
                63b6038f3e5d6e9b51b186a5c45635c70a6363
                b56164f577324fee2526c767ed71d95d4fdb84
                bbfc7795d0a35514c43603afb9457d174a22ba
                dfae167ce9b7bdd32908b9abcd8a8725fcd00b
            18/
                14e84bf9ee23517f3d235b09e24a247305c6df
            19/
                3aa697c4df9ff6f803e64e67be2af20a9b0914
            1a/
                b08272ab73deb481521b30ac5519395a516def
                faee21ce500e46e17297ab43eb2649a21d31f2
            1c/
                35adae7f315f4fa7a11da8fc272aecfe63760f
                4fc2590436195beb211b114575d3fbf9124007
            1d/
                a144b195b777a5ae5f68ff83397e1689da829e
                aa7e051967bfda1b2419928341f1ad02828c44
            1f/
                edcad9519ad8dbd3b56f50aff3656f8fd91fca
            20/
                7491a555eb6ef65b85c9525314b00242fe02e8
                dcc1020e0a5737ddc3415dcadf5bf3394c4761
            21/
                0a60c6add0dbf391f52b3788150effc9674a81
                c0c63d634926abb2bb5d554f24e98c58b4c1e4
            24/
                201748e13db38855599d98c451c459dc57b8ab
            25/
                503c542e67467cab44f6d2f42f507eb8ec18dc
                99fa09dea639b6d84d7a6ace65d0d98f038681
            26/
                59a36846cbd3ec3ebb3865f1107cdf65628c23
            27/
                4b1aafbfa1d735b6996a51e013e59ea174c038
            28/
                482cdf116d34ee307fbfc6e9073699958d9969
                a9764ae2b92a2568b1de03ed418881fff642b1
            29/
                29dc7abee09e1a72fe481f9230e67565029df9
                cf1de7e08c8d787cbbfd95ea730c77d1c107d5
            2b/
                15136c0c7963e417c0d6ba59a470626b2c7435
                3092c052d31720dde786222a14952643ffd1b6
            2c/
                7dd95cf6271aa0a9440e5fab700493a61dd665
                b03fcb717ce4c62a1e8d2a8b40cb8d8b372aaf
            2d/
                7194f4869d904a806ad19870414f4548b21896
            2f/
                9ad61c2d099a8fe71cc2aada8d4d8b9100ea94
            33/
                03769dee0f778c661c26276175942006452519
                8b331a971faca76a2ac629e9d75246f672536f
                a894560ea4769885afa8a4f379d3ea4d7ae24d
            34/
                623dc3cb192afdaa6664a4a5714e210960d1ce
            35/
                200a2371ab7f328a6a646bfc37f74b0ba33718
                856c24a06e7967c2708c950c4ae9016f0c060e
            36/
                24068cca3992042f6a0fe41680c396470f7c41
            38/
                272b63ff81efb3c496665d65ef22085916fc4c
            39/
                11c011e9aa4b0128910a3d3787dabf45ae18aa
            3a/
                feb9b41007a1346769613cc7391d0cf42cf8f8
            3b/
                6b70b57aea35ff01ee029542a93025a4f9ebad
                9594f72b8d6908a1180e953ff1c3b4a4cedd73
                b37d29c930f566df143517c7122f42de1a9f01
            3c/
                475b65a5235f333e980385e74d1b482f14edf1
            43/
                3a124cd0fd8c3da58a2dfd3a8577a5e09f90c5
                7a5fc67113854863fb6dbdb1eaec9b0e724f60
            46/
                5fdb3554f473fb3d1a5c32e6427e833105a0df
                9b4b0ba77605ce7c1126648486553096e72280
            47/
                8dc2c929bc1881ff957e41df71f23a34670a3f
            49/
                1b2e297e4a5032b3b3b630fdda6b53c4bf1b51
            4f/
                724a051e591e12f44cd513f12322f3c5a57caa
            51/
                a286c151ea61336b78a043397994adfe780592
            53/
                a5e26cb15fc5bc0b4f3ccf17b6ec1b7af26cc0
                e68b90921ae48743e7e128ec7e24b8365b0c09
            55/
                a4af7e3fa35d64bb795041ffe338c163f3c677
            56/
                71fdc65cd5ca543aae6e34f0060c03567d1f57
            57/
                0c5b5c4099d96f8b4c7623d57b017f0fa5d728
            58/
                f9cb8c87f593c2b8eed96c64cfb6e780bf5c1a
            59/
                eb7fe4c8a9eca34a2d89b95aa987c71d02d309
            5a/
                12c5f193b05890020a1192bb505928ed1dbdc3
                15deee73ff44fbea12b59a0d67fdbf5ed7923b
                56f47bd393eea0f6a01f8a1e8fd787afda84d7
            5c/
                646fbdc571f2e42d8fd91bbfcac8c6c1fa56b6
                b5bd30211f93faf50d130492b3a87729a2159d
            5d/
                a7712095a7b1d7f461c965446726173e96806f
            60/
                a984edc5ef13ab53f985e8437ca250c0613253
            61/
                7950bbfd683819af1b0db90b5417e1169dbce0
            68/
                7bdeeadfd4a43fafdf39fd35c337aac38b8469
                c01f04d9ed1af5efed86b6928731b3f536d805
            69/
                977903855f47180d6436a19c6907559031b02a
            6a/
                3251469fd54a7687f04e5d9c0e1473edbc9811
            6d/
                26a252a549b151bf4a906f3f21f9e2380e4498
            6e/
                13bdcdb856312deeddadb7c00b361beca77cb1
                93e3c0e1a5120f717b3d0877ac81b2d1d8fce1
                fc3dc9d7976ece1105ea9b4b10e35e9a50c644
            6f/
                d6f0ffebe5d4bc187493a98e9ca2017715bc9b
            72/
                f71743aed80939d3e3b7cfad66dc9c842a7dec
            75/
                1f11e1f04f651e6c368f5d7d1cb15ddc941ce2
            78/
                eaa8267d19d8c8515f74bef3207311753a77ca
            7a/
                af9971d4e13ce08f6143074b082c9f57d8596c
            7b/
                25b3ea7e377ceeaa36fabf12fdf7f78010d825
                39594207bdebea8fcd9c4b8191a83f890cfe0b
            7e/
                380d81861063d9b3e656831e94ee42a22ebefc
                b55341ae360d563111a3ad6c4f297dda01a94b
            7f/
                54bff2aafcaab9940218d2ab445907ce9d9e7c
            82/
                f70657a820252f37f5b3291e4ed1fd8e3ca7cb
            84/
                ff2eb89b0c7e4b2e19a57a8dcfd47e67013b9b
            86/
                5d547134439ee0b1b02475453b263881eeeac1
                9afde63c3e872cf06417e67c12aad2e32b9fac
            88/
                191737933e9b47cd5386c880b97d8c1817d3d7
                86341471938f6c3fcc779426ef55b6b83838d8
            89/
                2ec021ab9f8bc0e1a7254ea27cea0d44784b5e
            8a/
                25d115419db98997bb2318921eb5374c0a2f94
                62b2781437ba047c1519ba2ec3215818b90a18
                aa44f4a887ffdac788312f373b4db71cf35f21
            8c/
                28e4db2dbcc1de3d88c38486304a12a75b1c79
                88bf4de43a1c4824e3dd310684601f0954fcdb
            8d/
                bad6c95aca06811c099aeb3e417d802d49ce8d
            8e/
                084cb600cc6ff2e57c2a77fb44791eb73a12c8
                4fcfa9e88c2794a4732d519c13c1c4f309a6d7
                c4d8cd7547e23146c84d445e7b98992ace571d
            8f/
                3274712ed24adbe4c159927495470fd3f8bb3b
            91/
                48e5aa004df91473a567d81e4c97f23b81305f
                aa74f94b8e5ec27fdabde2f405af25aae692cc
                f2d0034730026165cef77a3f4c2a0449b455a8
            93/
                e1e972e8e5a77d69a4bce299cd52637265bbfb
            95/
                46ff1a4de74defe3b8122b7fc0ac851fb427f4
            96/
                1bdc18943e953dbd6d7772d6c4cf1545df8eec
                e5036e868c0d6b589d76938d7075201c3a4855
            9a/
                fcc1442d272b26bbd520f4573cdb170f156d65
            9b/
                96a90259354e12e04a684f15582a0788b8e691
            9c/
                acfc490b2ec0847b50f8b046ccf6b5315d21eb
                f33fdb46a6f3bfbb3f7c76283b776960a9dd17
            9d/
                372f06b19933407304f06e7f6e63754a6bbad0
                7c7aca062f3798921789867418d638bc6c8b2a
            9e/
                ed8d57a75333376cc610c4bb5f0061c3a3912d
                f0f7506b0935cf4ba0411798bfb6e353844b82
            a2/
                3e2f7732ad44e802c733b9f0072bd9b908c422
            a3/
                01ead626ed055378d05c0399ee60170548426d
            a4/
                953b3238a4cc0483da6622a1cf9c9fc8e09db3
                f7ce594fd6003e28c2315f6cdd59744a9a4c40
            a6/
                d7782b913712d5d65c1c2c46d414cca8f4730c
            a7/
                0e0853d4badd2b97c23b0a2bed420186882423
            a9/
                41c70f77c18712ba6d4535cb96b06ff82fc7e8
            ab/
                2b48f2f5bc492b230dbf768d44eb65ed393bee
            ac/
                0f8a9fc2f69097b36160643781a17682419078
            ad/
                2b55eae03cc8a8abbcace0cae3e37e46d57cdd
                3d14020048b54d75ca6856c354e49aa7f3c744
                5142cf78e860c8372560ea8f7ad7aae485e589
            ae/
                d1aeca1e9d5d12786538e43994929979758706
            af/
                10b6c860a16d81b9086cc14c5bffa89c325358
            b0/
                42e102255d390215a0c370f63141715434313d
                574b92661853a6be73dfd63e8f9d1765427e26
            b1/
                23dab174df785b4b90533dcbde550bb6a00a86
                752727d2170396de18642d7743d02afae6ee68
                f5323b2ca9940202a7100c1ec2e50292da4cbb
            b2/
                31dfd9a923bfc7a957efaa998de3d195774b1e
            b3/
                d7b03c5e02cee04333c7b3141d19710c1bca9f
            b4/
                650aac71698ab50eb7d04586013154247f6ea6
            b5/
                2dbf760e9db4fb6ebaa4c0b4528798554bce60
            b6/
                04a42196ac9e4bec6587d8ada871e4dae359cd
                89ad328244fbfc2df9461a053859f8c83e00b0
            b7/
                53ae962310ebde0d621e16d3da02ccfe52b5c5
            b8/
                096ba7329f1760c5d9c8909255d1dedd14bb52
            ba/
                546fa4b5685b8271f6a4e5dcd12c3ec1786294
                a174956ad862484368c23376e18e0b95b55f65
                a5f0c9dd7d635cc32436861cfdb29961b71b01
            bb/
                e04e2b54cc369f9a19c3fa105017a19b0fcf14
                f00277b3a5b74171ea48f629124540937baecd
            bc/
                efe79b75f5394384261e4f679b12650af8e392
            bd/
                8c85456e4adf078ab12fc3221419cca43840f4
                b949c074b5bb070d72cde558493f47f7e78248
            be/
                10f7c1e3ea54b665ac6e20f2025bbc382faad9
                8c12dbe24782a94df4c3cc9e3d50d17f17ef5e
                c9e58e95ac14f002cd23fc82d87d420b92709f
            bf/
                ba1df1b1be57d6e686358684c54cdd31c8dbe3
            c0/
                b92d630f4f8c6f497b8209fe00b9d14632318b
            c1/
                ab58d8a4b1bf6dbf6d3cbd81159a62d83e23d4
                e38a7214ee9a452e1366fc439eb073bc1c37ab
            c3/
                f2a17145dc99e27b72c1a96773254577ce28c7
            c6/
                dacbd903a178e8f090146e9ba24895900bd234
            c9/
                8edbc61c4b3b4eb19c228199e7a09e3fbbe9ff
            cb/
                068df27bcf8da7c7e6bb8af262d139e7535311
            cc/
                93c042bd1bd0a5229b15ea0bfb1654725b2ca2
                e944d334f28250ac656ee7067bc9af6cfff189
            cd/
                03693d10f59e2484e80cdae21b196c94d958e2
                bcb31bfbe79eaa5584bd7e8132aa8c0c6ddb67
            ce/
                b411db85572f721f572704915c44bc8e8e7f35
            d1/
                52de4a57e862ec118c29a6ba27b2c0c6534645
            d2/
                dc88e04586acf5ae1913356d13e8b7cf63e586
                eb7486ab81d361e70eade4fab3433da67a89b5
            d3/
                045af2167d1263afb2e6897e29422a719106b0
            d4/
                5852426aacbe54353b93cdb43e976eef24df71
                ce646f5138976df4b15a165f0f8c401f500c2a
            d5/
                050a9179c94ca7ae3d8997da4382be07f726ed
                6f0c79453891c7e20f85b8295505a705d495c0
                cbff5dde6e03addc22c71314b8b8553856df43
            d7/
                bc4a17bf1c994eeea2555c06c2c4a897c238d3
            d8/
                827f64dd5c6b06177c343f3364c87efa6aecef
                990a7ae3b2c6661ee0c4b1293e5c96392b052f
            d9/
                151d6e14b6bc74896de1d2f61ef1571be2613e
            db/
                1845ea27cea38c8c5d48e9527cb1505a2797b3
                c6367fe8759b2f528011209c66b83bc8d02977
            dc/
                219253508ef68c380c4e91fcf7401a194f4d18
                b4850c15fa513d0666a6a8aee167896a4318e8
            de/
                25f74a7485f7bf6ffd12198117c823d93341ae
            df/
                66c5081d2f7cdee1683a5bdcaea34371025260
            e0/
                b185c1ca58ab1d62a65d985f28676d6908a196
            e2/
                6bdfc3ec84cee5c85d2731d9b9699a5dfb139e
            e4/
                658f134747d3c15fb2304eda100090bd114192
            e6/
                9de29bb2d1d6434b8b29ae775ad8c2e48c5391
            e7/
                a70cbd176cf1e309d9342c75e4e73dea925ffe
            e9/
                9b56c0be3d423031eca34ed90add0c72db1ee4
            eb/
                fb09960429532dc26c4bd9abb86585c18ad6aa
            ec/
                b2ea6fc3fbd92761a9f620bd8002a9b1927c4c
            ef/
                a71b893ad305ac0818fedf0ecfa3d5edd17acf
            f0/
                b64f526cb7fadc3a35f309d68bc0874956ed10
            f1/
                2629aa1829132e4c4ce7da9ccb1bca771eb257
                9e7374dd261796b83208c2f1bcaf590a2f0dc7
                b04f043e38a6a7c4c3fe9928cf43f0c9c1b0d8
            f2/
                703bae16ae459aa906008d2cba389cf98e0194
            f3/
                456da972c902706d268c04a26d96f193e4901f
                c45f461a6a76e98759af3ef6acc425e41cf48d
            f5/
                a8332bc15a1778337fa2ba44e87c1585990568
                f92bd5b2dccd1fae7256f952cdd3ff5ae0ebc8
            f6/
                e6736c3663dfa7564fd83b12b2393265955828
            f9/
                9f714ea1b84947a752f7426673e5a34920817d
            fa/
                1015b0d461417a4f1a2e1ad41d34a373c793e2
            fc/
                fcb7368e6cd43d4ab89ffea4031e011ae573fa
            fd/
                032ad9b6792684c99934bf5782b8c02050e3d3
            fe/
                5649ccd213e8825ab06d9f2fef8dc73dc3764c
                cbe4333e6b420fa2a5f910d2a0e087312b92f8
                fb94f1b6600d66d1ecb31b50b28962dad862d4
            ff/
                38f0280d6886cf358afb712fe5ff2c68793e3d
                5afc1654e4ce3d55988bdbd6098b169d36dde2
            info/
            pack/
        refs/
            heads/
                dev
                main
                testing
                wip
            remotes/
                origin/
                    dev
                    features
                    main
                    Source-Code-Implementation
                    testing
                    wip
            tags/
    bot/
        activity_tracker.py
        commands.py
        games.py
        level_widget.py
        shop.py
        __init__.py
        status/
            offline.py
            online.py
            setup.py
            __pycache__/
                offline.cpython-311.pyc
                online.cpython-311.pyc
                setup.cpython-311.pyc
        __pycache__/
            abilities.cpython-311.pyc
            activity_tracker.cpython-311.pyc
            commands.cpython-311.pyc
            effects.cpython-311.pyc
            games.cpython-311.pyc
            level_widget.cpython-311.pyc
            shop.cpython-311.pyc
            status.cpython-311.pyc
            __init__.cpython-311.pyc
    data/
        game_data.json
        player_data.json
    settings/
        .env
        settings.py
        json/
            game_settings.json
            settings.json
        __pycache__/
            settings.cpython-311.pyc
    utils/
        graphics.py
        __init__.py
        images/
            level_bar.png
            level_image.png
            statistics_visualization.png
            blackjackdump/
            deckofcards/
                back.png
                10/
                    10C.png
                    10D.png
                    10H.png
                    10S.png
                2/
                    2C.png
                    2D.png
                    2H.png
                    2S.png
                3/
                    3C.png
                    3D.png
                    3H.png
                    3S.png
                4/
                    4C.png
                    4D.png
                    4H.png
                    4S.png
                5/
                    5C.png
                    5D.png
                    5H.png
                    5S.png
                6/
                    6C.png
                    6D.png
                    6H.png
                    6S.png
                7/
                    7C.png
                    7D.png
                    7H.png
                    7S.png
                8/
                    8C.png
                    8D.png
                    8H.png
                    8S.png
                9/
                    9C.png
                    9D.png
                    9H.png
                    9S.png
                A/
                    AC.png
                    AD.png
                    AH.png
                    AS.png
                J/
                    JC.png
                    JD.png
                    JH.png
                    JS.png
                K/
                    KC.png
                    KD.png
                    KH.png
                    KS.png
                Q/
                    QC.png
                    QD.png
                    QH.png
                    QS.png
            pokerdump/
                community_cards.png
                poker_1170556246257057888_hand.png
                poker_1170556246257057888_peek_hand.png
                poker_443232925769531392_hand.png
                poker_443232925769531392_peek_hand.png
        __pycache__/
            graphics.cpython-311.pyc
            settings.cpython-311.pyc
            __init__.cpython-311.pyc


.\main.py
import discord
from discord.ext import commands
import os
import subprocess
import sys
import signal
from settings.settings import load_settings
from dotenv import load_dotenv

load_dotenv(dotenv_path='settings/.env')
TOKEN = os.getenv('TOKEN')

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

def update_status_offline():
    script_path = os.path.join('bot', 'status', 'offline.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to OFFLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

def signal_handler(signal, frame):
    print("Signal received, updating status to OFFLINE...")
    update_status_offline()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    await bot.load_extension('bot.activity_tracker')
    await bot.load_extension('bot.commands')
    await bot.load_extension('bot.games')
    await bot.load_extension('bot.shop')
    print("Extensions loaded")

    # Update the bot status to ONLINE
    script_path = os.path.join('bot', 'status', 'online.py')
    process = subprocess.run([sys.executable, script_path], capture_output=True, text=True)

    if process.returncode == 0:
        print("Bot status updated to ONLINE.")
    else:
        print(f"Failed to update bot status. Error: {process.stderr}")

bot.run(TOKEN)


.\resetdata.py
import json

def wipe_activity_data():
    with open('data/player_data.json', 'w') as f:
        json.dump({}, f, indent=4)


wipe_activity_data()

.\summary.py
import os

def generate_directory_tree(directory, exceptions):
    tree = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions):
            continue
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        tree.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions):
                tree.append(f"{subindent}{file}")
    return tree

def generate_summary(directory, exceptions, include_extensions):
    summary = []
    for root, dirs, files in os.walk(directory):
        relative_root = os.path.relpath(root, directory)
        # Check if the current root is in the exceptions list
        if any(os.path.commonpath([relative_root, exception]) == exception for exception in exceptions):
            continue
        for file in files:
            file_relative_path = os.path.join(relative_root, file)
            # Check if the file is in the exceptions list and has an allowed extension
            if not any(os.path.commonpath([file_relative_path, exception]) == exception for exception in exceptions):
                if any(file.endswith(ext) for ext in include_extensions):
                    file_path = os.path.join(root, file)
                    summary.append(file_path)
    return summary

def read_and_prepend_file(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        content = file.read()
    return f"{file_path}\n{content}"

if __name__ == "__main__":
    exceptions = [
        os.path.normpath('extensions/gulp'),
        os.path.normpath('assets/instance/database.db'),
        os.path.normpath('assets/migrations')
    ]  # Add more directories to this list if needed
    include_extensions = [
        '.html', '.css', '.scss', '.py', '.java', '.cpp', '.js', '.ts', '.jsx', '.tsx'
    ]  # Add more file extensions to this list if needed
    with open('project_summary.txt', 'w', encoding='utf-8') as f:
        # Write directory tree
        directory_tree = generate_directory_tree('.', exceptions)
        for line in directory_tree:
            f.write(line + '\n')

        f.write('\n\n')  # Separate the directory tree from the file contents

        # Write file contents
        summary = generate_summary('.', exceptions, include_extensions)
        for file_path in summary:
            file_content = read_and_prepend_file(file_path)
            f.write(file_content + '\n\n')


.\test.py
INITIAL_LEVEL_POINTS_NEEDED = 1000  # Starting with a higher initial value
INITIAL_LEVEL = 1

def calculate_level_points(POINTS_NEEDED, CURRENT_LEVEL, growth_factor):
    if CURRENT_LEVEL == 1:
        return INITIAL_LEVEL_POINTS_NEEDED
    else:
        return round(POINTS_NEEDED * growth_factor)

# Calculate total points needed to reach a certain level
def total_points_to_reach_level(target_level, growth_factor):
    total_points = 0
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(2, target_level + 1):
        points_needed = calculate_level_points(points_needed, level, growth_factor)
        total_points += points_needed
    return total_points

# Adjust growth factor to fit the goal
def find_optimal_growth_factor(target_levels, target_points):
    growth_factor = 1.01
    while True:
        match = True
        for target_level, target_point in zip(target_levels, target_points):
            total_points = total_points_to_reach_level(target_level, growth_factor)
            if abs(total_points - target_point) > target_point * 0.01:  # Allow 1% tolerance
                match = False
                break
        if match:
            break
        growth_factor += 0.001
    return growth_factor - 0.001  # Step back to the last valid growth factor

# Target levels and their corresponding total points
target_levels = [10, 100, 300]
target_points = [12000, 97000, 600000]

# Calculate the optimal growth factor
optimal_growth_factor = find_optimal_growth_factor(target_levels, target_points)

# Print the optimal growth factor
print(f"Optimal growth factor: {optimal_growth_factor:.4f}")

# Calculate points needed for each level incrementally
def points_needed_per_level(target_level, growth_factor):
    points_per_level = []
    points_needed = INITIAL_LEVEL_POINTS_NEEDED
    for level in range(1, target_level):
        next_level_points = calculate_level_points(points_needed, level, growth_factor)
        points_per_level.append((level, next_level_points))
        points_needed = next_level_points
    return points_per_level

# Print points needed for each level from 1 to target level
target_level = 500
points_per_level = points_needed_per_level(target_level, optimal_growth_factor)
for level, points in points_per_level:
    print(f"Points needed from level {level} to {level + 1}: {points} points")


.\bot\activity_tracker.py
import discord
from discord.ext import commands, tasks
import json
import os
from datetime import datetime, timezone

# Variables for point increments and bot testing mode
MESSAGE_POINTS = 10
VOICE_POINTS = 5
ONLINE_POINTS = 2
CHARACTERS_TYPED_POINTS = 0.1
DUEL_WIN_POINTS = 100
DUEL_WIN_COINS = 500
BOT_TESTING_MODE = True  # Set to False to disable bot auto-playing duels

class ActivityTracker(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.activity_data = self.load_activity_data()
        self.reset_daily_stats.start()
        self.track_activity.start()

    def load_activity_data(self):
        if os.path.exists('data/player_data.json'):
            with open('data/player_data.json', 'r') as f:
                return json.load(f)
        return {}

    def save_activity_data(self):
        with open('data/player_data.json', 'w') as f:
            json.dump(self.activity_data, f, indent=4)

    @tasks.loop(hours=24)
    async def reset_daily_stats(self):
        now = datetime.now(timezone.utc)
        if now.hour == 5:  # 5 AM UTC, midnight EST
            for user_id in self.activity_data:
                self.activity_data[user_id]['points_today'] = 0
            self.save_activity_data()

    @reset_daily_stats.before_loop
    async def before_reset_daily_stats(self):
        await self.bot.wait_until_ready()

    @tasks.loop(minutes=5)
    async def track_activity(self):
        for guild in self.bot.guilds:
            for member in guild.members:
                if member.status != discord.Status.offline and not member.bot:
                    user_id = str(member.id)
                    if user_id not in self.activity_data:
                        self.activity_data[user_id] = {
                            "username": member.name,
                            "points": 0,
                            "points_today": 0,
                            "level": 1,
                            "messages_sent": 0,
                            "characters_typed": 0,
                            "minutes_in_voice": 0,
                            "minutes_online": 0,
                            "voice_activations": 0,
                            "total_talking_time": 0,
                            "coins": 0  # Add coins attribute
                        }
                    self.activity_data[user_id]['minutes_online'] += ONLINE_POINTS  # Increment by ONLINE_POINTS
                    self.save_activity_data()

    def update_user_activity(self, user, points=0, coins=0):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "points": 0,
                "points_today": 0,
                "level": 1,
                "messages_sent": 0,
                "characters_typed": 0,
                "minutes_in_voice": 0,
                "minutes_online": 0,
                "voice_activations": 0,
                "total_talking_time": 0,
                "coins": 0  # Add coins attribute
            }
        self.activity_data[user_id]['points'] += points
        self.activity_data[user_id]['points_today'] += points
        self.activity_data[user_id]['coins'] += coins
        self.save_activity_data()

    def update_user_coins(self, user, coins):
        user_id = str(user.id)
        if user_id not in self.activity_data:
            self.activity_data[user_id] = {
                "username": user.name,
                "coins": 0,
                # Add other fields as necessary
            }
        self.activity_data[user_id]['coins'] += coins
        self.save_activity_data()

    @commands.Cog.listener()
    async def on_message(self, message):
        if not message.author.bot:
            self.update_user_activity(message.author, points=MESSAGE_POINTS)
            self.activity_data[str(message.author.id)]['messages_sent'] += 1
            self.activity_data[str(message.author.id)]['characters_typed'] += len(message.content)
            self.save_activity_data()

    def get_statistics(self, user_id):
        return self.activity_data.get(user_id, {})
    
def points_for_level_transition(level):
    return 10000 if level == 1 else (level + 1) * 5000

def points_for_next_level(current_level):
    total_points = 0
    for level in range(1, current_level + 1):
        total_points += points_for_level_transition(level)
    return total_points

def get_current_level(points):
    level = 1
    while points >= points_for_next_level(level):
        level += 1
    return level, points_for_next_level(level) - points_for_next_level(level - 1)



async def setup(bot):
    await bot.add_cog(ActivityTracker(bot))


.\bot\commands.py
# bot/commands.py
from discord.ext import commands
import discord
from utils.graphics import generate_level_image, generate_statistics_visualization
from discord.ui import View
import pandas as pd
from bot.games import Duel, BlackjackGame, DUEL_WIN_POINTS, DUEL_WIN_COINS, BOT_TESTING_MODE
import asyncio
import aiohttp
from datetime import datetime, timedelta
import random
import pytz
from settings.settings import load_settings
import subprocess
import sys
import os
from activity_tracker import points_for_level_transition

TESTING = False
settings = load_settings()
coin_icon = settings['coin_icon']

class GeneralCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
    @commands.command(name='update_notes')
    async def update_notes(self, ctx, *, notes):
        try:
            # Determine if the bot is online or offline
            online_status = True  # Replace with your logic to determine the status

            script_path = os.path.join('bot', 'status', 'online.py' if online_status else 'offline.py')

            # Run the update_additional_notes method in the respective script
            process = subprocess.run([sys.executable, script_path, notes], capture_output=True, text=True)

            if process.returncode == 0:
                print("Successful Notes Change")
            else:
                await ctx.send(f"Failed to update additional notes. Error: {process.stderr}")
        except Exception as e:
            await ctx.send(f"An error occurred: {str(e)}")

    @commands.command(name='daily')
    async def daily(self, ctx):
        user_id = str(ctx.author.id)
        activity_tracker = self.bot.get_cog('ActivityTracker')
        user_data = activity_tracker.activity_data.get(user_id, {})

        if ctx.message.content.strip() != '!daily':
            return

        if TESTING:
            last_daily = None
        else:
            last_daily = user_data.get('last_daily', None)

        now = datetime.utcnow()

        if last_daily:
            last_daily_time = datetime.strptime(last_daily, "%Y-%m-%d %H:%M:%S")
            if now < last_daily_time + timedelta(hours = 24):
                next_claim_time = last_daily_time + timedelta(hours = 24)
                est = pytz.timezone('US/Eastern')
                next_claim_time_est = next_claim_time.replace(tzinfo=pytz.utc).astimezone(est)
                next_claim_time_str = next_claim_time_est.strftime('%Y-%m-%d %I:%M:%S %p')
                await ctx.send(f"You have already claimed your daily {coin_icon}.  NEXT CLAIM TIME: {next_claim_time_str} EST.")
                return
            
        daily_coins = random.randint(0, 10000)
        digits = str(daily_coins)

        await ctx.send(f"{ctx.author.mention}, generating your daily coins...")
        
        accumulated_digits = ""
        for digit in digits:
            accumulated_digits += digit
            await ctx.send(f"{accumulated_digits}")
            await asyncio.sleep(0.5)

        activity_tracker.update_user_coins(ctx.author, daily_coins)
        activity_tracker.activity_data[user_id]['last_daily'] = now.strftime('%Y-%m-%d %H:%M:%S')
        activity_tracker.save_activity_data()

        await ctx.send(f"You have been rewarded {daily_coins} {coin_icon} for the day!  Your balance is now {activity_tracker.activity_data[user_id]['coins']} {coin_icon}.")

class LevelUIView(View):
    def __init__(self, username, avatar_url, points, current_level, next_level, progress_percentage, remaining_points):
        super().__init__(timeout=60)
        self.username = username
        self.avatar_url = avatar_url
        self.points = points
        self.current_level = current_level
        self.next_level = next_level
        self.progress_percentage = progress_percentage
        self.remaining_points = remaining_points


class LevelUI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='level')
    async def level(self, ctx, member: discord.Member = None):
        if member is None:
            member = ctx.author

        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(member.id))
        if not stats:
            await ctx.send("No statistics available for this user.")
            return

        username = member.display_name
        avatar_url = member.avatar.url
        points = stats.get('points', 0)
        current_level = stats.get('level', 1)
        points_to_next_level = stats.get('points_to_next_level', 10000)
        progress_percentage = (points_to_next_level / points_for_level_transition(current_level)) * 100
        next_level = current_level + 1

        # Generate the level image
        image_path = generate_level_image(username, current_level, progress_percentage, points, next_level, avatar_url)
        if image_path:
            file = discord.File(image_path, filename="level_image.png")
            embed = discord.Embed(title=f"{username}'s Profile")
            embed.set_image(url="attachment://level_image.png")
            await ctx.send(file=file, embed=embed)
        else:
            await ctx.send("An error occurred while generating the level image.")

    @commands.command(name='leaderboard')
    async def leaderboard(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = {user_id: data for user_id, data in activity_tracker.activity_data.items()}
        sorted_stats = sorted(stats.items(), key=lambda x: x[1]['points'], reverse=True)[:20]

        df = pd.DataFrame(columns=["Rank", "Username", "Level", "Points"])
        for idx, (user_id, data) in enumerate(sorted_stats, start=1):
            member = ctx.guild.get_member(int(user_id))
            if member:
                df = pd.concat([df, pd.DataFrame({"Rank": [idx], "Username": [member.display_name], "Level": [data['level']], "Points": [data['points']]})], ignore_index=True)
        
        table_str = df.to_markdown(index=False)
        embed = discord.Embed(title="Leaderboard", color=discord.Color.green())
        embed.add_field(name="Top 20 Users", value=f"```\n{table_str}\n```", inline=False)

        await ctx.send(embed=embed)

    @commands.command(name='leaderboard_today')
    async def leaderboard_today(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = {user_id: data for user_id, data in activity_tracker.activity_data.items()}
        sorted_stats = sorted(stats.items(), key=lambda x: x[1].get('points_today', 0), reverse=True)[:20]

        df = pd.DataFrame(columns=["Rank", "Username", "Points Today"])
        for idx, (user_id, data) in enumerate(sorted_stats, start=1):
            member = ctx.guild.get_member(int(user_id))
            if member:
                df = pd.concat([df, pd.DataFrame({"Rank": [idx], "Username": [member.display_name], "Points Today": [data.get('points_today', 0)]})], ignore_index=True)

        table_str = df.to_markdown(index=False)
        embed = discord.Embed(title="Today's Leaderboard", color=discord.Color.green())
        embed.add_field(name="Top 20 Users", value=f"```\n{table_str}\n```", inline=False)

        await ctx.send(embed=embed)

class Statistics(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='statistics')
    async def statistics(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
        stats = self.bot.get_cog('ActivityTracker').get_statistics(str(member.id))
        if stats:
            embed = discord.Embed(title="Statistics", color=discord.Color.purple())
            embed.add_field(name="Username", value=member.display_name, inline=True)
            embed.add_field(name="Total Points", value=stats.get('points', 0), inline=True)
            embed.add_field(name="Level", value=stats.get('level', 1), inline=True)
            embed.add_field(name="XP to Next Level", value=stats.get('points_to_next_level', 0), inline=True)
            embed.add_field(name="Minutes in Voice", value=stats.get('minutes_in_voice', 0), inline=True)
            embed.add_field(name="Minutes Online", value=stats.get('minutes_online', 0), inline=True)
            embed.add_field(name="Messages Sent", value=stats.get('messages_sent', 0), inline=True)
            embed.add_field(name="Characters Typed", value=stats.get('characters_typed', 0), inline=True)
            embed.add_field(name="Points Today", value=stats.get('points_today', 0), inline=True)

            # Add coin information
            coins = stats.get('coins', 0)
            coin_icon_url = "https://cdn4.iconfinder.com/data/icons/coins-virtual-currency/104/Guarani-256.png"
            embed.add_field(name=f"\u200b", value=f"[![coins]({coin_icon_url})]({coin_icon_url}) **{coins}**", inline=False)

            await ctx.send(embed=embed)
        else:
            await ctx.send("No statistics available for this user.")
                        
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        if isinstance(error, commands.CommandNotFound):
            botlog_channel = discord.utils.get(ctx.guild.channels, name='botlog')
            if botlog_channel:
                await botlog_channel.send("Invalid Command Called.")
        else:
            raise error

async def setup(bot):
    await bot.add_cog(GeneralCommands(bot))
    await bot.add_cog(LevelUI(bot))
    await bot.add_cog(Statistics(bot))

.\bot\games.py
# bot/games.py

# Games played in the discord server from bot

from datetime import timedelta
import random  # Importing the random module to use for shuffling and generating random letters
import aiohttp  # Importing aiohttp for making asynchronous HTTP requests
import os  # Importing os for file operations
from PIL import Image  # Importing PIL (Pillow) for image processing
import json  # Importing json to read configuration settings from a file
import discord
import shutil
import io
from io import BytesIO  # Importing BytesIO for handling image data in memory
import asyncio
from discord.ext import commands
from discord import app_commands
from settings.settings import load_settings
import itertools

# Load game settings from a JSON file
with open('settings/json/game_settings.json', 'r') as f:
    game_settings = json.load(f)

# Blackjack settings
CARD_VALUES = game_settings['blackjack']['card_values']  # Dictionary of card values
SUITS = game_settings['blackjack']['suits']  # List of suits
DECK = [f'{value}_of_{suit}' for suit in SUITS for value in CARD_VALUES.keys()]  # List of all cards in the deck
DECK_IMAGES_FOLDER = 'utils/images/deckofcards'
DUMP_IMAGES_FOLDER = 'utils/images/blackjackdump'

# Duel settings
DUEL_WIN_POINTS = game_settings['duel']['win_points']  # Points awarded for winning a duel
DUEL_WIN_COINS = game_settings['duel']['win_coins']  # Coins awarded for winning a duel

# Poker settings
POKER_WIN_POINTS = game_settings['poker']['win_points']
POKER_PREFLOP_MAX_BET = game_settings['poker']['preflop_max_bet']
POKER_MIN_PLAYERS = game_settings['poker']['min_players']
POKER_MAX_PLAYERS = game_settings['poker']['max_players']
DUMP_IMAGES_FOLDER_POKER = 'utils/images/pokerdump'

# Game Settings
BOT_TESTING_MODE = game_settings['game']['bot_testing_mode']  # Whether bot testing mode is enabled
if BOT_TESTING_MODE:
    POKER_MIN_PLAYERS = 1
    POKER_MAX_PLAYERS = 1

settings = load_settings()
coin_icon = settings['coin_icon']

# Class for handling duel game logic
class Duel:
    def __init__(self, player1, player2):
        self.player1 = player1  # ID of player 1
        self.player2 = player2  # ID of player 2
        self.health = {player1: 100, player2: 100}  # Initial health for both players
        self.letter = None  # The current letter for the duel
        self.used_words = set()  # Set of words that have already been used

    def generate_letter(self):
        self.letter = random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')  # Generate a random letter

    async def is_valid_word(self, word):
        url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word.lower()}"  # URL to check if the word is valid
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                return resp.status == 200  # Return True if the word is valid

    def calculate_damage(self, words):
        valid_words = [word for word in words if word.lower().startswith(self.letter.lower()) and word.lower() not in self.used_words]
        self.used_words.update(word.lower() for word in valid_words)  # Add valid words to the set of used words
        return sum(len(word) for word in valid_words)  # Calculate damage as the sum of the lengths of valid words

    def get_winner(self):
        if self.health[self.player1] <= 0:
            return self.player2  # Player 2 wins if player 1's health is 0 or less
        elif self.health[self.player2] <= 0:
            return self.player1  # Player 1 wins if player 2's health is 0 or less
        return None  # No winner if both players have health above 0

    def adjust_health(self, player_id, damage):
        self.health[player_id] = max(self.health[player_id] - damage, 0)  # Reduce health by the damage amount, but not below 0

# Class for handling blackjack game logic
class BlackjackGame:
    def __init__(self, player, bot):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        self.player = player
        self.bot = bot
        self.player_hand = []
        self.dealer_hand = []
        self.player_points = 0
        self.dealer_points = 0
        self.bet = 0

    async def deal_initial_cards(self):
        self.player_hand = [self.deck.pop(), self.deck.pop()]
        self.dealer_hand = [self.deck.pop(), self.deck.pop()]
        self.player_points = self.calculate_hand_value(self.player_hand)
        self.dealer_points = self.calculate_hand_value(self.dealer_hand)

    def calculate_hand_value(self, hand):
        value = 0
        aces = 0
        for card in hand:
            card_value = card[:-1]  # Get the card value without the suit
            if card_value.isdigit():
                value += int(card_value)
            elif card_value in ['J', 'Q', 'K']:
                value += 10
            else:
                value += 11
                aces += 1
        while value > 21 and aces:
            value -= 10
            aces -= 1
        return value

    async def start_game(self, bet):
        self.bet = bet
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        await self.deal_initial_cards()

    async def player_hit(self):
        card = self.deck.pop()
        self.player_hand.append(card)
        self.player_points = self.calculate_hand_value(self.player_hand)
        return card

    async def dealer_play(self):
        while self.dealer_points < 17:
            card = self.deck.pop()
            self.dealer_hand.append(card)
            self.dealer_points = self.calculate_hand_value(self.dealer_hand)
        return self.dealer_hand

    def get_game_result(self):
        if self.player_points > 21:
            return "bust"
        elif self.dealer_points > 21 or self.player_points > self.dealer_points:
            return "win"
        elif self.player_points == self.dealer_points:
            return "push"
        else:
            return "lose"

    async def create_hand_image(self, hand, reveal_dealer=False):
        card_images = []
        for card in hand:
            if isinstance(card, dict) and card.get('value') == 'back':
                card_image_path = os.path.join(DECK_IMAGES_FOLDER, 'back.png')
            else:
                card_value = card[:-1]  # Extract the value part of the card string
                card_suit = card[-1].upper()  # Extract the suit part of the card string
                if card_value == '10':  # Check for '10' separately
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, '10', f'10{card_suit}.png')
                else:
                    card_value = card_value[0].upper()
                    card_image_path = os.path.join(DECK_IMAGES_FOLDER, card_value, f'{card_value}{card_suit}.png')
            card_images.append(card_image_path)
        return card_images



    async def concatenate_images(self, image_paths, filename):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        total_width = sum(widths)
        max_height = max(heights)
        new_image = Image.new('RGB', (total_width, max_height))

        x_offset = 0
        for img in images:
            new_image.paste(img, (x_offset, 0))
            x_offset += img.size[0]

        output_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path


    async def hit(self, ctx):
        card = await self.player_hit()
        await self.send_hand(ctx)

        if self.player_points > 21:
            await self.end_game(ctx, "bust")

    async def stand(self, ctx):
        dealer_hand = await self.dealer_play()
        await self.send_hand(ctx, reveal_dealer=True)

        result = self.get_game_result()
        await self.end_game(ctx, result)

    async def end_game(self, ctx, result):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        if result == "win":
            payout = self.bet * 2
            activity_tracker.update_user_activity(ctx.author, points=DUEL_WIN_POINTS, coins=self.bet)
            await ctx.send(f"Congratulations {ctx.author.mention}, you win! You have been awarded {DUEL_WIN_POINTS} points and {payout} {coin_icon}.")
        elif result == "bust":
            payout = -(self.bet)
            activity_tracker.update_user_activity(ctx.author, points=DUEL_WIN_POINTS, coins=payout)
            await ctx.send(f"Sorry {ctx.author.mention}, you busted! You lost {self.bet} {coin_icon}.")
        elif result == "lose":
            payout = -(self.bet)
            activity_tracker.update_user_activity(ctx.author, points=DUEL_WIN_POINTS, coins=payout)
            await ctx.send(f"Sorry {ctx.author.mention}, you lose! You lost {self.bet} {coin_icon}.")
        elif result == "push":
            await ctx.send(f"It's a push, {ctx.author.mention}. Your bet of {self.bet} {coin_icon} has been returned.")

        await self.cleanup_images()
        del self.bot.get_cog('CommandHandler').blackjack_games[ctx.author.id]

    async def send_hand(self, ctx, reveal_dealer=False):
        player_images = await self.create_hand_image(self.player_hand)
        dealer_hand = self.dealer_hand if reveal_dealer else self.dealer_hand[:1] + [{'value': 'back', 'suit': ''}]
        dealer_images = await self.create_hand_image(dealer_hand)

        concatenated_player_image = await self.concatenate_images(player_images, f'blackjack_{ctx.author.id}_player_hand.png')
        concatenated_dealer_image = await self.concatenate_images(dealer_images, f'blackjack_{ctx.author.id}_dealer_hand.png')

        player_hand_embed = discord.File(concatenated_player_image, filename="player_hand.png")
        dealer_hand_embed = discord.File(concatenated_dealer_image, filename="dealer_hand.png")

        embed = discord.Embed(title="Blackjack")
        embed.add_field(name="Your Hand", value=f"Points: {self.player_points}", inline=True)
        embed.add_field(name="Dealer's Hand", value=f"Points: {self.dealer_points if reveal_dealer else '?'}", inline=True)
        embed.set_image(url=f"attachment://player_hand.png")
        embed.set_thumbnail(url=f"attachment://dealer_hand.png")

        await ctx.send(embed=embed, files=[player_hand_embed, dealer_hand_embed])


    async def cleanup_images(self):
        for filename in os.listdir(DUMP_IMAGES_FOLDER):
            file_path = os.path.join(DUMP_IMAGES_FOLDER, filename)
            if os.path.isfile(file_path):
                os.unlink(file_path)

class PokerGame:
    def __init__(self, ctx, bot, buy_in):
        self.bot = bot  # The bot instance
        self.ctx = ctx  # The context from Discord
        self.buy_in = buy_in  # The buy-in amount for the game
        self.players = []  # List to store players
        self.betting_order = []  # Order in which players will bet
        self.current_bet = 0  # Current bet amount
        self.pot = 0  # Total pot amount
        self.current_player_index = 0  # Index to track the current player
        self.community_cards = []  # List to store community cards
        self.player_hands = {}  # Dictionary to store each player's hand
        self.player_balances = {}  # Dictionary to store each player's balance
        self.all_in_players = set()  # Set to track players who are all-in
        self.DECK_OF_CARDS_FOLDER = 'utils/images/deckofcards'  # Folder for card images
        self.DUMP_IMAGES_FOLDER = 'utils/images/pokerdump'  # Folder for dumping images
        self.game_cancelled = False  # Flag to check if the game is cancelled

    async def start_game(self):
        await self.collect_players()  # Collect players for the game
        if len(self.players) < POKER_MIN_PLAYERS:  # Check if there are enough players
            await self.ctx.send("Not enough players to start the game. Refunding buy-ins.")
            await self.refund_buy_ins()  # Refund the buy-ins if not enough players
            return

        self.betting_order = self.players[:]  # Set the betting order to the list of players
        random.shuffle(self.betting_order)  # Shuffle the betting order
        await self.deal_cards()  # Deal the initial cards to the players
        await self.betting_round(pre_flop=True)  # Run the first betting round (pre-flop)
        await self.reveal_community_cards(3)  # Reveal the flop (3 community cards)
        await self.betting_round()  # Run the second betting round
        await self.reveal_community_cards(1)  # Reveal the turn (1 community card)
        await self.betting_round()  # Run the third betting round
        await self.reveal_community_cards(1)  # Reveal the river (1 community card)
        await self.betting_round()  # Run the final betting round
        await self.showdown()  # Determine the winner and show the final hands

    async def collect_players(self):
        await self.ctx.send(f"A new poker game is starting with a buy-in of {self.buy_in} coins! Type `!join poker` to join. You have 2 minutes to join. The host can type `!cancel poker` to cancel the game or `!forcestart` to start the game if the minimum player requirements are met.")

        activity_tracker = self.bot.get_cog('ActivityTracker')
        player_coins = activity_tracker.get_statistics(str(self.ctx.author.id)).get('coins', 0)
        if player_coins < self.buy_in:
            await self.ctx.send(f"{self.ctx.author.mention}, you do not have enough coins to start the game.")
            return

        self.players.append(self.ctx.author)
        self.player_balances[self.ctx.author] = self.buy_in
        activity_tracker.update_user_activity(self.ctx.author, coins=-(self.buy_in))
        await self.display_player_list()

        def join_check(m):
            return m.content.lower() == "!join poker" and m.channel == self.ctx.channel

        def cancel_check(m):
            return m.content.lower() == "!cancel poker" and m.channel == self.ctx.channel and m.author == self.ctx.author

        def forcestart_check(m):
            return m.content.lower() == "!forcestart" and m.channel == self.ctx.channel and m.author == self.ctx.author

        end_time = discord.utils.utcnow() + timedelta(minutes=2)
        warning_times = [60, 30, 10]  # Times to send warnings in seconds
        sent_warnings = set()

        while True:
            remaining_time = (end_time - discord.utils.utcnow()).total_seconds()

            # Send warning messages
            for warning in warning_times:
                if remaining_time <= warning and warning not in sent_warnings:
                    await self.ctx.send(f"{int(warning)} seconds remaining to join the game!")
                    sent_warnings.add(warning)

            if remaining_time <= 0:
                break

            try:
                done, pending = await asyncio.wait(
                    [asyncio.create_task(self.bot.wait_for('message', check=join_check)), 
                    asyncio.create_task(self.bot.wait_for('message', check=cancel_check)),
                    asyncio.create_task(self.bot.wait_for('message', check=forcestart_check))],
                    timeout=1,
                    return_when=asyncio.FIRST_COMPLETED
                )

                if not done:
                    continue

                msg = done.pop().result()

                if msg.content.lower() == "!cancel poker":
                    await self.cancel_game()
                    return

                if msg.content.lower() == "!forcestart":
                    if len(self.players) >= 2:
                        await self.ctx.send("Minimum player requirements met. Starting the game now!")
                        break
                    else:
                        await self.ctx.send(f"Not enough players to start the game. Minimum required is 2.")
                        continue

                if msg.author in self.players:
                    await self.ctx.send(f"{msg.author.mention}, you are already in the game!")
                    continue

                player_coins = activity_tracker.get_statistics(str(msg.author.id)).get('coins', 0)
                if player_coins < self.buy_in:
                    await self.ctx.send(f"{msg.author.mention}, you do not have enough coins to join the game.")
                    continue

                self.players.append(msg.author)
                self.player_balances[msg.author] = self.buy_in
                activity_tracker.update_user_activity(msg.author, coins=-self.buy_in)
                await self.ctx.send(f"{msg.author.mention} has joined the Poker session!")
                await self.display_player_list()

                if len(self.players) > 8:
                    await self.ctx.send(f"MAX PLAYER EXCEEDED ERROR! The game has been cancelled.")
                    await self.cancel_game()
                    return

                if len(self.players) == 8:
                    await self.ctx.send("Maximum number of players reached. Starting the game now!")
                    break
            except asyncio.TimeoutError:
                continue

        if len(self.players) < 2:
            await self.ctx.send("Not enough players to start the game. Refunding buy-ins.")
            for player in self.players:
                activity_tracker.update_user_activity(player, coins=self.buy_in)
                await self.ctx.send(f"{player.mention}, you have been refunded {self.buy_in} coins.")
            return

        await self.deal_cards()

    async def cancel_game(self):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        for player in self.players:
            activity_tracker.update_user_activity(player, coins=self.buy_in)
            await self.ctx.send(f"{player.mention}, you have been refunded {self.buy_in} coins.")
        await self.ctx.send("The poker game has been cancelled by the host.")

    async def deal_cards(self):
        self.deck = [f'{value}{suit}' for value in '23456789JQKA' for suit in 'CDHS']
        self.deck.extend([f'10{suit}' for suit in 'CDHS'])
        random.shuffle(self.deck)
        for player in self.players:
            self.player_hands[player] = [self.deck.pop(), self.deck.pop()]
            await self.send_hand(self.ctx, player)
    
    async def send_hand(self, ctx, player, reveal=False):
        hand = self.player_hands[player]
        card_images = [await self.get_card_image(card) for card in hand]
        concatenated_image_path = await self.concatenate_images(card_images, f'poker_{player.id}_hand.png')
        file = discord.File(concatenated_image_path, filename="hand.png")

        if reveal:
            embed = discord.Embed(title=f"{player.display_name}'s Hand")
        else:
            embed = discord.Embed(title="Your Hand")
        
        embed.set_image(url="attachment://hand.png")
        await ctx.send(file=file, embed=embed, ephemeral=True)

    async def get_card_image(self, card):
            card_value = card[:-1]
            card_suit = card[-1].upper()
            if card_value == '10':
                card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, '10', f'10{card_suit}.png')
            else:
                card_value = card_value[0].upper()
                card_image_path = os.path.join(self.DECK_OF_CARDS_FOLDER, card_value, f'{card_value}{card_suit}.png')
            return card_image_path
    
    async def concatenate_images(self, image_paths, filename):
        images = [Image.open(path) for path in image_paths]
        widths, heights = zip(*(img.size for img in images))
        total_width = sum(widths)
        max_height = max(heights)
        new_image = Image.new('RGB', (total_width, max_height))

        x_offset = 0
        for img in images:
            new_image.paste(img, (x_offset, 0))
            x_offset += img.size[0]

        output_path = os.path.join(self.DUMP_IMAGES_FOLDER, filename)
        new_image.save(output_path)

        return output_path

    async def betting_round(self, pre_flop=False):
        self.current_bet = 0 if pre_flop else self.current_bet
        for player in self.betting_order:
            if player in self.all_in_players:
                continue
            await self.prompt_player_action(player)

    async def prompt_player_action(self, player):
        if self.current_bet == 0:
            await self.ctx.send(f"{player.mention}, it's your turn. You can `!check`, `check`, `!fold`, `fold`, `!raise`, `raise`, or `!allin`, `allin`. Your balance: {self.player_balances[player]} {coin_icon}. Pot: {self.pot} {coin_icon}.")
            valid_actions = ['!check', 'check', '!fold', 'fold', '!raise', 'raise', '!allin', 'allin']
        else:
            await self.ctx.send(f"{player.mention}, it's your turn. You can `!call`, `call`, `!fold`, `fold`, `!raise`, `raise`, or `!allin`, `allin`. Your balance: {self.player_balances[player]} {coin_icon}. Pot: {self.pot} {coin_icon}.")
            valid_actions = ['!call', 'call', '!fold', 'fold', '!raise', 'raise', '!allin', 'allin']

        def check(m):
            return m.author == player and m.channel == self.ctx.channel and m.content.lower() in valid_actions

        try:
            msg = await self.bot.wait_for('message', check=check, timeout=120)
            action = msg.content.lower().lstrip('!')
            if action == 'check':
                await self.check(player)
            elif action == 'call':
                await self.call(player)
            elif action == 'fold':
                await self.fold(player)
            elif action == 'raise':
                await self.raise_bet(player)
            elif action == 'allin':
                await self.allin(player)
        except asyncio.TimeoutError:
            await self.fold(player)

    @app_commands.command(name="peek", description="Peek at your hand in the current poker game")
    async def peek(self, interaction: discord.Interaction):
        player = interaction.user
        if player not in self.players:
            await interaction.response.send_message(f"{player.mention}, you are not part of this game!", ephemeral=True)
            return

        await self.send_hand(self.ctx, player)

    async def check(self, player):
        await self.ctx.send(f"{player.mention} checks.")

    async def call(self, player):
        call_amount = self.current_bet - self.player_balances[player]
        if self.player_balances[player] < call_amount:
            await self.allin(player)
        else:
            self.player_balances[player] -= call_amount
            self.pot += call_amount
            await self.ctx.send(f"{player.mention} calls {call_amount} coins. Pot is now {self.pot} {coin_icon}.")

    async def fold(self, player):
        self.betting_order.remove(player)
        await self.ctx.send(f"{player.mention} folds.")

    async def raise_bet(self, player):
        await self.ctx.send(f"{player.mention}, how much would you like to raise? Type an amount or `!allin` or `allin`.")
        def check(m):
            return m.author == player and m.channel == self.ctx.channel
        try:
            msg = await self.bot.wait_for('message', check=check, timeout=120)
            if msg.content.lower().lstrip('!') == 'allin':
                await self.allin(player)
            else:
                try:
                    raise_amount = int(msg.content)
                    if raise_amount > self.player_balances[player]:
                        await self.ctx.send(f"You don't have enough {coin_icon} to raise that amount.")
                        await self.raise_bet(player)
                    else:
                        self.current_bet += raise_amount
                        self.player_balances[player] -= raise_amount
                        self.pot += raise_amount
                        await self.ctx.send(f"{player.mention} raises by {raise_amount} {coin_icon}. Current bet is now {self.current_bet} {coin_icon}. Pot is now {self.pot} {coin_icon}.")
                except ValueError:
                    await self.ctx.send(f"{msg.content} is not a valid amount. Please enter a valid number or type `!allin` or `allin`.")
                    await self.raise_bet(player)
        except asyncio.TimeoutError:
            await self.fold(player)
            await self.fold(player)

    async def allin(self, player):
        allin_amount = self.player_balances[player]
        self.all_in_players.add(player)
        self.player_balances[player] = 0
        self.pot += allin_amount
        await self.ctx.send(f"{player.mention} goes all-in with {allin_amount} {coin_icon}. Pot is now {self.pot} {coin_icon}.")

    async def reveal_community_cards(self, num):
        for _ in range(num):
            self.deck.pop()  # Burn card
            self.community_cards.append(self.deck.pop())
        cards = [await self.get_card_image(card) for card in self.community_cards]
        concatenated_image_path = await self.concatenate_images(cards, 'community_cards.png')
        file = discord.File(concatenated_image_path, filename="community_cards.png")

        embed = discord.Embed(title="Community Cards")
        embed.set_image(url="attachment://community_cards.png")
        await self.ctx.send(file=file, embed=embed)

    async def showdown(self):
        await self.ctx.send("Showdown! Revealing hands...")
        hands = []
        for player in self.betting_order:
            hand = self.player_hands[player] + self.community_cards
            best_hand = self.get_best_hand(hand)
            hands.append((player, best_hand))
            await self.reveal_hand(player, best_hand)

        if not hands:
            await self.ctx.send("No hands to compare, ending showdown.")
            return

        winner = max(hands, key=lambda h: self.hand_rank(h[1]))[0]
        await self.ctx.send(f"{winner.mention} wins the pot of {self.pot} {coin_icon}!")

    async def display_player_list(self):
        if self.players:
            player_list = "\n".join([player.mention for player in self.players])
            embed = discord.Embed(title="Current Player List", description=player_list, color=discord.Color.blue())
            await self.ctx.send(embed=embed)
        else:
            await self.ctx.send("No players have joined yet.")

    def hand_rank(self, hand):
        """
        Determine the rank of a given poker hand.

        :param hand: List of 5 card strings (e.g., ['2H', '3D', '5S', '9C', 'KD'])
        :return: Tuple representing the hand rank and its components for comparison
        """

        # Define card ranks and their corresponding values
        ranks = '2345678910JQKA'
        values = {r: i for i, r in enumerate(ranks.split(), start=2)}

        # Get the numeric value of each card in the hand
        hand_ranks = sorted(
            [values['10'] if card[:-1] == '10' else values[card[0]] for card in hand],
            reverse=True
        )

        # Check for flush (all cards have the same suit)
        is_flush = len(set(card[-1] for card in hand)) == 1

        # Check for straight (consecutive card values)
        is_straight = len(set(hand_ranks)) == 5 and (hand_ranks[0] - hand_ranks[-1] == 4)

        # Special case: A-5 straight
        if hand_ranks == [14, 5, 4, 3, 2]:
            hand_ranks = [5, 4, 3, 2, 1]
            is_straight = True

        # Count the occurrences of each rank in the hand
        rank_counter = {r: hand_ranks.count(r) for r in hand_ranks}
        rank_values = sorted(((count, rank) for rank, count in rank_counter.items()), reverse=True)

        # Determine the rank of the hand
        if is_straight and is_flush:
            return (8, hand_ranks[0])  # Straight flush
        elif rank_values[0][0] == 4:
            return (7, rank_values[0][1], rank_values[1][1])  # Four of a kind
        elif rank_values[0][0] == 3 and rank_values[1][0] == 2:
            return (6, rank_values[0][1], rank_values[1][1])  # Full house
        elif is_flush:
            return (5, hand_ranks)  # Flush
        elif is_straight:
            return (4, hand_ranks[0])  # Straight
        elif rank_values[0][0] == 3:
            return (3, rank_values[0][1], hand_ranks)  # Three of a kind
        elif rank_values[0][0] == 2 and rank_values[1][0] == 2:
            return (2, rank_values[0][1], rank_values[1][1], hand_ranks)  # Two pair
        elif rank_values[0][0] == 2:
            return (1, rank_values[0][1], hand_ranks)  # One pair
        else:
            return (0, hand_ranks)  # High card
        
    def get_best_hand(self, hand):
        """
        From the 7 cards, choose the best 5-card hand.
        """
        all_combinations = itertools.combinations(hand, 5)
        best_hand = max(all_combinations, key=self.hand_rank)
        return best_hand

    async def reveal_hand(self, player, hand):
        cards = [await self.get_card_image(card) for card in hand]
        embed = discord.Embed(title=f"{player.display_name}'s Hand")
        for card in cards:
            embed.set_image(url=card)
        await self.ctx.send(embed=embed)

class CommandHandler(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.duels = {}
        self.blackjack_games = {}
        self.poker_games = {}

    @commands.command(name='challenge')
    async def challenge(self, ctx, opponent_name: str):
        opponent = self.find_member(ctx.guild, opponent_name)
        if opponent is None:
            await ctx.send(f"Could not find a unique member with the name '{opponent_name}'. Please specify a more exact name or use mention.")
            return

        if ctx.author.id in self.duels or opponent.id in self.duels:
            await ctx.send("One of the players is already in a duel!")
            return

        self.duels[ctx.author.id] = Duel(ctx.author.id, opponent.id)
        self.duels[opponent.id] = self.duels[ctx.author.id]

        if opponent == self.bot.user and BOT_TESTING_MODE:
            await self.accept_duel(ctx)
        else:
            await ctx.send(f"{ctx.author.mention} has challenged {opponent.mention} to a duel! Use !accept to accept the challenge.")

    @commands.command(name='accept')
    async def accept_duel(self, ctx):
        if ctx.author.id not in self.duels:
            await ctx.send("You have not been challenged to a duel!")
            return

        duel = self.duels[ctx.author.id]
        duel.generate_letter()
        await ctx.send(f"The duel between {self.bot.get_user(duel.player1).mention} and {self.bot.get_user(duel.player2).mention} has begun! The challenge is to type as many words as you can that start with '{duel.letter}'. The duel will continue until one player's health reaches zero. Type your words separated by spaces.")

        await self.handle_duel(ctx, duel)

    async def handle_duel(self, ctx, duel):
        def check(m):
            return m.channel == ctx.channel and m.author.id in [duel.player1, duel.player2]

        while True:
            msg = await self.bot.wait_for('message', check=check)
            damage = await self.process_message(msg, duel)
            opponent_id = duel.player1 if msg.author.id == duel.player2 else duel.player2
            duel.adjust_health(opponent_id, damage)

            embed = discord.Embed(
                title="Duel Status",
                description=f"{self.bot.get_user(duel.player1).mention} vs {self.bot.get_user(duel.player2).mention}",
                color=discord.Color.red()
            )
            embed.add_field(name=f"{self.bot.get_user(duel.player1).display_name} HP", value=duel.health[duel.player1])
            embed.add_field(name=f"{self.bot.get_user(duel.player2).display_name} HP", value=duel.health[duel.player2])
            await ctx.send(embed=embed)

            winner_id = duel.get_winner()
            if winner_id:
                winner = self.bot.get_user(winner_id)
                await ctx.send(f"{winner.mention} wins the duel!")
                activity_tracker = self.bot.get_cog('ActivityTracker')
                activity_tracker.update_user_activity(winner, points=DUEL_WIN_POINTS, coins=DUEL_WIN_COINS)
                await ctx.send(f"{winner.mention} has been awarded {DUEL_WIN_POINTS} points and {DUEL_WIN_COINS} {coin_icon}! Total {coin_icon}: {activity_tracker.activity_data[str(winner.id)]['coins']}")
                
                del self.duels[duel.player1]
                del self.duels[duel.player2]
                return

    async def process_message(self, msg, duel):
        words = msg.content.split()
        valid_words = []
        for word in words:
            if await duel.is_valid_word(word):
                if word.lower() not in duel.used_words:
                    valid_words.append(word)
                else:
                    await msg.channel.send(f"The word '{word}' has already been used.")
            else:
                await msg.channel.send(f"The word '{word}' is not a valid word.")
        return duel.calculate_damage(valid_words)

    @commands.command(name='blackjack')
    async def blackjack(self, ctx):
        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(ctx.author.id))
        current_coins = stats.get('coins', 0)

        await ctx.send(f"You have {current_coins} {coin_icon}. How many {coin_icon} would you like to bet?")

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content.isdigit()

        while True:
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=30.0)
                bet = int(msg.content)
                if bet > 0 and bet <= current_coins:
                    break
                else:
                    await ctx.send(f"Invalid response. Bet must be a positive number and less than or equal to your balance ({current_coins} {coin_icon}). You have 30 seconds to respond accurately.")
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond! Please use !blackjack again.")
                return

        game = BlackjackGame(ctx.author, self.bot)
        await game.start_game(bet)
        self.blackjack_games[ctx.author.id] = game

        await game.send_hand(ctx)

    @commands.command(name='hit')
    async def hit(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.hit(ctx)

    @commands.command(name='stand')
    async def stand(self, ctx):
        game = self.blackjack_games.get(ctx.author.id)
        if game:
            await game.stand(ctx)

    @commands.command(name='peek')
    async def peek(self, ctx):
        # Ensure the author is part of an active poker game
        for game in self.poker_games.values():
            if ctx.author in game.players:
                await game.peek(ctx)
                return
        await ctx.send(f"{ctx.author.mention}, you are not part of an active poker game!")

    def find_member(self, guild, name):
        members = [member for member in guild.members if member.display_name.lower() == name.lower()]
        if len(members) == 1:
            return members[0]
        return None
    
    @commands.command(name='poker')
    async def start_poker(self, ctx):
        if ctx.author.id in self.poker_games:
            await ctx.send("You are already in a game!")
            return

        activity_tracker = self.bot.get_cog('ActivityTracker')
        stats = activity_tracker.get_statistics(str(ctx.author.id))
        current_coins = stats.get('coins', 0)

        await ctx.send(f"You have {current_coins} {coin_icon}. How many {coin_icon} would you like to set as the buy-in amount for the game?")

        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content.isdigit()

        while True:
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=30.0)
                buy_in = int(msg.content)
                if buy_in > 0 and buy_in <= current_coins:
                    break
                else:
                    await ctx.send(f"Invalid response. Buy-in must be a positive number and less than or equal to your balance ({current_coins} {coin_icon}). You have 30 seconds to respond accurately.")
            except asyncio.TimeoutError:
                await ctx.send("You took too long to respond! Please use !poker again.")
                return

        game = PokerGame(ctx, self.bot, buy_in)
        self.poker_games[ctx.author.id] = game
        try:
            await game.start_game()
        finally:
            del self.poker_games[ctx.author.id]

        @commands.command(name='join poker')
        async def join_poker(self, ctx):
            if ctx.author.id not in self.poker_games:
                await ctx.send("You need to start a game first using !poker.")
                return
            game = self.poker_games[ctx.author.id]
            await game.collect_players()

    @commands.command(name='peek')
    async def peek(self, ctx):
        # Ensure the author is part of an active poker game
        for game in self.poker_games.values():
            if ctx.author in game.players:
                await game.peek(ctx)
                return
        await ctx.send(f"{ctx.author.mention}, you are not part of an active poker game!")

    @commands.command(name='forcestart')
    async def forcestart(self, ctx):
        # Ensure the author is part of an active poker game
        game = self.poker_games.get(ctx.author.id)
        if not game:
            await ctx.send(f"{ctx.author.mention}, you are not hosting any poker game!")
            return

        if len(game.players) >= game.POKER_MIN_PLAYERS:
            await ctx.send("Minimum player requirements met. Starting the game now!")
            await game.start_game()
        else:
            await ctx.send(f"Not enough players to start the game. Minimum required is {game.POKER_MIN_PLAYERS}.")

async def setup(bot):
    await bot.add_cog(CommandHandler(bot))

.\bot\level_widget.py
import discord
from discord.ext import commands

class LevelWidget(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        print("LevelWidget initialized")

async def setup(bot):
    print("Setting up LevelWidget")
    await bot.add_cog(LevelWidget(bot))
    print("LevelWidget added to bot")


.\bot\shop.py
# bot/shop.py
import discord
from discord.ext import commands
from discord.ui import View, Button
import os

class PaginatedShopView(View):
    def __init__(self, items, per_page=5):
        super().__init__(timeout=60)
        self.items = items
        self.per_page = per_page
        self.current_page = 0
        self.add_item(Button(label="Previous", style=discord.ButtonStyle.secondary, custom_id="previous_page"))
        self.add_item(Button(label="Next", style=discord.ButtonStyle.secondary, custom_id="next_page"))

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        return interaction.user == self.message.author

    @discord.ui.button(label='Previous', style=discord.ButtonStyle.secondary)
    async def previous_page(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.current_page -= 1
        await self.update_embed(interaction)

    @discord.ui.button(label='Next', style=discord.ButtonStyle.secondary)
    async def next_page(self, button: discord.ui.Button, interaction: discord.Interaction):
        self.current_page += 1
        await self.update_embed(interaction)

    async def update_embed(self, interaction: discord.Interaction):
        start = self.current_page * self.per_page
        end = start + self.per_page
        items = self.items[start:end]
        
        embed = discord.Embed(
            title="Casino Shop",
            description="Welcome to the Casino Shop! Here are some items you can purchase:",
            color=discord.Color.blue()
        )
        
        for item in items:
            embed.add_field(name=item['name'], value=f"{item['description']} - {item['price']} {item['icon']}", inline=False)
        
        await interaction.response.edit_message(embed=embed, view=self)

class Shop(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='shop')
    async def shop(self, ctx):
        items = [
            {'name': 'Virtual Pet', 'description': 'A cute virtual pet.', 'price': 100, 'icon': "<:coin:>"},
            {'name': 'Badge', 'description': 'A collectible badge.', 'price': 50, 'icon': "<:coin:>"},
            {'name': 'Game Tokens', 'description': 'Tokens for playing games.', 'price': 20, 'icon': "<:coin:>"}
        ]
        view = PaginatedShopView(items)
        await ctx.send(embed=view.create_embed(), view=view)


async def setup(bot):
    await bot.add_cog(Shop(bot))


.\bot\__init__.py


.\bot\status\offline.py
import aiohttp
import asyncio
import pytz
from datetime import datetime, timedelta
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    def get_estimated_time_back_up(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        estimated_time = now + timedelta(hours=16)
        hour = estimated_time.hour if estimated_time.hour <= 12 else estimated_time.hour - 12
        period = "AM" if estimated_time.hour < 12 else "PM"
        formatted_time = f"{hour}:{estimated_time.strftime('%M')} {period} EST"
        return estimated_time.strftime("%m/%d/%Y"), formatted_time

    def get_most_recent_script(self):
        scripts_directory = 'bot'
        scripts = [os.path.join(root, file) for root, _, files in os.walk(scripts_directory) for file in files if file.endswith('.py')]
        if not scripts:
            return "Unknown Script", "No recent updates detected"

        most_recent_script = max(scripts, key=lambda x: os.path.getmtime(x))
        script_name = os.path.basename(most_recent_script).replace('.py', '').capitalize()
        return script_name, f"Developing/Fixing the {script_name} feature"

    async def update_status_offline(self):
        current_date, current_time = self.get_current_time()
        estimated_date, estimated_time_back_up = self.get_estimated_time_back_up()
        script_name, reasoning = self.get_most_recent_script()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** OFFLINE

**Reasoning:** {reasoning}
**Estimated Date Back Up:** {estimated_date}
**Estimated Time Back Up:** {estimated_time_back_up}
**Impact on Users:** Inability to use bot
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to OFFLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_offline()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_offline()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\online.py
import aiohttp
import asyncio
import pytz
from datetime import datetime
import os
import sys

class StatusUpdater:
    def __init__(self):
        self.channel_id = 1261247614167285780  # Replace with your actual channel ID
        self.status_message_id = 1262292296104411258  # Replace with your actual message ID
        self.bot_token = os.getenv('TOKEN')
        self.additional_notes = "N/A"

    def get_current_time(self):
        now = datetime.now(pytz.timezone('US/Eastern'))
        hour = now.hour if now.hour <= 12 else now.hour - 12
        period = "AM" if now.hour < 12 else "PM"
        formatted_time = f"{hour}:{now.strftime('%M')} {period} EST"
        return now.strftime("%m/%d/%Y"), formatted_time

    async def update_status_online(self):
        current_date, current_time = self.get_current_time()

        async with aiohttp.ClientSession() as session:
            async with session.patch(
                f'https://discord.com/api/v9/channels/{self.channel_id}/messages/{self.status_message_id}',
                headers={"Authorization": f"Bot {self.bot_token}"},
                json={
                    "content": f'''**Bot Status Report**

**Date:** {current_date}
**Time:** {current_time}

**Bot:** Fred
**Status:** ONLINE

**Reasoning:** Bot started successfully
**Estimated Date Back Up:** N/A
**Estimated Time Back Up:** N/A
**Impact on Users:** Fully operational
**Additional Notes:** {self.additional_notes}'''
                }
            ) as response:
                if response.status == 200:
                    print("Status message updated to ONLINE.")
                else:
                    print(f"Failed to update status message. HTTP status: {response.status}")

    async def update_additional_notes(self, notes):
        self.additional_notes = notes
        await self.update_status_online()

async def main():
    updater = StatusUpdater()
    if len(sys.argv) > 1:
        notes = " ".join(sys.argv[1:])
        await updater.update_additional_notes(notes)
    else:
        await updater.update_status_online()

if __name__ == "__main__":
    asyncio.run(main())


.\bot\status\setup.py
from . import offline, online

async def setup(bot):
    pass  # No need to add any cogs or extensions here as the status scripts are executed separately


.\settings\settings.py
import json 
import os

def load_settings():
    # Get the current directory of the settings.py file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    # Construct the path to the settings.json file
    settings_path = os.path.join(current_dir, 'json', 'settings.json')
    # Open and load the settings.json file
    with open(settings_path, 'r', encoding='utf-8') as f:
        settings = json.load(f)
    return settings

.\utils\graphics.py
# utils/graphics.py
import matplotlib.pyplot as plt  # Importing the Matplotlib library for creating visualizations
import matplotlib.patches as patches  # Importing patches to draw shapes
import requests  # Importing requests to download images from the web
from PIL import Image  # Importing Pillow to handle image processing
from io import BytesIO  # Importing BytesIO to handle image data in memory
import numpy as np
import os  # Importing os to handle file paths

# This function generates an image showing the user's level information.
# utils/graphics.py
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import requests
from PIL import Image
from io import BytesIO
import os

def generate_level_image(username, level, progress, points, next_level, avatar_url):
    try:
        # Download the avatar image from the provided URL
        response = requests.get(avatar_url)
        avatar = Image.open(BytesIO(response.content)).resize((225, 225))

        # Create a new figure
        fig, ax = plt.subplots(figsize=(7, 2))

        # Set background color
        fig.patch.set_facecolor((255/255, 127/255, 80/255))  # Light Pink
        ax.set_facecolor((173/255, 216/255, 230/255))  # Light Blue 

        ax.set_xlim(0, 1000)
        ax.set_ylim(0, 250)
        ax.axis('off')

        # Draw the avatar image
        plt.imshow(avatar, aspect='auto', extent=(10, 10 + avatar.size[0], 12.5, 12.5 + avatar.size[1]))

        font_properties1 = {'family': 'Comic Sans MS', 'weight': 'bold', 'size': 25}
        font_properties2 = {'family': 'Comic Sans MS', 'size': 18}

        # Draw the username and points text
        plt.text(250, 200, username, fontdict=font_properties1, color='white', ha='left', va='center')
        plt.text(250, 135, f"{points} points", fontdict=font_properties2, color='white', ha='left', va='center')

        # Define progress bar
        bar_width = 350
        bar_height = 60
        bar_x = (1000 - bar_width + 225) / 2
        bar_y = 20

        # Draw progress bar background
        ax.add_patch(patches.Rectangle((bar_x, bar_y), bar_width, bar_height, color=(255/255, 255/255, 255/255), alpha=0.3))

        # Draw filled part of progress bar
        fill_width = progress * 3.5
        ax.add_patch(patches.Rectangle((bar_x, bar_y), fill_width, bar_height, color=(76/255, 175/255, 80/255)))

        # Draw level and progress percentage
        plt.text(bar_x - 15, (bar_y + bar_height / 2) - 12.5, f"{level}", fontdict=font_properties1, color='white', ha='right', va='center')
        plt.text(bar_x + bar_width / 2, bar_y + bar_height / 2, f"{progress:.2f}%", fontsize=15, color='white', ha='center', va='center')
        plt.text(bar_x + bar_width + 15, (bar_y + bar_height / 2) - 12.5, f"{next_level}", fontdict=font_properties1, color='white', ha='left', va='center')

        # Save image
        image_path = 'level_image.png'
        plt.savefig(image_path, bbox_inches='tight', pad_inches=0, dpi=100)
        plt.close()

        if os.path.exists(image_path):
            return image_path
        else:
            print("Error: Image file was not created.")
            return None

    except Exception as e:
        print(f"Error in generate_level_image: {e}")
        return None

def generate_statistics_visualization(stats):
    labels = ['Messages Sent', 'Minutes in Voice', 'Minutes Online']
    user_values = [stats.get('messages_sent', 0), stats.get('minutes_in_voice', 0), stats.get('minutes_online', 0)]
    server_averages = [100, 50, 300]  # These values should be calculated based on your server's data

    x = np.arange(len(labels))

    fig, ax = plt.subplots()
    ax.bar(x - 0.2, user_values, width=0.4, label='User')
    ax.bar(x + 0.2, server_averages, width=0.4, label='Server Average')

    ax.set_xlabel('Activity')
    ax.set_ylabel('Count')
    ax.set_title('User Activity vs Server Average')
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend()

    plt.tight_layout()
    plt.savefig('utils/images/statistics_visualization.png')
    plt.close()

    return 'utils/images/statistics_visualization.png'

.\utils\__init__.py


